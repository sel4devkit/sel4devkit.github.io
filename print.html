<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>seL4 Developer Kit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A developer kit for the seL4 microkernel on the Avnet MaaXBoard SBC (Single Board Computer).">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/audience.html"><strong aria-hidden="true">1.1.</strong> Audience</a></li><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="introduction/structure.html"><strong aria-hidden="true">1.3.</strong> Structure</a></li></ol></li><li class="chapter-item expanded "><a href="resources/main.html"><strong aria-hidden="true">2.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/sel4_microkernel.html"><strong aria-hidden="true">2.1.</strong> seL4 Microkernel</a></li><li class="chapter-item expanded "><a href="resources/avent_maaxboard.html"><strong aria-hidden="true">2.2.</strong> Avent MaaXBoard</a></li><li class="chapter-item expanded "><a href="resources/repositories.html"><strong aria-hidden="true">2.3.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="resources/glossary.html"><strong aria-hidden="true">2.4.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="development_platform/main.html"><strong aria-hidden="true">3.</strong> Development Platform</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development_platform/hardware_requirements.html"><strong aria-hidden="true">3.1.</strong> Hardware Requirements</a></li><li class="chapter-item expanded "><a href="development_platform/software_requirements.html"><strong aria-hidden="true">3.2.</strong> Software Requirements</a></li></ol></li><li class="chapter-item expanded "><a href="install_and_configure/main.html"><strong aria-hidden="true">4.</strong> Install and Configure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install_and_configure/host_setup.html"><strong aria-hidden="true">4.1.</strong> Host Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/build_environment_setup.html"><strong aria-hidden="true">4.2.</strong> Build Environment Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/target_setup.html"><strong aria-hidden="true">4.3.</strong> Target Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/bootloader_setup.html"><strong aria-hidden="true">4.4.</strong> Bootloader Setup</a></li></ol></li><li class="chapter-item expanded "><a href="first_boot/main.html"><strong aria-hidden="true">5.</strong> First Boot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_boot/bootloader.html"><strong aria-hidden="true">5.1.</strong> Bootloader</a></li><li class="chapter-item expanded "><a href="first_boot/sel4test.html"><strong aria-hidden="true">5.2.</strong> seL4Test</a></li><li class="chapter-item expanded "><a href="first_boot/camkes_adder.html"><strong aria-hidden="true">5.3.</strong> CAmkES Adder</a></li><li class="chapter-item expanded "><a href="first_boot/microkit_hello_world.html"><strong aria-hidden="true">5.4.</strong> Microkit Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="activities/main.html"><strong aria-hidden="true">6.</strong> Activities</a></li><li class="chapter-item expanded "><a href="activity/microkit_memory_probe/main.html"><strong aria-hidden="true">7.</strong> Activity: Microkit Memory Probe</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/main.html"><strong aria-hidden="true">8.</strong> Activity: Device Drivers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="device_driver_intro.html"><strong aria-hidden="true">8.1.</strong> Device Driver Introduction</a></li><li class="chapter-item expanded "><a href="uboot_driver_library.html"><strong aria-hidden="true">8.2.</strong> U-Boot Driver Library Overview</a></li><li class="chapter-item expanded "><a href="uboot_driver_usage.html"><strong aria-hidden="true">8.3.</strong> Using the U-Boot Driver Library</a></li><li class="chapter-item expanded "><a href="uboot_library_add_platform.html"><strong aria-hidden="true">8.4.</strong> Library Extension - New Platform</a></li><li class="chapter-item expanded "><a href="uboot_library_add_driver.html"><strong aria-hidden="true">8.5.</strong> Library Extension - New Driver</a></li></ol></li><li class="chapter-item expanded "><a href="activity/spi_bus_bmp280_pressure_sensor/main.html"><strong aria-hidden="true">9.</strong> Activity: SPI Bus BMP280 Pressure Sensor</a></li><li class="chapter-item expanded "><a href="activity/case_study_application/main.html"><strong aria-hidden="true">10.</strong> Activity: Case Study Applicaton</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/main.html"><strong aria-hidden="true">11.</strong> Activity: CAmkES Case Study Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/architecture.html"><strong aria-hidden="true">11.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/detail.html"><strong aria-hidden="true">11.2.</strong> Design</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/build.html"><strong aria-hidden="true">11.3.</strong> Build</a></li></ol></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/main.html"><strong aria-hidden="true">12.</strong> Activity: Microkit Case Study Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/architecture.html"><strong aria-hidden="true">12.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/detail.html"><strong aria-hidden="true">12.2.</strong> Design</a></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/build.html"><strong aria-hidden="true">12.3.</strong> Build</a></li></ol></li><li class="chapter-item expanded "><a href="activity/microkit_usb_driver/main.html"><strong aria-hidden="true">13.</strong> Activity: Microkit USB Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_hdmi_driver/main.html"><strong aria-hidden="true">14.</strong> Activity: Microkit HDMI Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_single_linux_guest/main.html"><strong aria-hidden="true">15.</strong> Activity: Microkit VMM Single Linux Guest</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_tty_multiplex/main.html"><strong aria-hidden="true">16.</strong> Activity: Microkit VMM Dual Linux Guest TTY Multiplex</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_usb_routing/main.html"><strong aria-hidden="true">17.</strong> Activity: Microkit VMM Dual Linux Guest USB Routing</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="licensing.html">Licensing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">seL4 Developer Kit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sel4devkit/sel4devkit-manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <a href="https://sel4.systems">seL4® Microkernel</a> is a technology of
increasing interest. It delivers specific capabilities and assurances, which
make it particularly suitable for applications that demand a trusted execution
environment and strong separation of concerns.</p>
<p>The seL4 Microkernel is engineered to deliver both high-assurance and
high-performance (<a href="https://sel4.systems/About/seL4-whitepaper.pdf">The seL4 Microkernel: An
Introduction</a>). High-assurance
is achieved through comprehensive formal verification. High-performance is
achieved through deliberate design and profiling, potentially accepting
greater complexity in the formal verification where this achieves higher
performance.</p>
<p>The development of the seL4 Microkernel is overseen by the <a href="https://sel4.systems/Foundation/">seL4
Foundation</a>, operating as project under The
<a href="https://www.linuxfoundation.org/">Linux Foundation</a>. The entirety of the seL4
Microkernel, and its associated components, are made available as Open Source,
on Git Hub (<a href="https://github.com/seL4">seL4 Microkernel and associated
components</a>).</p>
<p>In common with all Microkernels, the seL4 Microkernel provides a minimum set
of essential features as needed to frame a viable OS (Operating System). There
is an expectation that further components will be introduced atop this OS, in
developing useful applications (such as drivers, libraries, and services).</p>
<p>As a consequence, developing on top of the seL4 microkernel is currently
complex and time-consuming, and the expertise is limited to a small number of
individuals and organisations. Thus, this seL4 Developer Kit is created to
reduce the barrier to entry for developing on top of seL4 Microkernel. The
overall intention is to encourage and support more organisations in adopting
seL4 in their projects and products.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="audience"><a class="header" href="#audience">Audience</a></h2>
<p>The intended audience is an application developer:</p>
<ul>
<li>Experienced in programming within a Linux, macOS, or Windows environment.</li>
<li>Already familiar with seL4 concepts and benefits.</li>
<li>Looking for practical guidance in getting started with seL4.</li>
</ul>
<h3 id="complementary-approach"><a class="header" href="#complementary-approach">Complementary Approach</a></h3>
<p>This seL4 Developer Kit does not intend to cover or replace any of the
extensive material as maintained by the (<a href="https://sel4.systems">seL4
Foundation</a>) and associated organisations.</p>
<p>Instead, the purpose is to complement this existing material with practical
guidance about getting started with seL4. Throughout the seL4 Developer Kit,
reference is made to externally maintained material where appropriate.</p>
<h3 id="focus-on-sel4-details"><a class="header" href="#focus-on-sel4-details">Focus on seL4 Details</a></h3>
<p>Whilst the seL4 Developer Kit aims to cover all the important configuration
steps, it does assume a reasonable level of developer knowledge. In general,
priority and prominence is given to seL4 specific details, while more routine
aspects are explained at a higher level or through external reference (such as
installing software or interacting with configuration management).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The seL4 Developer Kit intends to support developers in gaining familiarity
with seL4 Microkernel, and ultimately to encourage more use of seL4 within
projects and products. It does this by:</p>
<ul>
<li>
<p>Selecting a readily available low-cost SBC (Single Board Computer) as the
target platform ((The <a href="introduction/%22../avent_maaxboard/main.html">Avnet MaaXBoard</a>).</p>
</li>
<li>
<p>Identifying the minimum needed to create a viable development platform, and
detailing specific hardware and software requirements to achieve this.</p>
</li>
<li>
<p>Supplying preconfigured build environments, plus associated examples, with
all the content required to generate seL4 executable programs.</p>
</li>
<li>
<p>Demonstrating how an seL4 executable program can be loaded and executed on
the chosen target platform.</p>
</li>
<li>
<p>Documenting the specific steps needed, along with more general guidance.</p>
</li>
</ul>
<p>Once the fundamentals of building and executing an seL4 program are
established, the seL4 Developer Kit seeks to explain and encourage further
development through the presentation of a diverse series of technical
(<a href="introduction/%22../activities/activities.html">Activities</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The seL4 Developer Kit is structured into the following sections to provide a
step-by-step guide:</p>
<ul>
<li>
<p><strong>Introduction</strong>: Introduce the potential benefits that the seL4 Microkernel
offers, acknowledge its steep learning curve, and position the seL4
Developer Kit as a means to help facilitate and encourage wider adoption.</p>
</li>
<li>
<p><strong>Resources</strong>: Provides an overview of the fundamental aspects of both the
seL4 Microkernel and the Avent MaaXBoard (our chosen SBC (Single Board
Computer)), highlighting relevant supporting material from other sources. The
technical scope of the seL4 Developer Kit is summerised though a list of its
associated repositories. Finally, a consolidated glossary of key terms is
presented for easy reference.</p>
</li>
<li>
<p><strong>Development Platform</strong>: Identify and explain the minimum hardware and
software requirements needed to assemble a viable development platform for
using the seL4 Developer Kit. It is expected that, to meet these requirements,
some equipment will need to be purchased (for example, an Avent MaaXBoard).</p>
</li>
<li>
<p><strong>Install and Configure</strong>: Provides guidance, and explores options, in
installing and configuring the development platform. Once complete, the
development platform will be ready for building sel4 programs, loading such
programs onto the target, and executing these programs on the target, with
terminal (text) input and output available.</p>
</li>
<li>
<p><strong>First Boot</strong>: Utilising a previously prepared development platform, walk
through the steps in powering up the target (Avnet MaaXBoard), interacting
with the bootloader, and building and executing a small number of example
programs. On completion of this step, the development platform is prepared and
proven to operate.</p>
</li>
<li>
<p><strong>Activities</strong>: With the development platform established, a series of
distinct technical activities are undertaken. Each Activity describes both
its approach, and the eventual outcome, seeking to illustrate how sel4
development may be practically progressed.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>Presents for immediate reference a summary of the various resources associated
with seL4 Developer Kit.</p>
<h2 id="supporting-material"><a class="header" href="#supporting-material">Supporting Material</a></h2>
<p>The seL4 Developer Kit makes use of a large collection of existing material.
Here, we summarise and reference this material, explaining its relevance to
the seL4 Developer Kit.</p>
<p>Distinct areas considered are listed below:</p>
<ul>
<li><a href="resources/%22../resources/sel4_microkernel.html">seL4 Microkernel</a></li>
<li><a href="resources/%22../resources/avent_maaxboard.html">Avent MaaXBoard</a></li>
</ul>
<h2 id="repositories"><a class="header" href="#repositories">Repositories</a></h2>
<p>A summarised list of all the repositories that form part of the seL4 Developer
Kit is presented to support their navigation:</p>
<ul>
<li><a href="resources/reference/repositories.html">Repositories</a></li>
</ul>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p>A consolidated glossary of key terms is presented for easy reference:</p>
<ul>
<li><a href="resources/reference/glossary.html">Glossary</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-1"><a class="header" href="#todo-1">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-2"><a class="header" href="#todo-2">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#AArch32">AArch32</a></td><td>Execution state of <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#64/32-bit_architecture">ARMv8</a> architecture using 32-bit wide general-purpose registers.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/AArch64">AArch64</a></td><td>Execution state of <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#64/32-bit_architecture">ARMv8</a> architecture using 64-bit wide general-purpose registers.</td></tr>
<tr><td><a href="https://www.avnet.com">Avnet</a></td><td>The manufacturer of the MaaXBoard SBC.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Bootloader">Bootloader</a></td><td>The tool responsible for booting a computer. Responsible for initialisation of software following by loading and execution of software.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/camkes">CAmkES</a></td><td>Component Architecture for microkernel-based Embedded Systems. An abstraction layer on top of seL4 providing a software development and runtime framework for quickly and reliably building microkernel-based multiserver (operating) systems.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Devicetree">Device Tree</a></td><td>A <a href="https://www.devicetree.org/specifications">standardised data structure</a> with nodes that describe the hardware components of a computer system. Associated with device trees are DTS files (Device Tree Source - a textual representation of a device tree), DTB files (Device Tree Blob - a binary representation of a device tree), and DTC (Device Tree Compiler - a tool used to convert between device tree formats, e.g. DTS to DTB).</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a></td><td>Direct Memory Access. A feature that allows certain hardware subsystems to access main system memory independently of the central processing unit (CPU), typically used by devices that need to transfer bulk data (e.g. USB).</td></tr>
<tr><td><a href="https://www.docker.com">Docker</a></td><td>A tool that allows packaging of an application and its dependencies within a container, with fewer overheads than a virtual machine. It is used in this developer kit to provide a standardised build environment.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/General-purpose_input/output#Board-level_GPIOs">GPIO</a></td><td>General-Purpose Input/Output. A digital signal pin on an integrated circuit or electronic circuit board which may be used as an input or output, or both, and is controllable by software.</td></tr>
<tr><td><a href="https://www.ncsc.gov.uk/whitepaper/security-architecture-anti-patterns">High-side</a></td><td>In a security context, 'more trusted' or 'high-side' refers to a system in which there is more confidence of its integrity.</td></tr>
<tr><td><a href="https://www.ncsc.gov.uk/whitepaper/security-architecture-anti-patterns">Low-side</a></td><td>In a security context, 'less trusted' or 'low-side' refers to a system in which there is less confidence of its integrity.</td></tr>
<tr><td><a href="https://www.avnet.com/wps/portal/us/products/avnet-boards/avnet-board-families/maaxboard/maaxboard">MaaXBoard</a></td><td>An <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-8-applications-processors/i-mx-8m-family-armcortex-a53-cortex-m4-audio-voice-video:i.MX8M">NXP i.MX 8M SoC</a> based SBC. Selected as the target platform for this developer kit.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a></td><td>Single Board Computer. A complete computer on a single circuit board. The Avnet MaaXBoard is an example of a SBC.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/sel4test">seL4Test</a></td><td>Test suite for seL4 developed and maintained by the seL4 Foundation.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a></td><td>System on chip. A chip that integrates all or most components of a computer. The SoC on the MaaXBoard is the <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-8-applications-processors/i-mx-8m-family-armcortex-a53-cortex-m4-audio-voice-video:i.MX8M">NXP i.MX 8M</a>.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">TFTP</a></td><td>Trivial File Transfer Protocol. A simple file transfer protocol commonly used in the early stages of bootloading from a local area network.</td></tr>
<tr><td><a href="https://www.denx.de/wiki/U-Boot">U-Boot</a></td><td>Das U-Boot (known as "the Universal Boot Loader" and often shortened to U-Boot) is an open-source bootloader commonly used in embedded devices.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a></td><td>Universal Asynchronous Receiver-Transmitter. A simple serial communication device commonly used by SBCs.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/microkit">Microkit</a></td><td>Operating system framework on top of seL4 that provides a small set of simple abstractions that ease the design and implementation of statically structured systems on seL4, while still leveraging the kernel’s benefits of security and performance</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a></td><td>Single Board Computer. A complete computer on a single circuit board. The Avnet MaaXBoard is an example of a SBC.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/sel4test">seL4Test</a></td><td>Test suite for seL4 developed and maintained by the seL4 Foundation.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="development-platform"><a class="header" href="#development-platform">Development Platform</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-boot"><a class="header" href="#first-boot">First Boot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-setup"><a class="header" href="#host-setup">Host Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-environment-setup"><a class="header" href="#build-environment-setup">Build Environment Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup"><a class="header" href="#bootloader-setup">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup-1"><a class="header" href="#bootloader-setup-1">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="activities"><a class="header" href="#activities">Activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-3"><a class="header" href="#todo-3">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-drivers"><a class="header" href="#device-drivers">Device Drivers</a></h1>
<ul>
<li><a href="activity/device_drivers/device_driver_intro.html">Device Driver Introduction</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html">U-Boot Driver Library Overview</a></li>
<li><a href="activity/device_drivers/uboot_driver_usage.html">Using the U-Boot Driver Library</a></li>
<li><a href="activity/device_drivers/uboot_library_add_platform.html">Library Extension - New Platform</a></li>
<li><a href="activity/device_drivers/uboot_library_add_driver.html">Library Extension - New Driver</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-driver-introduction"><a class="header" href="#device-driver-introduction">Device Driver Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u-boot-driver-library-overview"><a class="header" href="#u-boot-driver-library-overview">U-Boot Driver Library Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-u-boot-driver-library"><a class="header" href="#using-the-u-boot-driver-library">Using the U-Boot Driver Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-platform"><a class="header" href="#library-extension---new-platform">Library Extension - New Platform</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-driver"><a class="header" href="#library-extension---new-driver">Library Extension - New Driver</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-4"><a class="header" href="#todo-4">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream
This section works through an example to show some of our device drivers being used within a larger application. It is nominally labelled as a 'security domain' demonstrator (named <code>security_demo</code>) but this is mainly in the context of being a keyboard-based encryption device that was inspired by an Enigma machine! It is intentionally simple and its main purpose is to show data separation and to provide worked examples of inter-component communications using different seL4 mechanisms.</p>
<h1 id="extra-functionality-within-the-demonstration-application-is-deliberately-kept-to-a-minimum-to-leave-the-source-code-less-cluttered-so-that-the-developer-can-readily-see-the-more-interesting-sel4-inter-component-and-device-interactions-without-too-much-extra-feature-supporting-code-in-line-with-the-rest-of-the-developer-kit-the-demonstration-application-is-intended-to-be-more-of-a-springboard-for-a-developer-kit-user-than-a-polished-product-for-an-end-user"><a class="header" href="#extra-functionality-within-the-demonstration-application-is-deliberately-kept-to-a-minimum-to-leave-the-source-code-less-cluttered-so-that-the-developer-can-readily-see-the-more-interesting-sel4-inter-component-and-device-interactions-without-too-much-extra-feature-supporting-code-in-line-with-the-rest-of-the-developer-kit-the-demonstration-application-is-intended-to-be-more-of-a-springboard-for-a-developer-kit-user-than-a-polished-product-for-an-end-user">Extra functionality within the demonstration application is deliberately kept to a minimum to leave the source code less cluttered, so that the developer can readily see the 'more interesting' seL4 inter-component and device interactions without too much extra, feature-supporting code. In line with the rest of the developer kit, the demonstration application is intended to be more of a springboard for a developer kit user than a polished product for an end user.</a></h1>
<p>This case study works through an example to show some of our device drivers being used within a larger application. It is nominally labelled as a 'security domain' demonstrator (named <code>security_demo</code>) but this is mainly in the context of being a keyboard-based encryption device that was inspired by an Enigma machine! It is intentionally simple and its main purpose is to show data separation and to provide worked examples of inter-component communications using different seL4 mechanisms.</p>
<p>Extra functionality within the demonstration application is deliberately kept to a minimum to leave the source code less cluttered, so that the developer can readily see the 'more interesting' seL4 inter-component and device interactions without too much extra, feature-supporting code. In line with the rest of the developer kit, the demonstration application is intended to be more of a springboard for a developer kit user than a polished product for an end user.</p>
<p>The case study has been produced for both frameworks (CAmkES and Microkit):</p>
<ul>
<li>
<p><a href="activity/case_study_application/../camkes_case_study_application/main.html">CAmkES case study</a></p>
</li>
<li>
<p><a href="activity/case_study_application/../microkit_case_study_application/main.html">Microkit case study</a></p>
</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Stashed changes</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-5"><a class="header" href="#todo-5">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>We defer to the seL4 Foundation's documentation of CAmkES as the primary source of understanding of CAmkES, but this section will cover aspects of the use of CAmkES where appropriate.</p>
<h2 id="basic-description"><a class="header" href="#basic-description">Basic Description</a></h2>
<p>An operator types a plaintext message using a USB-connected keyboard. The application encrypts the message and transmits the resulting ciphertext via Ethernet to a client that has connected to a predetermined port. The application also records the ciphertext messages in a logfile on the SD card of the device.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The architecture of the demonstrator is shown below.</p>
<p><img src="activity/camkes_case_study_application/encrypter_arch.png" alt="Demonstrator architecture" /></p>
<p>Blue blocks show CAmkES components created specifically for the security demonstrator (or previously created within the developer kit in the case of <a href="activity/camkes_case_study_application/../device_drivers/uboot_driver_usage.html#test-application-picoserver_uboot">EthDriverUboot</a>); grey blocks show CAmkES <a href="https://github.com/seL4/global-components">global components</a>.</p>
<p>Arrow directions show an abstracted view of data flow. Arrow labels refer to seL4 connector types (some concerned with data flow, some with control flow), which are elaborated in the key. More details about seL4 connector types may be found in the <a href="https://docs.sel4.systems/projects/camkes/manual.html">CAmkES manual</a>, but the fundamental types are <em>RPC</em> (Remote Procedure Call), <em>SharedData</em>, and <em>Notification</em> (see examples such as <code>seL4RPCCall</code> in the key).</p>
<p>As the KeyReader and Crypto components handle plaintext and cryptographic data (e.g. keys), they are considered as 'high-side' in terms of security and must be kept separate from the downstream 'low-side' components that handle ciphertext. It is not the role of this developer kit to re-justify the credentials of seL4 (the <a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4 whitepaper</a> is a good starting point), but suffice to say that seL4's capability-based access controls guarantee protection and separation between all components, regardless of the notional high and low sides that we have overlaid, only allowing interactions between components where explicitly established via the seL4 connector types.</p>
<p>The following paragraphs briefly describe the data flow, from left to right, highlighting the different seL4 mechanisms used for inter-component communications.</p>
<h3 id="components-and-connector-types"><a class="header" href="#components-and-connector-types">Components and Connector Types</a></h3>
<p>Plaintext characters are typed on a keyboard and read by the KeyReader component. These characters are then 'encrypted' by the Crypto component to transform them into ciphertext. <em>RPC</em> is an appropriate connector type for the character-by-character data flow between KeyReader and Crypto (labelled as RPC-1 on the diagram), employing <code>seL4RPCCall</code>. Since this application is more concerned with demonstrating seL4 concepts than crypto-algorithms, the Enigma machine's rotors and plugboard are replaced with a simple <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> algorithm!</p>
<p>The encrypted characters are transferred to the Transmitter component via a shared circular buffer, where Crypto writes to the <em>head</em> of the buffer and Transmitter reads from its <em>tail</em>. The buffer is implemented as a <em>SharedData</em> connection (labelled as SharedData-1 on the diagram) using <code>seL4SharedData</code>. (Note that within CAmkES, shared memory is abstracted as a <em>Dataport</em>, so this terminology is often seen associated with this connection type.)</p>
<p>If the buffer is full, Crypto discards characters; otherwise, each time Crypto writes a character to the buffer, it sends a <em>Notification</em> to Transmitter (labelled as Notification-1 on the diagram) to signify that there is data to read, using <code>seL4Notification</code>. Transmitter acts upon notifications by reading all available characters until the buffer is empty.</p>
<p>The shared buffer is protected from concurrent access by use of a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>. The mutex is owned by Crypto, and Transmitter accesses its lock and unlock operations via an <em>RPC</em> connection (labelled as RPC-2); note that this is a control flow and is in the opposite direction to the arrow, which shows the data flow of encrypted characters.</p>
<p>The Transmitter component interfaces to PicoServer via three connections, as shown in the <code>picoserver_uboot</code> <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot">test application diagram</a>: <code>send</code>, <code>receive</code>, and <code>control</code>. The <code>send</code> and <code>receive</code> connections are defined as global connector type <code>seL4PicoServer</code>, which is fundamentally <code>seL4RPCDataport</code> (<em>SharedData</em> combined with <em>RPC</em>). The <code>control</code> connection has a global connector type of <code>seL4PicoServerSignal</code>, which is fundamentally <code>seL4RPCCallSignal</code> (<em>RPC</em> combined with <em>Notification</em>). Note that although the interface between Transmitter and PicoServer configures <code>receive</code> in order to satisfy the CAmkES connections, the application does not process any Ethernet traffic in this direction, and only <code>send</code> is used.</p>
<p>The interface between PicoServer and EthDriverUboot uses the <code>seL4Ethdriver</code> global connector type, which is fundamentally another instance of <code>seL4RPCDataport</code> (<em>SharedData</em> combined with <em>RPC</em>).</p>
<p>TimeServer, which supports timing functionality for PicoServer, uses the <code>seL4TimeServer</code> global connector type, which is fundamentally another instance of <code>seL4RPCCallSignal</code> (<em>RPC</em> combined with <em>Notification</em>).</p>
<h3 id="device-drivers-1"><a class="header" href="#device-drivers-1">Device Drivers</a></h3>
<p>As can be seen from the architecture diagram, three hardware devices are involved in the operation of the application.</p>
<ol>
<li>
<p>The KeyReader component requires access to the USB device to allow for plaintext characters to be input from a USB keyboard.</p>
</li>
<li>
<p>The Transmitter component requires access to the SD/MMC device to allow for the ciphertext message to be output to a log file.</p>
</li>
<li>
<p>The EthDriverUboot component requires access to the Ethernet device to allow for ciphertext message to be output to the network.</p>
</li>
</ol>
<p>Device drivers for the required hardware access are supplied by the <a href="activity/camkes_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a> previously introduced by this development kit.</p>
<p>Three separate instances of the library are used by the application, one per component with a need for hardware device access. The capabilities of each component, and their associated library instances, are configured such that each component is only capable of accessing the minimum set of hardware devices required to perform the desired function.</p>
<p>For example, the Transmitter component only has a need to access the SD/MMC device to write the ciphertext log file. As such, the capabilities of the Transmitter component permit it to access the memory-mapped interface of the SD/MMC device; however no such capabilities are provided for the USB or Ethernet devices. Any attempt by the Transmitter component to access the memory-mapped interface of the USB device (e.g. in an attempt to read the plaintext keypresses) would therefore be prevented by seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-detail"><a class="header" href="#design-detail">Design Detail</a></h1>
<p>Following on from the <a href="activity/camkes_case_study_application/architecture.html">Architecture document</a>, this section provides further details on the design and functionality of the 'security domain' demonstrator application.</p>
<p>It is expected that the reader is familiar with the <a href="https://docs.sel4.systems/projects/camkes/manual.html">seL4 CAmkES manual</a>.</p>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>The application is held within the following structure (all within the <code>camkes/apps</code> folder), with key folders and files shown:</p>
<pre><code class="language-text">security_demo
│
├───components
│   ├───&lt;component_1&gt;
│   │   ├───src
│   │   │   └───&lt;component_source_file&gt;.c
│   │   └───&lt;component_camkes_file&gt;.camkes
│   ...
│   └───&lt;component_n&gt;
│       ├───src
│       │   └───&lt;component_source_file&gt;.c
│       └───&lt;component_camkes_file&gt;.camkes
│
├───include
│   └───plat
│       ├───&lt;platform&gt;
│       │   ├───eth_platform_devices.h
│       │   ├───mmc_platform_devices.h
│       │   └───usb_platform_devices.h
│       └───dataport_buffer.h
│
├───interfaces
│   ├───Character_RPC.idl4
│   └───Lock_RPC.idl4
│
├───CMakeLists.txt
└───security_demo.camkes
</code></pre>
<ul>
<li><code>CMakeLists.txt</code>: Application build file.</li>
<li><code>security_demo.camkes</code>: Top-level CAmkES file for the project, declaring the application's CAmkES 'assembly' including declaration of all inter-component connections.</li>
<li><code>components/&lt;component&gt;/&lt;component_camkes_file&gt;.camkes</code>: A component's CAmkES file, declaring the component's attributes including declaration of all interfaces (i.e. exposed inter-component interaction points).</li>
<li><code>interfaces/Character_RPC.idl4</code>: Declaration of a remote procedure call method used to communicate a character between components.</li>
<li><code>interfaces/Lock_RPC.idl4</code>: Declaration of remote procedure call methods used to access a mutex held by another component.</li>
<li><code>include/dataport_buffer.h</code>: Declaration of a C data type for a circular buffer to be stored in a dataport.</li>
<li><code>include/&lt;platform&gt;/&lt;eth|mmc|usb&gt;_platform_devices.h</code>: Declaration of (platform specific) CAmkES attributes to grant a component with capabilities access to a hardware device.</li>
</ul>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<p>From a concurrency perspective, the security demonstrator can be summarised as threads of execution on the 'high-side' managing plaintext data running asynchronously to threads of execution on the 'low-side' managing ciphertext data.</p>
<p>Threads of execution on the high-side perform the following functions:</p>
<ol>
<li>Reading plaintext keypresses from the USB keyboard;</li>
<li>Encrypting those keypresses from plaintext to ciphertext; and</li>
<li>Placing ciphertext keypresses into a shared circular buffer between the high-side and low-side.</li>
</ol>
<p>Asynchronously, threads of execution on the low-side perform the following functions:</p>
<ol>
<li>Reading ciphertext keypresses from a shared circular buffer between the high-side and low-side;</li>
<li>Periodically writing received ciphertext to a log file; and</li>
<li>Outputting ciphertext to a network socket (if connected).</li>
</ol>
<p>All data is passed from the high-side to the low-side through a shared circular buffer stored within a dataport. It is this circular buffer between the high-side and low-side that permits:</p>
<ol>
<li>Data transfer from the high-side to the low-side; and</li>
<li>Threads of execution on the high-side and threads of execution on the low-side to run asynchronously.</li>
</ol>
<h2 id="example-of-inter-component-communication"><a class="header" href="#example-of-inter-component-communication">Example of Inter-Component Communication</a></h2>
<p>The circular buffer shared between the Crypto component (high-side) and the Transmitter component (low-side) is used in this section as a detailed worked example of CAmkES inter-component data flow and control flow.</p>
<p>The buffer has been deliberately designed for the purpose of this worked example to use of all three types of component interface listed in the <a href="https://docs.sel4.systems/projects/camkes/manual.html">seL4 CAmkES manual</a>, i.e. <em>procedure</em>, <em>event</em> and <em>port</em>.</p>
<h3 id="port"><a class="header" href="#port">Port</a></h3>
<p>At its core the circular buffer is a simple character array with <em>head</em> and <em>tail</em> holding indexes associated with the start and end of the used portion of the array.</p>
<ul>
<li>Further details are documented alongside the definition of the <code>dataport_buffer_t</code> type definition in <code>include/dataport_buffer.h</code>.</li>
<li><em>Port</em> interfaces of data type <code>dataport_buffer_t</code> are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4SharedData</code> connection between the two <em>port</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in an instance of the circular buffer type being made available in an area of memory shared by both the Crypto and Transmitter components.</p>
<h3 id="procedure"><a class="header" href="#procedure">Procedure</a></h3>
<p>Reading data from, or writing data to, the circular buffer requires the data array, <em>head</em> index, and <em>tail</em> index to be modified. Such modification of the buffer cannot be allowed to occur concurrently by both the Crypto and Transmitter components, otherwise corruption of the buffer may occur. Access to the buffer by the two components must therefore be protected to avoid concurrent access.</p>
<p>Within the security demonstrator, a mutex is used to enforce this critical section; each component must hold the lock on the mutex prior to accessing the circular buffer, and must release the lock when access to the circular buffer has been completed.</p>
<p>The mutex is owned by the Crypto component; see definition of <code>circular_buffer_mutex</code> in the Crypto component's CAmkES file. To allow the Transmitter component to access the mutex, a <em>procedure</em> interface is used providing <code>lock</code> and <code>unlock</code> routines.</p>
<ul>
<li>Declaration of the <code>lock</code> and <code>unlock</code> <em>procedure</em> templates are provided by <code>interfaces/Lock_RPC.idl4</code>.</li>
<li><em>Procedure</em> interfaces using the <code>lock</code> and <code>unlock</code> templates are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4RPCCall</code> connection between the two <em>procedure</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in the Crypto component being supplied with a mutex and remote procedure call interfaces being supplied to the Transmitter component to allow it to access the mutex.</p>
<h3 id="event"><a class="header" href="#event">Event</a></h3>
<p>Whilst a functional system could be produced with just the <em>port</em> and <em>procedure</em> interfaces described above, there would be no mechanism for the Transmitter component to determine whether the circular buffer contains any data other than to periodically poll the contents of the circular buffer; this would be needlessly inefficient.</p>
<p>Instead, an <em>event</em> interface is used to allow the Crypto component to notify Transmitter when a character has been written into the circular buffer. This allows the Transmitter component to wait or poll for such a notification before locking the mutex and accessing the circular buffer.</p>
<ul>
<li><em>Event</em> interfaces, with the Crypto component as the emitter and Transmitter as the consumer, are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4Notification</code> connection between the two <em>event</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in the creation of a notification that can be emitted from the Crypto component and can be either waited on, or polled, by the Transmitter component.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Putting all three interface types (<em>port</em>, <em>procedure</em>, and <em>event</em>) together results in:</p>
<ul>
<li>A shared circular buffer;</li>
<li>A mutex which can be accessed via remote procedure calls to protect the buffer against concurrent access; and</li>
<li>A notification mechanism to allow the producer to notify the consumer when new data is available.</li>
</ul>
<p>This thereby allows asynchronous data transfer and buffering between components such that the producer and consumer can work concurrently.</p>
<p>The example source code for the producer component demonstrating use of these inter-component communication mechanisms can be found in <code>components/Crypto/src/crypto.c</code>. The source code for the consumer component can be found in <code>components/Transmitter/src/transmitter.c</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-running"><a class="header" href="#building-and-running">Building and Running</a></h1>
<p>This section builds and runs the <code>security_demo</code> demonstration application described in <a href="activity/camkes_case_study_application/architecture.html">Architecture document</a>. All the host machine and target platform requirements described previously in this developer kit documentation are assumed.</p>
<h2 id="building-the-application"><a class="header" href="#building-the-application">Building the Application</a></h2>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/camkes_case_study_application/../../install_and_configure/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/security_demo
cd /host/security_demo
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The application requires an IP address to be allocated to PicoServer. This should be substituted for <code>xxx.xxx.xxx.xxx</code> below. From the <code>/host/security_demo</code> directory, we execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=security_demo -DPLATFORM=maaxboard -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
</code></pre>
<p>This command should be repeated as a workaround - see the <a href="activity/camkes_case_study_application/build.html#implementation-note">implementation note</a> below:</p>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=security_demo -DPLATFORM=maaxboard -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
</code></pre>
<p>Then run <code>ninja</code> as usual:</p>
<pre><code class="language-bash">ninja
</code></pre>
<h3 id="implementation-note"><a class="header" href="#implementation-note">Implementation note</a></h3>
<p>There is a known race condition with the CMake configuration of picoserver, which, if only run once, results in <code>fatal error: pico_device.h: No such file or directory</code>. A workaround is to run the command twice, or run CMake again, by typing <code>cmake .</code> (see <a href="https://lists.sel4.systems/hyperkitty/list/devel@sel4.systems/thread/O5B42BFF4FZ2WSCPUK6C6QUAJHD6DETN/">here</a>).</p>
<h2 id="preparing-to-run"><a class="header" href="#preparing-to-run">Preparing to Run</a></h2>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/camkes_case_study_application/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>Running the <code>security_demo</code> application requires the following:</p>
<ul>
<li>Connect a keyboard to the USB socket<sup class="footnote-reference"><a href="#1">1</a></sup> of the MaaXBoard;</li>
<li>Establish an Ethernet connection between the MaaXBoard and the host machine, which can be direct or via a network, as outlined in <a href="activity/camkes_case_study_application/bootloader.html#loading-via-tftp">an earlier section</a> (e.g. it will already be in place if TFTP is being used to transfer executables).</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<p>If the user has experience of running the <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot"><code>picoserver_uboot</code> test application</a>, then elements of the <code>security_demo</code> application will be familiar. For example, from a terminal window on the host machine, we will use the <code>netcat</code> (<code>nc</code>) command (native to Linux or macOS, or available as a <a href="https://nmap.org/ncat/">download</a> for Windows) to connect to the MaaXBoard, so this should be prepared.</p>
<h2 id="running-the-application"><a class="header" href="#running-the-application">Running the Application</a></h2>
<p>The application invokes three instances of the <a href="activity/camkes_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a>, so various sets of diagnostic messages are repeated on the CoolTerm display as the application starts. We should not be unduly concerned with some of the individual messages, such as <code>No ethernet found</code>, since in this case only one of the library instances is configured to use Ethernet (i.e. the library invoked by the EthDriverUboot component), and amongst the other messages there should be confirmation that it was successful, e.g. <code>Assigned ipv4 xxx.xxx.xxx.xxx to device eth0</code>. There are also some <code>clk_register: failed ... (parent ...)</code> messages, which are harmless (a fault in U-Boot's clock driver for the MaaXBoard).</p>
<p>When the application's initialisation has completed, we should see:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
Net:   transmitter_log.txt: doesn't exist
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 1 ---
</code></pre>
<p>Note that on subsequent runs, the log file will exist (unless the user has intentionally deleted it), and the output will instead read:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 0 ---
</code></pre>
<p>In either scenario, this is housekeeping by the application to delete any previous Transmitter logfile from the SD card, before it starts writing new log data. The logfile is named <code>transmitter_log.txt</code> and is expected on the third partition of the SD card - see the FAT partition <code>FILESYS</code> established during the <a href="activity/camkes_case_study_application/appendices/partitioning_sd_card.html">Partitioning the SD Card appendix</a>.</p>
<p>Just as with the <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot"><code>picoserver_uboot</code> test application</a>, the application may sporadically display <code>No such port ....</code> messages as it monitors traffic on the network. This is expected diagnostic behaviour that may be ignored; indeed, the lack of any such messages may indicate for example that the Ethernet driver has not initialised properly.</p>
<p>The application is now ready to perform various actions concurrently:</p>
<ol>
<li>If a key is pressed, the plaintext character will be encrypted into a ciphertext character;</li>
<li>If a client requests an Ethernet connection on port 1234, the application will establish the connection and transmit ciphertext to the client, continuing to do so until the client closes the connection;</li>
<li>Every 30 seconds, if there are any ciphertext characters that it has not yet logged to file, the application will append them to the logfile on the SD card.</li>
</ol>
<p>For item (2), from a terminal window on the host machine, start <code>netcat</code> with the command:</p>
<pre><code class="language-bash">nc xxx.xxx.xxx.xxx 1234
</code></pre>
<p>where <code>xxx.xxx.xxx.xxx</code> is the IP address of the MaaXBoard, as previously specified in the <code>init_build</code> call, and 1234 is the port number that has been programmed into the application.</p>
<p>In the CoolTerm window, a message such as the following will signify a successful connection:</p>
<pre><code class="language-text">transmitter: Connection established with yyy.yyy.yyy.yyy on socket 1
</code></pre>
<p>where <code>yyy.yyy.yyy.yyy</code> is the IP address of the host machine.</p>
<p>If this connection is not established promptly, please refer to the previous <a href="activity/camkes_case_study_application/uboot_driver_usage.html#implementation-note">implementation note</a> relating to network connection delays.</p>
<p>If characters have been typed at the USB keyboard before making the <code>netcat</code> connection, then (ciphertext) characters will appear straightaway on the host machine, since the application stores characters in a buffer while they cannot be sent.</p>
<p>Plaintext messages may be typed on the keyboard (note that these are not displayed anywhere), for example:</p>
<pre><code class="language-text">Hello world, testing 123. We love seL4!
</code></pre>
<p>Within the host machine's <code>netcat</code> session, the corresponding ciphertext message should appear:</p>
<pre><code class="language-text">Uryyb jbeyq, grfgvat 123. Jr ybir frY4!
</code></pre>
<p>Periodically, the CoolTerm window will show diagnostic messages concerning the logfile, such as:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' ---
38 bytes written in 5 ms (6.8 KiB/s)
run_uboot_command@uboot_wrapper.c:181 --- command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' completed with return code 0 ---
</code></pre>
<p>The application will continue indefinitely. <code>netcat</code> sessions on the host machine may be terminated (Ctrl-C) and restarted, whereupon the application will establish a new connection (buffering output in the meantime).</p>
<p>If the MaaXBoard is powered off and its SD card removed and transferred to the host machine, the <code>transmitter_log.txt</code> can be accessed from the <code>FILESYS</code> partition as one would expect.</p>
<p>To reduce the risk of corrupting the SD card, it is advisable to avoid powering off the MaaXBoard during a write operation of the logfile. As this operation lasts in the order of 10 ms and only occurs every 30 seconds (and only then if there are any ciphertext characters that have not yet been logged to file), the risk is both remote and avoidable (e.g. power off soon after a <code>fatwrite</code> command message, or wait for &gt;30 seconds after the last <code>fatwrite</code> command message).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-6"><a class="header" href="#todo-6">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<p>It is assumed the CAmkES case study <a href="activity/microkit_case_study_application/../camkes_case_study_application/architecture.html">architecture document</a> had been read previous to reading this document.</p>
<p>The architecture of the Microkit demonstrator is shown below.</p>
<p><img src="activity/microkit_case_study_application/encrypter_arch.png" alt="Demonstrator architecture" /></p>
<p>The CAmkES and Microkit architectures are the same up to the Picoserver module, the Microkit connector types are Protected Procedure and Notification.</p>
<h3 id="protection-domains-and-connector-types"><a class="header" href="#protection-domains-and-connector-types">Protection domains and Connector Types</a></h3>
<p>Protected procedure is an appropriate connector type for the character-by-character data flow between KeyReader and Crypto. The encrypted characters are transferred to the Transmitter PD via a shared circular buffer, where Crypto writes to the head of the buffer and Transmitter reads from its tail. The buffer is implemented as a shared memory region. When the buffer is full Crypto notifies Transmitter that the buffer is full and the data needs to be read via the notification mechanism. Transmitter acts upon notifications by reading all available characters until the buffer is empty.</p>
<h3 id="device-drivers-2"><a class="header" href="#device-drivers-2">Device Drivers</a></h3>
<p>As can be seen from the architecture diagram, three hardware devices are involved in the operation of the application.</p>
<ol>
<li>
<p>The KeyReader protection domain requires access to the USB device to allow for plaintext characters to be input from a USB keyboard.</p>
</li>
<li>
<p>The Transmitter protection domain requires access to the SD/MMC device to allow for the ciphertext message to be output to a log file.</p>
</li>
</ol>
<p>Device drivers for the required hardware access are supplied by the <a href="activity/microkit_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a> previously introduced by this development kit.</p>
<p>Two separate instances of the library are used by the application, one per protection domain with a need for hardware device access. The capabilities of each protection domain, and their associated library instances, are configured such that each protection domain is only capable of accessing the minimum set of hardware devices required to perform the desired function.</p>
<p>For example, the Transmitter protection domain only has a need to access the SD/MMC device to write the ciphertext log file. As such, the capabilities of the Transmitter protection domain permit it to access the memory-mapped interface of the SD/MMC device; however no such capabilities are provided for the USB device. Any attempt by the Transmitter protection domain to access the memory-mapped interface of the USB device (e.g. in an attempt to read the plaintext keypresses) would therefore be prevented by seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study-design-detail"><a class="header" href="#case-study-design-detail">Case Study Design Detail</a></h1>
<p>Following on from the <a href="activity/microkit_case_study_application/architecture.html">architecture document</a>, this section provides further details on the design and functionality of the 'security domain' demonstrator application.</p>
<p>It is expected that the reader is familiar with the <a href="https://github.com/seL4/microkit/blob/main/docs/manual.md">seL4 Microkit manual</a>.</p>
<h2 id="code-structure-1"><a class="header" href="#code-structure-1">Code Structure</a></h2>
<p>The application is held within the following structure (all within the <code>microkit</code> folder), with key folders and files shown:</p>
<pre><code class="language-text">microkit
│
├───crypto
|   └───crytpo.c
├───keyreader
│   └───keyreader.c
├───transmitter
│   └───transmitter.c
│      
├───include
│   └───plat
│       └───&lt;platform&gt;
│            ├───mmc_platform_devices.h
│            └───usb_platform_devices.h
│
│
├───CMakeLists.txt
│
├───example
│   └───&lt;platform&gt;
│       └───security_demo
│           └───security_demo.system
</code></pre>
<ul>
<li><code>CMakeLists.txt</code>: Application build file.</li>
<li><code>security_demo.system</code>: Microkit file for the project, declaring the application's protection domains including declaration of all protection domain channels.</li>
<li><code>include/plat/&lt;mmc|usb&gt;_platform_devices.h</code>: Declaration of (platform specific) Microkit attributes to grant a protection domain with capabilities access to a hardware device.</li>
</ul>
<h2 id="concurrency-model-1"><a class="header" href="#concurrency-model-1">Concurrency Model</a></h2>
<p>From a concurrency perspective, the security demonstrator can be summarised as threads of execution on the 'high-side' managing plaintext data running asynchronously to threads of execution on the 'low-side' managing ciphertext data.</p>
<p>Threads of execution on the high-side perform the following functions:</p>
<ol>
<li>Reading plaintext keypresses from the USB keyboard;</li>
<li>Encrypting those keypresses from plaintext to ciphertext; and</li>
<li>Placing ciphertext keypresses into a shared circular buffer between the high-side and low-side.</li>
</ol>
<p>Asynchronously, threads of execution on the low-side perform the following functions:</p>
<ol>
<li>Reading ciphertext keypresses from a shared circular buffer between the high-side and low-side;</li>
<li>Periodically writing received ciphertext to a log file.</li>
</ol>
<p>All data is passed from the high-side to the low-side through a shared circular buffer stored within a dataport. It is this circular buffer between the high-side and low-side that permits:</p>
<ol>
<li>Data transfer from the high-side to the low-side; and</li>
<li>Threads of execution on the high-side and threads of execution on the low-side to run asynchronously.</li>
</ol>
<h2 id="example-of-protection-domain-communication"><a class="header" href="#example-of-protection-domain-communication">Example of Protection Domain Communication</a></h2>
<p>The circular buffer shared between the Crypto protection domain (high-side) and the Transmitter protection domain (low-side) is used in this section as a detailed worked example of Microkit data flow and control flow.</p>
<p>The buffer has been deliberately designed for the purpose of this worked example to use two types of protection domain interface listed in the <a href="https://github.com/sel4-cap/microkit-old/blob/main/docs/manual.md">seL4 Microkit manual</a>, i.e. Memory region and Notification.</p>
<h3 id="memory-region"><a class="header" href="#memory-region">Memory Region</a></h3>
<p>At its core the circular buffer is a simple character array with <em>head</em> and <em>tail</em> holding indexes associated with the start and end of the used portion of the array.</p>
<h3 id="procedure-1"><a class="header" href="#procedure-1">Procedure</a></h3>
<p>Reading data from, or writing data to, the circular buffer requires the data array, <em>head</em> index, and <em>tail</em> index to be modified. Such modification of the buffer cannot be allowed to occur concurrently by both the Crypto and Transmitter protection domains, otherwise corruption of the buffer may occur. Access to the buffer by the two protection domains must therefore be protected to avoid concurrent access.</p>
<p>Within the security demonstrator, a lock is used to enforce this critical section which takes the form of a boolean on the circular buffer data structure; each protection domain must lock the circular buffer prior to accessing the circular buffer, and must release the lock when access to the circular buffer has been completed.</p>
<ul>
<li>Function implementations for the circular buffer are included in <code>src/circular_buffer.c</code>.</li>
<li>A memory region is a contiguous range of physical memory and the memory region for the circular buffer is mapped onto both the Crypto and Transmitter protection domains. A virtual address, caching attributes and permissions (read, write and execute) are given to each protection domain.</li>
</ul>
<p>This results in an instance of the circular buffer type being made available in an area of memory shared by both the Crypto and Transmitter protection domains.</p>
<h3 id="notification"><a class="header" href="#notification">Notification</a></h3>
<p>A mechanism for the Transmitter protection domain to determine whether the circular buffer contains any data.</p>
<p>A Notification interface is used to allow the Crypto protection domain to notify Transmitter when the circular buffer is full. This allows the Transmitter protection domain to wait or poll for such a notification before accessing the circular buffer.</p>
<ul>
<li>Channels are set up between the Crypto and Transmitter protection domains in the applications system file which allow the protection domains to notify each other when there is data to read in a shared buffer.</li>
</ul>
<p>This results in the creation of a notification that can be emitted from the Crypto protection domain and can be either waited on, or polled, by the Transmitter protection domain.</p>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>Putting the two interface types (Memory region and Notification) together results in:</p>
<ul>
<li>A shared circular buffer;</li>
<li>A notification mechanism to allow the producer to notify the consumer when new data is available.</li>
</ul>
<p>This thereby allows asynchronous data transfer and buffering between protection domains such that the producer and consumer can work concurrently.</p>
<p>The example source code for the producer protection domain demonstrating use of these communication mechanisms can be found in <code>crypto/crypto.c</code>. The source code for the consumer protection domain can be found in <code>transmitter/transmitter.c</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study-building-and-running"><a class="header" href="#case-study-building-and-running">Case Study Building and Running</a></h1>
<p>This section builds and runs the <code>security_demo</code> demonstration application described in <a href="activity/microkit_case_study_application/intro.html">Case Study Introduction</a>. All the host machine and target platform requirements described previously in this developer kit documentation are assumed.</p>
<h2 id="building-the-application-1"><a class="header" href="#building-the-application-1">Building the Application</a></h2>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/microkit_case_study_application/../../install_and_configure/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/security_demo
cd /host/security_demo
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4-cap/dev-kit-microkit-manifest
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>From the <code>/host/security_demo</code> directory, we execute the following commands:</p>
<pre><code class="language-text">cd microkit
</code></pre>
<pre><code class="language-bash">./init-build.sh -DMICROKIT_APP=security_demo -DPLATFORM=maaxboard
</code></pre>
<h2 id="preparing-to-run-1"><a class="header" href="#preparing-to-run-1">Preparing to Run</a></h2>
<p>A successful build will result in an executable file called <code>sel4_image</code> in the <code>example/&lt;platform&gt;/security_demo/example-build</code> subdirectory. This file should be made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/microkit_case_study_application/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>Running the <code>security_demo</code> application requires the following:</p>
<ul>
<li>Connect a keyboard to the USB socket<sup class="footnote-reference"><a href="#1">1</a></sup> of the MaaXBoard;</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<h2 id="running-the-application-1"><a class="header" href="#running-the-application-1">Running the Application</a></h2>
<p>The application invokes two instances of the <a href="activity/microkit_case_study_application/../device_drivers/uboot_driver_library.html">U-Boot Driver Library</a>, so various sets of diagnostic messages are repeated on the CoolTerm display as the application starts. We should not be unduly concerned with some of the individual messages, such as <code>No ethernet found</code>, since in this case none of the library instances are configured to use ethernet. There are also some <code>clk_register: failed ... (parent ...)</code> messages, which are harmless (a fault in U-Boot's clock driver for the MaaXBoard).</p>
<p>When the application's initialisation has completed, we should see:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
Net:   transmitter_log.txt: doesn't exist
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 1 ---
</code></pre>
<p>Note that on subsequent runs, the log file will exist (unless the user has intentionally deleted it), and the output will instead read:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 0 ---
</code></pre>
<p>In either scenario, this is housekeeping by the application to delete any previous Transmitter logfile from the SD card, before it starts writing new log data. The logfile is named <code>transmitter_log.txt</code> and is expected on the third partition of the SD card - see the FAT partition <code>FILESYS</code> established during the <a href="activity/microkit_case_study_application/partitioning_sd_card.html">Partitioning the SD Card appendix</a>.</p>
<p>The application is now ready to perform various actions concurrently:</p>
<ol>
<li>If a key is pressed, the plaintext character will be encrypted into a ciphertext character;</li>
<li>When the circular buffer is full, the application will append them to the logfile on the SD card.</li>
</ol>
<p>Periodically, the CoolTerm window will show diagnostic messages concerning the logfile, such as:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' ---
38 bytes written in 5 ms (6.8 KiB/s)
run_uboot_command@uboot_wrapper.c:181 --- command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' completed with return code 0 ---
</code></pre>
<p>The application will continue indefinitely.</p>
<p>If the MaaXBoard is powered off and its SD card removed and transferred to the host machine, the <code>transmitter_log.txt</code> can be accessed from the <code>FILESYS</code> partition as one would expect.</p>
<p>To reduce the risk of corrupting the SD card, it is advisable to avoid powering off the MaaXBoard during a write operation of the logfile. As this operation lasts in the order of 10 ms, the risk is both remote and avoidable (e.g. power off soon after a <code>fatwrite</code> command message).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-7"><a class="header" href="#todo-7">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hdmi-driver"><a class="header" href="#hdmi-driver">HDMI Driver</a></h1>
<p>For this task the aim was to create an hdmi display driver using our current devkit setup. For inspiration looked at U-Boot’s implementation of an imx8m display driver. We chose to look at U-Boot’s solution as is BSD licensed and has minimal features making it simpler to understand.</p>
<p>The repository for this project is located at: https://github.com/sel4-cap/sel4-hdmi</p>
<h2 id="displaying-a-static-image"><a class="header" href="#displaying-a-static-image">Displaying a static image</a></h2>
<p>The first goal was to understand U-Boot’s display driver and to set up our memory regions for the frame buffer and the physical devices required by the driver. After building and running the U-Boot example, we looked through the source code and found relevant sections in IMX8M technical specification to get a better understanding of how to write the display driver. We currently rely on the firmware provided by U-Boot which needs to be configured when setting up the development environment.</p>
<p>Through reading the technical specification we learnt that the two main components of the Maaxboard needed for the driver are the DCSS (Display Controller Subsystem) and the HDMI TX Controller. With this information we were able to understand the purpose of the memory register read and write operations and which register bits needed to be set for specific functionality. We decided to use one protection domain for the simplicity of having one area to handle all operations.</p>
<p>After gaining a deeper understanding of Maaxboard and U-Boots implementation, we set values for the essential memory registers including where to set the address of the frame buffer to. For the framebuffer, we defined a region of memory that was large enough for our currently selected screen resolution and bit depth.</p>
<p>In order to read and write from specific memory registers, they must be explicitly defined in the system file for the PD that they are being accessed from. This is an essential concept to grasp when working with microkit. The majority of the code was taken from U-Boot, so the main focus of this part of the task was to set up the parts of the code that directly interfaced with the hardware. For other projects this could include registering and handling interrupts.</p>
<p>Our initial display configuration had a screen resolution of 1280x720 and a colour depth of 32 bit RGB. This meant that each pixel was composed of 32 bits with 8 bits reserved for each colour and an additional alpha channel for colour transparency. With this information, we were able to create a simple image displaying 4 colours red, green, blue and white as 4 equally spaced bars across the screen. We then experimented with different screen resolutions which involved re-defining the size of the framebuffer so that it could accommodate larger screen resolutions.</p>
<h2 id="displaying-a-moving-image"><a class="header" href="#displaying-a-moving-image">Displaying a moving image</a></h2>
<p>The next goal was to display a moving image, which first involved learning about the theory of double buffering and understanding the capabilities of the Maaxboard’s DCSS. Double buffering makes use of two buffers. The first stores the current frame, whilst the second buffer is used to store the next frame. Whilst the current frame is being displayed the second buffer is being written to. During the window of time where the image on screen is not actively being redrawn, the pointers to each buffer are swapped.</p>
<p>U-Boot’s implementation did not provide any capability to drive video, so we needed to investigate and understand the technical specification in greater detail. We found a component of the DCSS called the Context Loader which can be configured to change various parts of the display state at specific timing intervals. This would act as the trigger to switch the pointers to each frame buffer.</p>
<p>For our implementation we decided to use two PD’s. One PD contains the display driver, consisting of the DCSS and the HDMI TX Controller. The other PD contains the api and examples which demonstrate different use cases of the driver. The system is designed such that the two PD’s communicate with each other through notifications and make use of a single shared DMA memory region. This memory region is split into different parts which are accessed by a pointer with a specific offset for different parts of the memory e.g frame buffer 1, frame buffer 2. This approach was implemented for simplicity so that the memory is easily accessible, however it would be better to define individual DMA regions for specific tasks, so that certain parts of the memory are only exposed to the PD that should have access to it.</p>
<p>The initial time to redraw the buffer was slow because we were writing 8 bits of the 32 bit pixel at a time. To combat this we optimised the code logic reducing loops and where possible, we wrote 16, 32 or 64 bits at a time to minimise the amount of separate cpu instructions. This example is limited by the technology that we have available to us. For fully fledged display drivers, there will be extra bits of hardware that will be able to handle the different stages of processing video, drastically increasing performance.</p>
<p>For moving images a visible redraw is seen when switching between frames which is most noticeable when the entire screen has changed. Multiple attempts have been made to combat this issue, which have been listed in the repo for this activity.</p>
<p>The API contains the following examples:</p>
<ul>
<li>static_image - Displays 4 colour bars on the screen.</li>
<li>resolution_change - Displays a square of the same size in pixels one after another at three different resolutions.</li>
<li>rotating_bars - Displays 4 colour bars rotating across the screen.</li>
<li>moving_square - A small square that moves around the screen, changing direction each time it hits the side of the screen.</li>
</ul>
<p>TO DO:</p>
<ul>
<li>Talk about the firmware being used and the config options that need to be disabled (could be more specific and show an example... It is in the repo so not really needed)</li>
<li>Add some more specific code examples (What other things in this process could help someone to do something similar)</li>
<li>Information on how to read the specification to find the memory register and how each memory register is set up, how to toggle bits, read and write to memory etc</li>
<li>Split into different sections</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-linux-guest"><a class="header" href="#single-linux-guest">Single Linux guest</a></h1>
<p>For this task, the goal was to load up a virtual machine (VM) on a host with serial TTY passthrough. Our starting point for this activity was to rework an example from the Trustworthy Systems libvmm repository so that it runs on the Maaxboard. This repo contains a virtual machine monitor for the seL4 microkernel with various examples built for the Odroid board and the open source emulator Qemu. Libvmm provides a virtual machine monitor (VMM) which is used to start and manage the guest VM.</p>
<p>The repository for this project is located at: TBD</p>
<p>To create the linux kernel image we used buildroot. Buildroot is an open source project that automates the process of building a complete and bootable Linux environment for an embedded system. We chose buildroot because the process to create a basic linux kernel image is straightforward. <strong>(More on build root)</strong></p>
<p>The VM doesn’t necessarily know it's being virtualised, so it may try to perform read and write operations on certain devices and memory regions that it doesn’t have access to. When setting up the project there were a number of virtual memory faults, which were caused by the guest VM trying to access devices that it was not exposed to in the system file. Generally, there are three approaches to fix this.</p>
<p>One approach is to disable the device node in the device tree so that it does not try to access the device. This approach may not be feasible because the memory region may be required by a specific process in your system or dependent on another device in order to function. Another approach is to disable the device driver in the guest configuration (This can be configured with buildroot). The last approach is to utilise device “pass-through” which is where the address of the device is mapped into the guest VM allowing access directly to the device. Ideally, in a virtualised environment the guest VM shouldn’t have access to physical devices. However, for simplicity and with the absence of a serial driver it was necessary to pass through the serial device and the devices that depend on it.</p>
<p>Two memory regions that are required to be passed through for the use of libvmm and our example are the RAM and the Generic Interrupt Controller Virtual CPU (GIC-VCPU). In order for the linux guest to be able to run, it needs to have an area of contiguous space directly allocated for its own RAM. In its current implementation libvmm expects the physical memory address and the virtual memory area for the RAM to be at the same address. At a minimum there needed to be enough memory to load the kernel image and other associated binaries. The size and position of this memory need to reflect the memory node in the device tree. The GIC-VCPU is used to signal virtual interrupts. Libvmm provides a driver to handle this device which is necessary for running any guest operating system with libvmm.</p>
<p>Another issue we faced was</p>
<ul>
<li>Link to build root</li>
<li>Link to bills repository</li>
<li>Write a short bit about the SMC issue</li>
<li>Talk about the RAM issue (only allocated 2gb for example - double check what we are using in the the actual example, look at hex amount and see if it is less - does this match up?)</li>
<li>Split into headings</li>
<li>Did anything else trip us up on the way? Is more detail needed?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vmm-with-dual-linux-guests-and-tty-multiplex"><a class="header" href="#vmm-with-dual-linux-guests-and-tty-multiplex">VMM with dual linux guests and TTY Multiplex</a></h1>
<p>For this activity the goal was to load two linux Virtual Machines (VM) on one host. This was achieved by building upon our previous single guest example and taking inspiration from an existing libvmm contribution that makes use of VirtIO console. For this example five Protection Domains (PD) are used. Two PD’s are used for each virtual machine, one for the UART serial driver and the remaining two for the transmit (TX) and recieve (RX) communication channels to handle the serial data.</p>
<p>In this example, an interrupt is generated by a key press that is processed by the driver. It then adds data to a shared queue and notifies the RX PD to read from the queue and place into a new shared queue with the client. This will then notify the client that there is data in the queue. In the client vmm code this then tells the VirtIO console to handle the RX data ready to be processed in the guest VM. For TX communication, linux guest puts data in a shared queue through VirtIO. In the client PD, the data is read fro the queue and placed in a shared queue with TX PD. A notification is then sent to the TX PD so that it can read this data and place it in a shared queue with the driver. The driver then reads the data from the queue and outputs it to the hosts serial port.</p>
<p>VirtIO is an interface used by virtual machines to use its hosts’ devices through the means of virtual devices. The main role of these devices is to get data to and from the hosts physical hardware. VirtIO consists of three main parts: front-end drivers, back-end devices, and VirtQueues.</p>
<p>Typically, the front end drivers exist in the hosts kernel. These can be turned on in the config file when creating a linux kernel with buildroot. They are responsible for accepting I/O requests from user processes, transfering I/O requests to its corresponding back-end VirtIO device and retrieving completed requests from the back-end device. The back-end devices typically exist in the VMM. Libvmm provides implementations for console, network, block and sound devices. They are responsible for accepting I/O requests from the corresponding front-end driver,
handling the requests by offloading the I/O operations to the host’s physical hardware,
and making the processed and requested data available to the VirtIO driver.</p>
<p>VirtQueues are shared memory regions that are used by a VirtIO front-end driver and back-end device pair. A VRing is a data structure contained within the VirtQueue that facilitates data transfer between the VirtIO device and driver. Libvmm follows version 1.2 of the VirtIO specification and uses the seL4 Device Driver Framework (SDDF) to implement the VirtQueues for specific devices.</p>
<p>In our example, we make use of the VirtIO Console device to handle serial I/O data. To use VirtIO Console a node was created in the device tree and a multiple settings turned on in the linux kernel config file. In the “chosen” node of the device tree, the stdout path and the boot args also needed to be set up specifically for the console device. In our initial implementation we passed through 8 additional devices. We then managed to remove the need for 7 of them by disabling them in the device tree. The remaining “gpc” device was needed by virtio-console, but at this stage it is unknown why.</p>
<p>When loading up TWO VM's</p>
<ul>
<li>Memory considerations for two linuxes. (reference single tty)</li>
<li>Talk about the timer, priorities of the two VM’s.</li>
<li>Do we need to include more failures and attempts at things?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-8"><a class="header" href="#todo-8">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="licensing"><a class="header" href="#licensing">Licensing</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
