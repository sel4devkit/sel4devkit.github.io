<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>seL4 Developer Kit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A developer kit for the seL4 microkernel on the Avnet MaaXBoard SBC (Single Board Computer).">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/audience.html"><strong aria-hidden="true">1.1.</strong> Audience</a></li><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="introduction/structure.html"><strong aria-hidden="true">1.3.</strong> Structure</a></li></ol></li><li class="chapter-item expanded "><a href="resources/main.html"><strong aria-hidden="true">2.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/sel4_microkernel.html"><strong aria-hidden="true">2.1.</strong> seL4 Microkernel</a></li><li class="chapter-item expanded "><a href="resources/avent_maaxboard.html"><strong aria-hidden="true">2.2.</strong> Avent MaaXBoard</a></li><li class="chapter-item expanded "><a href="resources/repositories.html"><strong aria-hidden="true">2.3.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="resources/glossary.html"><strong aria-hidden="true">2.4.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="development_platform/main.html"><strong aria-hidden="true">3.</strong> Development Platform</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development_platform/hardware_requirements.html"><strong aria-hidden="true">3.1.</strong> Hardware Requirements</a></li><li class="chapter-item expanded "><a href="development_platform/software_requirements.html"><strong aria-hidden="true">3.2.</strong> Software Requirements</a></li></ol></li><li class="chapter-item expanded "><a href="install_and_configure/main.html"><strong aria-hidden="true">4.</strong> Install and Configure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install_and_configure/host_setup.html"><strong aria-hidden="true">4.1.</strong> Host Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/build_environment_setup.html"><strong aria-hidden="true">4.2.</strong> Build Environment Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/target_setup.html"><strong aria-hidden="true">4.3.</strong> Target Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/bootloader_setup.html"><strong aria-hidden="true">4.4.</strong> Bootloader Setup</a></li></ol></li><li class="chapter-item expanded "><a href="first_boot/main.html"><strong aria-hidden="true">5.</strong> First Boot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_boot/bootloader.html"><strong aria-hidden="true">5.1.</strong> Bootloader</a></li><li class="chapter-item expanded "><a href="first_boot/sel4test.html"><strong aria-hidden="true">5.2.</strong> seL4Test</a></li><li class="chapter-item expanded "><a href="first_boot/camkes_adder.html"><strong aria-hidden="true">5.3.</strong> CAmkES Adder</a></li><li class="chapter-item expanded "><a href="first_boot/microkit_hello_world.html"><strong aria-hidden="true">5.4.</strong> Microkit Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="activities/main.html"><strong aria-hidden="true">6.</strong> Activities</a></li><li class="chapter-item expanded "><a href="activity/microkit_memory_probe/main.html"><strong aria-hidden="true">7.</strong> Activity: Microkit Memory Probe</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/main.html"><strong aria-hidden="true">8.</strong> Activity: Device Drivers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_driver_library.html"><strong aria-hidden="true">8.1.</strong> U-Boot Driver Library Overview</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_driver_usage.html"><strong aria-hidden="true">8.2.</strong> Using the U-Boot Driver Library</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_library_add_platform.html"><strong aria-hidden="true">8.3.</strong> Library Extension - New Platform</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_library_add_driver.html"><strong aria-hidden="true">8.4.</strong> Library Extension - New Driver</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/add_driver_worked_example.html"><strong aria-hidden="true">8.5.</strong> Add Driver Worked Example</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/add_odroidc2.html"><strong aria-hidden="true">8.6.</strong> Add Odroid C2</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/driver_troubleshooting.html"><strong aria-hidden="true">8.7.</strong> Driver Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="activity/spi_bus_bmp280_pressure_sensor/main.html"><strong aria-hidden="true">9.</strong> Activity: SPI Bus BMP280 Pressure Sensor</a></li><li class="chapter-item expanded "><a href="activity/case_study_application/main.html"><strong aria-hidden="true">10.</strong> Activity: Case Study Applicaton</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/main.html"><strong aria-hidden="true">11.</strong> Activity: CAmkES Case Study Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/architecture.html"><strong aria-hidden="true">11.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/detail.html"><strong aria-hidden="true">11.2.</strong> Design</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/build.html"><strong aria-hidden="true">11.3.</strong> Build</a></li></ol></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/main.html"><strong aria-hidden="true">12.</strong> Activity: Microkit Case Study Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/architecture.html"><strong aria-hidden="true">12.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/detail.html"><strong aria-hidden="true">12.2.</strong> Design</a></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/build.html"><strong aria-hidden="true">12.3.</strong> Build</a></li></ol></li><li class="chapter-item expanded "><a href="activity/microkit_usb_driver/main.html"><strong aria-hidden="true">13.</strong> Activity: Microkit USB Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_hdmi_driver/main.html"><strong aria-hidden="true">14.</strong> Activity: Microkit HDMI Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_single_linux_guest/main.html"><strong aria-hidden="true">15.</strong> Activity: Microkit VMM Single Linux Guest</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_tty_multiplex/main.html"><strong aria-hidden="true">16.</strong> Activity: Microkit VMM Dual Linux Guest TTY Multiplex</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_usb_routing/main.html"><strong aria-hidden="true">17.</strong> Activity: Microkit VMM Dual Linux Guest USB Routing</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="licensing.html">Licensing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">seL4 Developer Kit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sel4devkit/sel4devkit-manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <a href="https://sel4.systems">seL4® Microkernel</a> is a technology of
increasing interest. It delivers specific capabilities and assurances, which
make it particularly suitable for applications that demand a trusted execution
environment and strong separation of concerns.</p>
<p>The seL4 Microkernel is engineered to deliver both high-assurance and
high-performance (<a href="https://sel4.systems/About/seL4-whitepaper.pdf">The seL4 Microkernel: An
Introduction</a>). High-assurance
is achieved through comprehensive formal verification. High-performance is
achieved through deliberate design and profiling, potentially accepting
greater complexity in the formal verification where this achieves higher
performance.</p>
<p>The development of the seL4 Microkernel is overseen by the <a href="https://sel4.systems/Foundation/">seL4
Foundation</a>, operating as project under The
<a href="https://www.linuxfoundation.org/">Linux Foundation</a>. The entirety of the seL4
Microkernel, and its associated components, are made available as Open Source,
on Git Hub (<a href="https://github.com/seL4">seL4 Microkernel and associated
components</a>).</p>
<p>In common with all Microkernels, the seL4 Microkernel provides a minimum set
of essential features as needed to frame a viable OS (Operating System). There
is an expectation that further components will be introduced atop this OS, in
developing useful applications (such as drivers, libraries, and services).</p>
<p>As a consequence, developing on top of the seL4 microkernel is currently
complex and time-consuming, and the expertise is limited to a small number of
individuals and organisations. Thus, this seL4 Developer Kit is created to
reduce the barrier to entry for developing on top of seL4 Microkernel. The
overall intention is to encourage and support more organisations in adopting
seL4 in their projects and products.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="audience"><a class="header" href="#audience">Audience</a></h2>
<p>The intended audience is an application developer:</p>
<ul>
<li>Experienced in programming within a Linux, macOS, or Windows environment.</li>
<li>Already familiar with seL4 concepts and benefits.</li>
<li>Looking for practical guidance in getting started with seL4.</li>
</ul>
<h3 id="complementary-approach"><a class="header" href="#complementary-approach">Complementary Approach</a></h3>
<p>This seL4 Developer Kit does not intend to cover or replace any of the
extensive material as maintained by the (<a href="https://sel4.systems">seL4
Foundation</a>) and associated organisations.</p>
<p>Instead, the purpose is to complement this existing material with practical
guidance about getting started with seL4. Throughout the seL4 Developer Kit,
reference is made to externally maintained material where appropriate.</p>
<h3 id="focus-on-sel4-details"><a class="header" href="#focus-on-sel4-details">Focus on seL4 Details</a></h3>
<p>Whilst the seL4 Developer Kit aims to cover all the important configuration
steps, it does assume a reasonable level of developer knowledge. In general,
priority and prominence is given to seL4 specific details, while more routine
aspects are explained at a higher level or through external reference (such as
installing software or interacting with configuration management).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The seL4 Developer Kit intends to support developers in gaining familiarity
with seL4 Microkernel, and ultimately to encourage more use of seL4 within
projects and products. It does this by:</p>
<ul>
<li>
<p>Selecting a readily available low-cost SBC (Single Board Computer) as the
target platform ((The <a href="introduction/%22../avent_maaxboard/main.html">Avnet MaaXBoard</a>).</p>
</li>
<li>
<p>Identifying the minimum needed to create a viable development platform, and
detailing specific hardware and software requirements to achieve this.</p>
</li>
<li>
<p>Supplying preconfigured build environments, plus associated examples, with
all the content required to generate seL4 executable programs.</p>
</li>
<li>
<p>Demonstrating how an seL4 executable program can be loaded and executed on
the chosen target platform.</p>
</li>
<li>
<p>Documenting the specific steps needed, along with more general guidance.</p>
</li>
</ul>
<p>Once the fundamentals of building and executing an seL4 program are
established, the seL4 Developer Kit seeks to explain and encourage further
development through the presentation of a diverse series of technical
(<a href="introduction/%22../activities/activities.html">Activities</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The seL4 Developer Kit is structured into the following sections to provide a
step-by-step guide:</p>
<ul>
<li>
<p><strong>Introduction</strong>: Introduce the potential benefits that the seL4 Microkernel
offers, acknowledge its steep learning curve, and position the seL4
Developer Kit as a means to help facilitate and encourage wider adoption.</p>
</li>
<li>
<p><strong>Resources</strong>: Provides an overview of the fundamental aspects of both the
seL4 Microkernel and the Avent MaaXBoard (our chosen SBC (Single Board
Computer)), highlighting relevant supporting material from other sources. The
technical scope of the seL4 Developer Kit is summerised though a list of its
associated repositories. Finally, a consolidated glossary of key terms is
presented for easy reference.</p>
</li>
<li>
<p><strong>Development Platform</strong>: Identify and explain the minimum hardware and
software requirements needed to assemble a viable development platform for
using the seL4 Developer Kit. It is expected that, to meet these requirements,
some equipment will need to be purchased (for example, an Avent MaaXBoard).</p>
</li>
<li>
<p><strong>Install and Configure</strong>: Provides guidance, and explores options, in
installing and configuring the development platform. Once complete, the
development platform will be ready for building sel4 programs, loading such
programs onto the target, and executing these programs on the target, with
terminal (text) input and output available.</p>
</li>
<li>
<p><strong>First Boot</strong>: Utilising a previously prepared development platform, walk
through the steps in powering up the target (Avnet MaaXBoard), interacting
with the bootloader, and building and executing a small number of example
programs. On completion of this step, the development platform is prepared and
proven to operate.</p>
</li>
<li>
<p><strong>Activities</strong>: With the development platform established, a series of
distinct technical activities are undertaken. Each Activity describes both
its approach, and the eventual outcome, seeking to illustrate how sel4
development may be practically progressed.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>Presents for immediate reference a summary of the various resources associated
with seL4 Developer Kit.</p>
<h2 id="supporting-material"><a class="header" href="#supporting-material">Supporting Material</a></h2>
<p>The seL4 Developer Kit makes use of a large collection of existing material.
Here, we summarise and reference this material, explaining its relevance to
the seL4 Developer Kit.</p>
<p>Distinct areas considered are listed below:</p>
<ul>
<li><a href="resources/%22../resources/sel4_microkernel.html">seL4 Microkernel</a></li>
<li><a href="resources/%22../resources/avent_maaxboard.html">Avent MaaXBoard</a></li>
</ul>
<h2 id="repositories"><a class="header" href="#repositories">Repositories</a></h2>
<p>A summarised list of all the repositories that form part of the seL4 Developer
Kit is presented to support their navigation:</p>
<ul>
<li><a href="resources/reference/repositories.html">Repositories</a></li>
</ul>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p>A consolidated glossary of key terms is presented for easy reference:</p>
<ul>
<li><a href="resources/reference/glossary.html">Glossary</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-1"><a class="header" href="#todo-1">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repositories-1"><a class="header" href="#repositories-1">Repositories</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Purpose</th></tr></thead><tbody>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-manual</a></td><td>User Manual and its hosting on GitHub Pages</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-camkes-docker-dev-env</a></td><td>MaaXBoard CAmkES Docker Development Environment</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-docker-dev-env</a></td><td>MaaXBoard Microkit Docker Development Environment</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-bootloader-u-boot</a></td><td>MaaXBoard Bootloader via Avnet fork of Das U-Boot</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-first-boot-hello-world</a></td><td>Coordinate Build of MaaXBoard Microkit Hello World</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-first-boot-sel4test</a></td><td>Coordinate Build of MaaXBoard seL4 Test</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-camkes-first-boot-adder</a></td><td>Coordinate Build of MaaXBoard CAmkES adder</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-linux-guest</a></td><td>Coordinate Build of MaaXBoard Linux Guest</td></tr>
<tr><td><a href="resources/">https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-vmm-single-linux-guest</a></td><td>Coordinate Build of MaaXBoard Microkit VMM Single Linux Guest</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/ARM_architecture_family#AArch32">AArch32</a></td><td>Execution state of <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#64/32-bit_architecture">ARMv8</a> architecture using 32-bit wide general-purpose registers.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/AArch64">AArch64</a></td><td>Execution state of <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#64/32-bit_architecture">ARMv8</a> architecture using 64-bit wide general-purpose registers.</td></tr>
<tr><td><a href="https://www.avnet.com">Avnet</a></td><td>The manufacturer of the MaaXBoard SBC.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Bootloader">Bootloader</a></td><td>The tool responsible for booting a computer. Responsible for initialisation of software following by loading and execution of software.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/camkes">CAmkES</a></td><td>Component Architecture for microkernel-based Embedded Systems. An abstraction layer on top of seL4 providing a software development and runtime framework for quickly and reliably building microkernel-based multiserver (operating) systems.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Devicetree">Device Tree</a></td><td>A <a href="https://www.devicetree.org/specifications">standardised data structure</a> with nodes that describe the hardware components of a computer system. Associated with device trees are DTS files (Device Tree Source - a textual representation of a device tree), DTB files (Device Tree Blob - a binary representation of a device tree), and DTC (Device Tree Compiler - a tool used to convert between device tree formats, e.g. DTS to DTB).</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a></td><td>Direct Memory Access. A feature that allows certain hardware subsystems to access main system memory independently of the central processing unit (CPU), typically used by devices that need to transfer bulk data (e.g. USB).</td></tr>
<tr><td><a href="https://www.docker.com">Docker</a></td><td>A tool that allows packaging of an application and its dependencies within a container, with fewer overheads than a virtual machine. It is used in this developer kit to provide a standardised build environment.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/General-purpose_input/output#Board-level_GPIOs">GPIO</a></td><td>General-Purpose Input/Output. A digital signal pin on an integrated circuit or electronic circuit board which may be used as an input or output, or both, and is controllable by software.</td></tr>
<tr><td><a href="https://www.ncsc.gov.uk/whitepaper/security-architecture-anti-patterns">High-side</a></td><td>In a security context, 'more trusted' or 'high-side' refers to a system in which there is more confidence of its integrity.</td></tr>
<tr><td><a href="https://www.ncsc.gov.uk/whitepaper/security-architecture-anti-patterns">Low-side</a></td><td>In a security context, 'less trusted' or 'low-side' refers to a system in which there is less confidence of its integrity.</td></tr>
<tr><td><a href="https://www.avnet.com/wps/portal/us/products/avnet-boards/avnet-board-families/maaxboard/maaxboard">MaaXBoard</a></td><td>An <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-8-applications-processors/i-mx-8m-family-armcortex-a53-cortex-m4-audio-voice-video:i.MX8M">NXP i.MX 8M SoC</a> based SBC. Selected as the target platform for this developer kit.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a></td><td>Single Board Computer. A complete computer on a single circuit board. The Avnet MaaXBoard is an example of a SBC.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/sel4test">seL4Test</a></td><td>Test suite for seL4 developed and maintained by the seL4 Foundation.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a></td><td>System on chip. A chip that integrates all or most components of a computer. The SoC on the MaaXBoard is the <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-8-applications-processors/i-mx-8m-family-armcortex-a53-cortex-m4-audio-voice-video:i.MX8M">NXP i.MX 8M</a>.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">TFTP</a></td><td>Trivial File Transfer Protocol. A simple file transfer protocol commonly used in the early stages of bootloading from a local area network.</td></tr>
<tr><td><a href="https://www.denx.de/wiki/U-Boot">U-Boot</a></td><td>Das U-Boot (known as "the Universal Boot Loader" and often shortened to U-Boot) is an open-source bootloader commonly used in embedded devices.</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a></td><td>Universal Asynchronous Receiver-Transmitter. A simple serial communication device commonly used by SBCs.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/microkit">Microkit</a></td><td>Operating system framework on top of seL4 that provides a small set of simple abstractions that ease the design and implementation of statically structured systems on seL4, while still leveraging the kernel’s benefits of security and performance</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a></td><td>Single Board Computer. A complete computer on a single circuit board. The Avnet MaaXBoard is an example of a SBC.</td></tr>
<tr><td><a href="https://docs.sel4.systems/projects/sel4test">seL4Test</a></td><td>Test suite for seL4 developed and maintained by the seL4 Foundation.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="development-platform"><a class="header" href="#development-platform">Development Platform</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-boot"><a class="header" href="#first-boot">First Boot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-setup"><a class="header" href="#host-setup">Host Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-environment-setup"><a class="header" href="#build-environment-setup">Build Environment Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup"><a class="header" href="#bootloader-setup">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup-1"><a class="header" href="#bootloader-setup-1">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="activities"><a class="header" href="#activities">Activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-2"><a class="header" href="#todo-2">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-driver-introduction"><a class="header" href="#device-driver-introduction">Device Driver Introduction</a></h1>
<p>This section seeks to provide guidance on adding device drivers to seL4.</p>
<p>It should be noted that seL4 runs all device drivers in user mode; device support is therefore not the kernel’s problem.</p>
<p>This guide focuses on methods, complete with an extensive worked example, for adding device support to seL4.</p>
<p>The following sections describe the creation of an extensible library for seL4 allowing U-Boot device drivers to function under seL4 with either minimal or no modifications. As an example of its usage, the library provides an extensive set of device drivers for the Avnet MaaXBoard (support for USB, Ethernet, SD/MMC, I<sup>2</sup>C, GPIO, IOMUX, Clock and SPI devices). Guidance on the extension of this library to support other platforms and devices is also provided.</p>
<p>This guide provides guidance on adding device drivers atop of both the CAmkES and Microkit frameworks.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The goal of this guide is to lower the barrier to entry for the use of seL4. One such barrier is device driver support for seL4, both the relatively limited device driver support as well as the difficulty in the creation of new device drivers.</p>
<p>To help overcome this barrier, this guide attempts to provide a route for adding device support to seL4 with minimal effort and technical challenges. This goal has resulted in the following decisions and priorities being taken:</p>
<ol>
<li>
<p>A focus on porting existing open source device drivers from other projects (e.g. Linux or U-Boot) over the writing of new device drivers; detailed guidance on the writing of new device drivers is outside the scope of this guide.</p>
</li>
<li>
<p>Methods of porting that allow devices to be supported with minimal effort, e.g. minimising changes to driver source code, have been prioritised over factors such as performance and support for all features.</p>
</li>
<li>
<p>Consideration for device driver formal verification has not been applied. No guarantee of correctness, security, or anything else is given for the drivers ported, or the method described.</p>
</li>
</ol>
<h2 id="porting-drivers"><a class="header" href="#porting-drivers">Porting Drivers</a></h2>
<p>Device drivers can be ported from any source where the device driver source code is available under a suitable license. The most obvious such sources are Linux and U-Boot, both of which contain a very large selection of open source device drivers. It is suggested that porting drivers from U-Boot is easier than porting drivers from Linux for the following reasons:</p>
<ul>
<li>
<p>Porting a device driver requires either the driver to be made to function independently from the driver framework of its source project, or for the source project's driver framework to be made to function within seL4. The U-Boot driver framework is significantly less complex and extensive than the Linux driver framework.</p>
</li>
<li>
<p>U-Boot device drivers tend to be significantly simpler than device drivers found in Linux. This is because the use cases of a bootloader such as U-Boot do not require high performance, fully-featured drivers. Indeed it can be seen that many of the U-Boot device drivers are in fact actively simplified versions of Linux drivers that have been ported to the U-Boot driver framework.</p>
</li>
</ul>
<p>In line with the goals stated above this guide therefore focuses on the porting of drivers from U-Boot to seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u-boot-driver-library-overview"><a class="header" href="#u-boot-driver-library-overview">U-Boot Driver Library Overview</a></h1>
<p>To achieve the goals specified in <a href="activity/device_drivers/main.html">device driver introduction</a> section, an extensible library of device drivers ported from U-Boot has been created. This library provides an extensive set of drivers for the Avnet MaaXBoard platform as a worked example of its usage. The library is supported by documentation in the following sections on usage, maintenance, and guidance on the extension of the library to support additional platforms and devices.</p>
<p>Information on the design and structure of the library is provided under the following sections:</p>
<ul>
<li><a href="activity/device_drivers/uboot_driver_library.html#design-summary">Design Summary</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#build-system">Build System</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#library-limitations">Library Limitations</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#code-structure">Code Structure</a></li>
</ul>
<h2 id="design-summary"><a class="header" href="#design-summary">Design Summary</a></h2>
<p>The primary goal of the library is to allow drivers from U-Boot to be used within seL4 with minimal or no code changes. To support this goal, the library comprises:</p>
<ul>
<li>
<p>A set of U-Boot drivers.</p>
</li>
<li>
<p>The U-Boot <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/index.html">Driver Model</a> driver framework and associated subsystems required to support device drivers.</p>
</li>
<li>
<p>Stubbed versions of U-Boot subsystems providing a compatibility / conversion layer between the U-Boot source code and underlying seL4 libraries.</p>
</li>
<li>
<p>A wrapper around the U-Boot code to provide an API for users of the library to interact with devices and manage library initialisation / shutdown.</p>
</li>
</ul>
<p>It should be noted that the library works with the intended security and isolation of seL4; capabilities to permit access to hardware devices and provide sufficient resources (e.g. heap and DMA memory) must be granted to components/protection domains using the library.</p>
<h2 id="detailed-design-information"><a class="header" href="#detailed-design-information">Detailed Design Information</a></h2>
<p>The following sections provide details on the design of stub or wrapper elements that are significant to support the functioning of the drivers within the Driver Model framework.</p>
<h3 id="linker-lists"><a class="header" href="#linker-lists">Linker Lists</a></h3>
<p>To allow variable levels of functionality to be built into a U-Boot executable, U-Boot utilises a concept of <a href="https://u-boot.readthedocs.io/en/latest/api/linker_lists.html">linker-generated arrays</a>. These are arrays of objects (e.g. drivers, supported commands, driver classes, etc.) which are stored by U-Boot within dedicated linker sections to be queried at runtime.</p>
<p>Access to the objects stored within these linker sections is provided by U-Boot through a set of macros defined in the <code>linker_lists.h</code> header file.</p>
<p>To mimic this functionality within the library, the following approach has been taken:</p>
<ol>
<li>
<p>Rather than storing the objects within linker sections of the executable, a global variable named <code>driver_data</code> is declared within <code>driver_data.h</code> which contains the equivalent object arrays.</p>
</li>
<li>
<p>During initialisation of the library, the platform-dependent contents of the <code>driver_data</code> global variable are set up.</p>
</li>
<li>
<p>A stubbed version of the <code>linker_lists.h</code> header file is provided. Rather than accessing data from the executable's linker sections as performed by the original version, the stubbed version accesses data from the arrays within the <code>driver_data</code> global variable.</p>
</li>
</ol>
<h3 id="global-data"><a class="header" href="#global-data">Global Data</a></h3>
<p>U-Boot maintains a <a href="https://u-boot.readthedocs.io/en/latest/develop/global_data.html">global data</a> structure for the storage of globally required fields.</p>
<p>The macro <code>DECLARE_GLOBAL_DATA_PTR</code> is used by U-Boot to provide a pointer to this data structure. On most architectures this pointer is stored in a dedicated register (e.g. register <code>x18</code> on ARM64); such a mechanism is not compatible with seL4.</p>
<p>Within the library the following approach has been taken to global data:</p>
<ol>
<li>
<p>A stub of the <code>global_data.h</code> header file has been provided to provide the macro <code>DECLARE_GLOBAL_DATA_PTR</code> as a pointer to a global variable.</p>
</li>
<li>
<p>At initialisation of the library, memory for the global data structure is allocated and initialised as follows:</p>
<ul>
<li>Most elements are unused and set to null values.</li>
<li>The global status <code>flags</code> are set up to mimic an instance of U-Boot that has been relocated to, and is executing from, RAM.</li>
<li>Pointers to the flattened device tree are setup to point to seL4's device tree.</li>
<li>A <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html">live device tree</a> is built from the flattened device tree and referenced.</li>
</ul>
</li>
</ol>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p>The U-Boot code expects to have access to a high-frequency, monotonic timer. The timer is accessed by the U-Boot source code through calls to routines <code>get_ticks</code>, <code>get_timer_*</code> and <code>timer_get_*</code>.</p>
<p>Provision of such a timer is platform dependent. For the Avnet MaaXBoard the timer has been implemented through use of the System Counter (SYS_CON) device provided by the iMX8MQ SoC; see file <code>timer_imx8mq.c</code> for details.</p>
<h3 id="memory-mapped-io"><a class="header" href="#memory-mapped-io">Memory Mapped IO</a></h3>
<p>One of the core mechanisms for providing a software interface to a hardware device is through the use of <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped IO</a>.</p>
<p>The memory addresses that a U-Boot driver uses for communication with a device can be either read from the device tree (i.e. from a device's <code>reg</code> property) or in some cases can be hard-coded into the driver.</p>
<p>At this point it should be noted that U-Boot source code is intended to be executed in an environment with direct access to the system's physical address space; however, the library is executed within a virtual address space provided by seL4. As such, the addresses used by U-Boot drivers are <em>physical</em> addresses which are not directly accessible by the library. To work around this issue:</p>
<h4 id="camkes"><a class="header" href="#camkes">CAmkES</a></h4>
<ol>
<li>
<p>During library initialisation the list of all platform-dependent devices that need to be accessed must be provided. For each device:</p>
<ul>
<li>The device's physical address range is read from the device tree.</li>
<li>The device's physical address range is mapped into the virtual address space through use of the IO mapping routines provided by seL4's platform support library.</li>
<li>The mapping between the physical address range and the mapped virtual address range is stored within the <code>sel4_io_map</code> package (part of the library's wrapper functionality).</li>
</ul>
</li>
<li>
<p>When a driver attempts to perform memory mapped IO it calls architecture-dependent routines from the <code>io.h</code> header, e.g. <code>readl</code> or <code>writel</code>. A stubbed version of the <code>io.h</code> header is provided that uses the <code>sel4_io_map</code> package to translate the physical addresses provided by the driver to the equivalent address mapped into the library's virtual address space.</p>
</li>
</ol>
<p>U-Boot drivers performing memory mapped IO should perform seamlessly without the need for any modifications to the driver.</p>
<h4 id="microkit"><a class="header" href="#microkit">Microkit</a></h4>
<p>The physical addresses of all platform-dependent devices must be provided in the system file in this format:</p>
<pre><code>&lt;system&gt;
    &lt;memory_region name="&lt;physical_device_name&gt;" size="&lt;physical_device_size&gt;" phys_addr="&lt;physical_device address&gt;"/&gt;
    ...
    &lt;protection_domain name="&lt;PD name&gt;"&gt;
      &lt;map mr="&lt;physical_device_name&gt;" vaddr="&lt;virtual_map_address&gt;" perms="rw" cached="false"/&gt;
      ...
   &lt;/protection_domain&gt;
&lt;/system&gt;
</code></pre>
<h3 id="dma"><a class="header" href="#dma">DMA</a></h3>
<p>As for <a href="activity/device_drivers/uboot_driver_library.html#memory-mapped-io">memory mapped IO</a>, it should be noted that U-Boot source code expects to be executed in an environment with direct access to the system's physical address space; however the library is executed within a virtual address space provided by seL4.</p>
<p>This can lead to U-Boot drivers that are executed within seL4 erroneously providing a <em>virtual</em> memory address to devices as the address to use for a DMA transfer; DMA transfers performed by devices can only be performed to <em>physical</em> addresses.</p>
<p>To support this issue, the library:</p>
<ol>
<li>
<p>Provides the <code>sel4_dma</code> package as part of its wrapper, which:</p>
<ul>
<li>Provides memory allocation / deallocation routines that utilise the underlying DMA functions provided by seL4's platform support library;</li>
<li>Maintains a mapping between the physical and virtual addresses, and provides routines to perform address translations;</li>
<li>Provides routines to perform flushing and invalidation of the allocated DMA regions.</li>
</ul>
</li>
<li>
<p>Provides an implementation of Linux's <code>dma_mapping.h</code> interface via the <code>sel4_dma</code> package.</p>
</li>
<li>
<p>Provides modifications to the XHCI USB stack, as used by USB 3.0 devices, intended to cover all DMA issues related to <em>users</em> of the USB stack (e.g. keyboard, mouse, or mass storage devices).</p>
</li>
</ol>
<p>It is an unfortunate fact that drivers utilising DMA may require manual modifications to function correctly:</p>
<ul>
<li>
<p>Drivers that use the DMA interface exported by <code>dma-mapping.h</code> should work without modification; drivers ported to U-Boot from Linux have been seen to use this interface. Examples of device drivers for the Avnet MaaXBoard using the <code>dma-mapping.h</code> DMA interface are the USB driver and the SD/MMC driver.</p>
</li>
<li>
<p>Drivers that do not use the DMA interface exported by <code>dma-mapping.h</code> will need to be modified to use the API exported by the <code>sel4_dma</code> wrapper package. An example of a device driver for the Avnet MaaXBoard that required manual modifications is the Ethernet driver (see <code>fec_mxc.c</code>).</p>
</li>
</ul>
<h3 id="console"><a class="header" href="#console">Console</a></h3>
<p>A minimal stub of U-Boot's console subsystem has been provided (see <code>console.c</code>). This stub provides the subset of functionality required to allow input and output devices to be registered and accessed by the driver library.</p>
<p>It should be noted that the console subsystems's <code>stdout</code> file is not used by the library; instead all output is routed directly to the C library output routines.</p>
<p>The console subsystem's <code>stdin</code> file, however, is used. For example, if a USB keyboard is registered with the console as the <code>stdin</code> device then subsequent calls to retrieve input from <code>stdin</code> will return keypresses that are input from the USB keyboard.</p>
<h3 id="standard-output-and-logging"><a class="header" href="#standard-output-and-logging">Standard Output and Logging</a></h3>
<p>The wrapper header file <code>uboot_print.h</code> provides a set of macros that map:</p>
<ul>
<li>All U-Boot standard output routines onto calls to the C library <code>printf</code> routine.</li>
<li>All U-Boot logging routines onto the seL4 platform support library <code>ZF_LOG*</code> routines at an equivalent logging level or <code>UBOOT_LOG</code> routines for Microkit.</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>As part of library initialisation, any U-Boot subsystems that require explicit initialisation are handled (see <code>uboot_wrapper.c:initialise_uboot_wrapper</code>). This mimics the initialisation that would normally be performed by <a href="https://github.com/u-boot/u-boot/blob/master/common/board_r.c">U-Boot's start-up routine</a>.</p>
<p>Initialisation of the library comprises:</p>
<h4 id="camkes-1"><a class="header" href="#camkes-1">CAmkES</a></h4>
<ul>
<li>Initialisation of the memory mapped IO and DMA wrappers;</li>
<li>Initialisation of the monotonic timer;</li>
<li>Initialisation of the Linker Lists data structure;</li>
<li>Initialisation of the Global Data data structure;</li>
<li>Initialisation of U-Boot's Environment subsystem (manages storage of environment variables);</li>
<li>Initialisation of U-Boot's Driver Model subsystem;</li>
<li>Initialisation of U-Boot's MMC subsystem (if SD/MMC drivers are used by the platform);</li>
<li>Initialisation of U-Boot's Network subsystem (if Ethernet drivers are used by the platform).</li>
</ul>
<p>When calling the <code>initialise_uboot_wrapper</code> routine the following must be provided:</p>
<ul>
<li>The I/O operations data structure from the platform support library. These routines enable the library to access the seL4 device tree and to perform memory mapping and DMA operations. The routines are provided by CAmkES on creation of a single threaded component.</li>
<li>The list of device tree paths containing physical addresses to be memory mapped (through the <code>reg</code> property).</li>
<li>The list of device tree paths for the devices to enable. Note that all sub-nodes of the device tree paths will be automatically enabled; only the root node for the required devices need to be listed. All other nodes in the device tree will be marked as disabled.</li>
</ul>
<h4 id="microkit-1"><a class="header" href="#microkit-1">Microkit</a></h4>
<ul>
<li>Initialisation of the DMA wrappers;</li>
<li>Initialisation of the monotonic timer;</li>
<li>Initialisation of the Linker Lists data structure;</li>
<li>Initialisation of the Global Data data structure;</li>
<li>Initialisation of U-Boot's Environment subsystem (manages storage of environment variables);</li>
<li>Initialisation of U-Boot's Driver Model subsystem;</li>
<li>Initialisation of U-Boot's MMC subsystem (if SD/MMC drivers are used by the platform);</li>
<li>Initialisation of U-Boot's Network subsystem (if Ethernet drivers are used by the platform).</li>
</ul>
<p>When calling the <code>initialise_uboot_wrapper</code> routine the following must be provided:</p>
<ul>
<li>A DMA manager which can be initialised with a call to the <code>microkit_dma_manager</code> routine.</li>
<li>A pointer to the device tree blob.</li>
<li>The list of device tree paths for the devices to enable. Note that all sub-nodes of the device tree paths will be automatically enabled; only the root node for the required devices need to be listed. All other nodes in the device tree will be marked as disabled.</li>
</ul>
<p>A worked example for use of the <code>initialise_uboot_wrapper</code> routine is provided by the <a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example"><code>uboot-driver-example</code> test application</a> for the Avnet MaaXBoard.</p>
<h2 id="build-system"><a class="header" href="#build-system">Build System</a></h2>
<p>U-Boot is, by necessity, highly configurable in terms of which functionality is included in a build and the configuration of default values / settings. The U-Boot source code relies upon a KConfig build system that results in the definition of a set of macros (typically named <code>CONFIG_xxx</code>), together with the identification of the required source code files, to manage this configuration; however, seL4 relies upon the CMake build system. To resolve this issue the following approach has been taken:</p>
<ol>
<li>
<p>Macros that are expected to be consistent across all platforms, e.g. those supporting the basic U-Boot subsystem configuration that the library relies upon, are defined in the <code>uboot_helper.h</code> header file within the library's wrapper.</p>
</li>
<li>
<p>All other configuration, i.e. macros, includes and sources files, are controlled by the library's CMake file (<code>CMakeLists.txt</code>).</p>
</li>
</ol>
<p>As such all architecture and platform dependent configuration is encapsulated within the library's CMake file. The general structure of this file is as follows:</p>
<ul>
<li>
<p>A section controlling architecture dependent settings. The settings necessary for ARM-based platforms (both ARMv7 and ARMv8) have been provided.</p>
</li>
<li>
<p>A section controlling platform dependent settings. This contains platform-specific macros, identification of drivers supporting the platform, and setup of platform specific header files.</p>
</li>
<li>
<p>One section for each class of device (e.g. clock devices, USB devices, etc.). For each class of device the generic settings are provided (i.e. settings required irrespective of the chosen driver) as well as the settings provided for each supported driver.</p>
</li>
<li>
<p>A section controlling configuration consistent across all architectures and platforms, e.g. the set of source files required by all platforms.</p>
</li>
</ul>
<p>This modular structure of the CMake file is intended to allow for the library to be incrementally extended, i.e. through the addition of support for new architectures, platforms, device classes and drivers.</p>
<h2 id="library-limitations"><a class="header" href="#library-limitations">Library Limitations</a></h2>
<p>Users of the library should be aware of its limitations, and potential workarounds for those limitations.</p>
<ol>
<li>
<p><strong>Thread safety</strong>: The library is not thread safe; as such it is the responsibility of the user to serialise access to any single instance of the library. Note, however, that multiple instances of the library may be used. For example, two instances of the library could be used concurrently, each held within separate CAmkES components/ Microkit protection domains. If multiple instances of the library are used, it is the responsibility of the user to ensure that each instance is using disjoint devices, i.e. two instances of the library would not both be able to access the same USB device; however, it should be possible for one instance to access an Ethernet device whilst a second instance accesses a USB device (see the <a href="activity/device_drivers/case_study_intro.html">case study application</a> for an example of this).</p>
</li>
<li>
<p><strong>Performance</strong>: Do not expect great performance from the library. The underlying U-Boot drivers have tended to prioritise simplicity over performance; for example the SPI driver for the Avnet MaaXBoard does not support the use of DMA transfers even though the underlying device can perform DMA transfers. Additionally, the library wrapper adds additional layers of address translations and data copying (e.g. in its support of memory mapped IO and DMA) as part of the trade-off for minimising changes necessary to the U-Boot drivers.</p>
</li>
<li>
<p><strong>U-Boot Live Device Tree</strong>: The decision has been taken for the library to utilise U-Boot's modern <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html">live device tree</a> functionality to read device tree properties rather than the historical <code>fdtdec</code> interface. Whilst this should result in improved long term support for the library, it may be necessary to make minor changes to a driver when porting an old driver to the live device tree interface. Porting is a simple activity and guidance is provided <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html#porting-drivers">here</a>.</p>
</li>
<li>
<p><strong>Interrupt Handling</strong>: The device drivers provided by U-Boot generally do not support interrupt handling; instead they rely on busy-waiting / polling of devices. There is, however, no inherent reason preventing the use of interrupt handlers. Should use of interrupt handling be required then it would need to be added by the user to the driver and the library's API would need to be enhanced to support such functionality.</p>
</li>
<li>
<p><strong>ARM Power Domains</strong>: ARM power domains are controlled through calls to the ARM Trusted Firmware (ATF). Accessing the ATF from within seL4 is not currently supported due to the need for elevated privileges. It is instead suggested that the power domains should be set as required during execution of the bootloader prior to seL4's startup. On the Avnet MaaXBoard, for example, power domains need to be enabled to power the USB PHY; therefore the USB devices need to be probed from the U-Boot bootloader prior to starting seL4 to ensure they are powered.</p>
</li>
</ol>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>The library code is held within the following structure:</p>
<pre><code class="language-text">libubootdrivers
│
├───include
│   ├───plat
│   ├───public_api
│   └───wrapper
│
├───src
│   ├───plat
│   ├───timer
│   └───wrapper
│
├───uboot
│
└───uboot_stub
</code></pre>
<p>The following conventions are maintained for each folder name:</p>
<ul>
<li><strong>plat</strong>: Folders holding platform specific source files. Contains one subfolder per platform.</li>
<li><strong>public_api</strong>: Holds header files defining the library's publicly accessible API.</li>
<li><strong>wrapper</strong>: Bespoke code written for the library.</li>
<li><strong>timer</strong>: Timer driver source code.</li>
<li><strong>uboot</strong>: A symlink to an unmodified, or minimally modified, fork of the U-Boot project. Note that the build system is responsible for creation of the symlink; for the <a href="activity/device_drivers/uboot_driver_usage.html">example test applications</a> the symlink is created by the <code>repo</code> tool.</li>
<li><strong>uboot_stub</strong>: Holds library specific replacements for U-Boot source code. Internal folder structure mirrors U-Boot code structure.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-u-boot-driver-library"><a class="header" href="#using-the-u-boot-driver-library">Using the U-Boot Driver Library</a></h1>
<p>This section outlines the library's API and provides instructions for running two test applications that demonstrate use of its drivers.</p>
<ul>
<li><a href="activity/device_drivers/uboot_driver_usage.html#library-api">Library API</a></li>
<li><a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example">Test application: <code>uboot-driver-example</code></a></li>
<li><a href="activity/device_drivers/uboot_driver_usage.html#test-application-picoserver_uboot">Test application: <code>picoserver_uboot</code></a></li>
</ul>
<h2 id="library-api"><a class="header" href="#library-api">Library API</a></h2>
<p>At the core of the library's public API (see library folder <code>include/public_api</code> for full details) are:</p>
<ul>
<li>
<p>Routines to initialise (<code>initialise_uboot_drivers</code>) and shutdown (<code>shutdown_uboot_drivers</code>) the library that must book-end the usage of all other API routines;</p>
</li>
<li>
<p>A routine (<code>run_uboot_command</code>) to allow execution of the same textual commands as used at the <a href="activity/device_drivers/first_boot.html#boot-to-u-boot-prompt">U-Boot prompt</a>. For example, in the <a href="activity/device_drivers/uboot_library_add_driver.html#establishing-the-driver-api">I<sup>2</sup>C worked example</a>, it is shown how the U-Boot <code>i2c</code> command is added and used, e.g. to probe the bus.</p>
</li>
</ul>
<p>Although this provides a relatively simple API, it is intuitive as it has a direct analogue to the commands available at the U-Boot command line. There are limitations, but the API can be readily developed further to expose more functionality, for example:</p>
<ul>
<li>
<p>To accept arguments through parameter passing rather than through a textual command;</p>
</li>
<li>
<p>To return data or results rather than printing outcomes to the console;</p>
</li>
<li>
<p>To expose lower-level interfaces than the U-Boot commands permit, for example access to raw Ethernet frames.</p>
</li>
</ul>
<p>It is expected that the source code of the U-Boot commands are likely to provide a starting point for extended API routines.</p>
<p>A number of worked examples have been provided for extensions to the core API described above:</p>
<ul>
<li>
<p>For accessing the <code>stdin</code> file maintained by U-Boot, routines <code>uboot_stdin_&lt;...&gt;</code> have been provided to enable testing whether characters are available and to retrieve them. The <code>uboot-driver-example</code> test application demonstrates usage of these API routines for retrieving characters typed on a connected USB keyboard.</p>
</li>
<li>
<p>For reading and sending raw Ethernet frames, routines <code>uboot_eth_&lt;...&gt;</code> have been provided. The <code>picoserver_uboot</code> test application demonstrates usage of these API routines to integrate the library with the picoTCP stack.</p>
</li>
</ul>
<p>Sections below give a basic overview of the test applications and how to build and run them.</p>
<h2 id="test-application-uboot-driver-example"><a class="header" href="#test-application-uboot-driver-example">Test application: <code>uboot-driver-example</code></a></h2>
<h3 id="overview-of-the-uboot-driver-example-test-application"><a class="header" href="#overview-of-the-uboot-driver-example-test-application">Overview of the <code>uboot-driver-example</code> test application</a></h3>
<p>The source file at <code>camkes/apps/uboot-driver-example/components/Test/src/test.c</code>/ <code>project_libs/example/maaxboard/uboot-driver-example/uboot-driver-example.c</code> represents the script for the test application. It contains <code>run_uboot_cmd("...")</code> calls to U-Boot commands that are supported by the library. The set of supported commands can be readily seen in the <code>cmd_tbl</code> entries of <code>projects_libs/libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code>.</p>
<p>It is left to the reader to look through the test script in detail, but the features demonstrated include the following.</p>
<ul>
<li>The MaaXBoard's two integral LEDs are toggled.</li>
<li>Ping operations.</li>
<li>USB operations<sup class="footnote-reference"><a href="#1">1</a></sup>, including:
<ul>
<li>identify and list (<code>ls</code>) the contents of a USB flash drive, if connected;</li>
<li>read and echo keypresses from a USB keyboard, if connected, during a defined period.</li>
</ul>
</li>
<li>SD/MMC operations to identify and list (<code>ls</code>) the contents of the SD card.</li>
<li>Filesystem operations to write a file to a FAT partition on the SD card before reading the contents back and deleting the file.</li>
<li>I<sup>2</sup>C operations to probe the bus and read the power management IC present on the MaaXBoard's I<sup>2</sup>C bus. (There are more details in the <a href="activity/device_drivers/add_driver_worked_example.html">worked example</a> that walks through the steps that were required to add this driver.)</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<p>Other utility commands are exercised, such as <code>dm tree</code>, which is useful to follow the instantiation of device drivers, and <code>clocks</code> which lists all the available clocks. As well as 'headline' drivers like USB, there are also some fundamental 'building block' drivers in the library, for elements such as clocks, IOMUX, and GPIO, which are needed by other drivers.</p>
<h4 id="configuration-for-different-platforms"><a class="header" href="#configuration-for-different-platforms">Configuration for different platforms</a></h4>
<p>Although <code>uboot-driver-example</code> was created to demonstrate the device drivers developed for this MaaXBoard developer kit, it is configurable to support other platforms. For example, in the <a href="activity/device_drivers/add_odroidc2.html">worked example appendix for the Odroid-C2</a>, a small subset of drivers has been developed for that platform, and the <code>test.c</code> source file for <code>uboot-driver-example</code> uses the preprocessor macros <code>CONFIG_PLAT_MAAXBOARD</code> and <code>CONFIG_PLAT_ODROIDC2</code> to configure which commands are run for each platform. By default, all tests are enabled for an unrecognised platform, but this would be readily configured for a new platform's <code>CONFIG_PLAT_...</code> preprocessor macro.</p>
<h3 id="instructions-for-running-uboot-driver-example"><a class="header" href="#instructions-for-running-uboot-driver-example">Instructions for running <code>uboot-driver-example</code></a></h3>
<h4 id="camkes-2"><a class="header" href="#camkes-2">CAmkES</a></h4>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_test
cd /host/uboot_test
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The test application includes an Ethernet operation (<code>ping</code>) with hard-coded IP addresses; these need to be customised for an individual's environment. The following lines of the source file <code>projects/camkes/apps/uboot-driver-example/components/Test/src/test.c</code> should be edited:</p>
<pre><code class="language-c">run_uboot_command("setenv ipaddr xxx.xxx.xxx.xxx"); // IP address to allocate to MaaXBoard
run_uboot_command("ping yyy.yyy.yyy.yyy"); // IP address of host machine
</code></pre>
<p>Optionally, to <code>ping</code> to an address beyond the local network:</p>
<pre><code class="language-c">run_uboot_command("setenv gatewayip zzz.zzz.zzz.zzz"); // IP address of router
run_uboot_command("setenv netmask 255.255.255.0");
run_uboot_command("ping 8.8.8.8"); // An example internet IP address (Google DNS)
</code></pre>
<p>From the <code>/host/uboot_test</code> directory, execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=uboot-driver-example -DPLATFORM=maaxboard -DSIMULATION=FALSE
</code></pre>
<pre><code class="language-bash">ninja
</code></pre>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<h3 id="instructions-for-running-uboot-driver-example-1"><a class="header" href="#instructions-for-running-uboot-driver-example-1">Instructions for running <code>uboot-driver-example</code></a></h3>
<h4 id="microkit-2"><a class="header" href="#microkit-2">Microkit</a></h4>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_test
cd /host/uboot_test
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/microkit_manifest
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The test application includes an Ethernet operation (<code>ping</code>) with hard-coded IP addresses; these need to be customised for an individual's environment. The following lines of the source file <code>microkit/example/maaxboard/uboot-driver-example/uboot-driver-example.c</code> should be edited:</p>
<pre><code class="language-c">run_uboot_command("setenv ipaddr xxx.xxx.xxx.xxx"); // IP address to allocate to MaaXBoard
run_uboot_command("ping yyy.yyy.yyy.yyy"); // IP address of host machine
</code></pre>
<p>Optionally, to <code>ping</code> to an address beyond the local network:</p>
<pre><code class="language-c">run_uboot_command("setenv gatewayip zzz.zzz.zzz.zzz"); // IP address of router
run_uboot_command("setenv netmask 255.255.255.0");
run_uboot_command("ping 8.8.8.8"); // An example internet IP address (Google DNS)
</code></pre>
<p>From the <code>/host/uboot_test/project_libs</code> directory, execute the following command:</p>
<pre><code class="language-bash">./init-build.sh -DMICROKIT_APP=uboot-driver-example -DPLATFORM=maaxboard
</code></pre>
<p>A successful build will result in an executable file called <code>sel4_image</code> in the <code>project_libs/example/maaxboard/uboot-driver-example/example-build</code> subdirectory. This file should be made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<h2 id="test-application-picoserver_uboot"><a class="header" href="#test-application-picoserver_uboot">Test application: <code>picoserver_uboot</code></a></h2>
<h3 id="overview-of-the-picoserver_uboot-test-application"><a class="header" href="#overview-of-the-picoserver_uboot-test-application">Overview of the <code>picoserver_uboot</code> test application</a></h3>
<p>It is not the purpose of this developer kit to give a CAmkES tutorial (e.g. see <a href="https://docs.sel4.systems/projects/camkes/">seL4's documentation</a>), but this application is based on the following CAmkES model:</p>
<p><img src="activity/device_drivers/figures/picoserver-camkes.png" alt="Picoserver CAmkES overview" /></p>
<p>EthDriverUboot is a simple implementation of an Ethernet driver that has been ported from U-Boot. PicoServer provides a picoTCP TCP/IP stack on top of this, and the Echo component simply listens on port 1234 of a given IP address, echoing received characters on the display. (An additional component TimeServer has been omitted from the diagram for clarity, but see the <a href="activity/device_drivers/case_study_intro.html">case study application</a> for more details.)</p>
<h3 id="instructions-for-running-picoserver_uboot"><a class="header" href="#instructions-for-running-picoserver_uboot">Instructions for running <code>picoserver_uboot</code></a></h3>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_pico
cd /host/uboot_pico
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>From the <code>/host/uboot_pico</code> directory, execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=picoserver_uboot -DPLATFORM=maaxboard -DSIMULATION=FALSE -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
ninja
</code></pre>
<p>where <code>xxx.xxx.xxx.xxx</code> is the IP address to allocate to the MaaXBoard.</p>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>When the <code>picoserver_uboot</code> application is running on the MaaXBoard, it should confirm that it is listening on port 1234 of the supplied IP address. It will also confirm registration of the protocol stack layers. The application allocates a random MAC address.</p>
<p>At any time while running, the application may display <code>No such port ....</code> messages as it monitors traffic on the network; this is expected behaviour that may be ignored.</p>
<p>Meanwhile, from a terminal window on the host machine, use the <code>netcat</code> (<code>nc</code>) command (native to Linux or macOS, or available as a <a href="https://nmap.org/ncat/">download</a> for Windows), where <code>xxx.xxx.xxx.xxx</code> is the IP address of the MaaXBoard, as previously specified:</p>
<pre><code class="language-bash">nc xxx.xxx.xxx.xxx 1234
</code></pre>
<p>On the MaaXBoard (via CoolTerm as usual), a message like the following should be seen:</p>
<pre><code class="language-text">echo: Connection established with yyy.yyy.yyy.yyy on socket 1
</code></pre>
<p>where <code>yyy.yyy.yyy.yyy</code> is the IP address of the host machine.</p>
<p>From the host machine's terminal, strings may be typed until <code>nc</code> is terminated with Ctrl-C:</p>
<pre><code class="language-bash">hostmachine ~ % nc 192.168.0.111 1234
Hello world!
Goodbye
^C
hostmachine ~ %
</code></pre>
<p>Each time carriage return is entered, the <code>picoserver_uboot</code> application will display the string, until the <code>nc</code> session is terminated, upon which the connection will be closed:</p>
<pre><code class="language-text">echo: Connection established with 192.168.0.11 on socket 1
echo: Received message of length 13 --&gt; Hello world!
echo: Received message of length 8 --&gt; Goodbye
echo: Connection closing on socket 2
echo: Connection closed on socket 2
</code></pre>
<p>Connections can be re-established simply by issuing another <code>nc</code> command.</p>
<h4 id="implementation-note"><a class="header" href="#implementation-note">Implementation note</a></h4>
<p>Connecting, disconnecting, and reconnecting to a network can give rise to delays in the order of a few minutes while the elements in the network handshake and resynchronise, particularly in the case of our application, which assigns a random MAC address to the same IP address each time it runs. If the connection is not established promptly, the easiest remedial options are:</p>
<ul>
<li>Start from a clean reboot of the host machine (which will include flushing its DNS cache); or</li>
<li>Be patient! (If you are prepared to wait for a few minutes, the connection will be made. Note that <code>nc</code> may timeout after a while if no connection is made, so the command would need to be repeated.)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-platform"><a class="header" href="#library-extension---new-platform">Library Extension - New Platform</a></h1>
<p>This section documents the required actions and guidance to add support for a new platform to the library.</p>
<p>By the end of this section, an seL4 executable will be built for the new platform that can initialise the library (although the library may not support any of the platform's devices). Later sections of this guide cover the required actions to add driver support into the library for the new platform (e.g. see the <a href="activity/device_drivers/add_odroidc2.html">Odroid-C2 worked example</a>).</p>
<p>Throughout the sections of this guide devoted to extension of the U-Boot driver library, it is expected the developer is working within the folder structure created by the <code>repo</code> tool (e.g. as used to build the <a href="activity/device_drivers/uboot_driver_usage.html">test applications</a>). Key folders and files within the hierarchy are shown below:</p>
<h3 id="camkes-3"><a class="header" href="#camkes-3">CAmkES</a></h3>
<pre><code class="language-text">&lt;manifest root&gt;
|
├───kernel
│   └───tools
│       └───dts
│
└───projects
    ├───camkes
    │   └───apps
    │       └───uboot-driver-example
    │           └───include
    │               └───plat
    │                   └───&lt;platform name&gt;
    │                       └───platform_devices.h
    │
    ├───projects_libs
    │   └───libubootdrivers
    │       ├───include
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.h
    │       ├───src
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.c
    │       └───CMakeLists.txt
    │
    └───uboot
</code></pre>
<ul>
<li><code>kernel/tools/dts</code>: Location of platform device trees.</li>
<li><code>projects/project_libs/camkes/apps/uboot-driver-example</code>: <a href="activity/device_drivers/uboot_driver_usage.html">The test application</a>.</li>
<li><code>projects/project_libs/libubootdrivers</code>: Referred to as "the library" throughout. See <a href="https://github.com/sel4devkit/projects_libs/tree/master/libubootdrivers">linked Git repository</a>.</li>
<li><code>projects/uboot</code>: Fork of the U-Boot project source code (note, this is also symlinked to <code>projects/project_libs/libubootdrivers/uboot</code>).</li>
</ul>
<h3 id="microkit-3"><a class="header" href="#microkit-3">Microkit</a></h3>
<pre><code class="language-text">&lt;manifest root&gt;
|
└───project_libs
    ├───include
    │   └───&lt;platform&gt;
    │       └───all_platform_devices.h
    │
    ├───libubootdrivers
    │       ├───include
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.h
    │       ├───src
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.c
    │       └───CMakeLists.txt
    │
    ├───boards
    │      └───&lt;platform&gt;.dts
    │ 
    ├───example
    │   └───&lt;platform&gt;
    │       └───uboot-driver-example
    │
    └───uboot
</code></pre>
<ul>
<li><code>project_libs/boards</code>: Location of platform device trees.</li>
<li><code>example/&lt;platform&gt;/uboot-driver-example</code>: <a href="activity/device_drivers/uboot_driver_usage.html">The test application</a>.</li>
<li><code>project_libs/libubootdrivers</code>: Referred to as "the library" throughout. See <a href="https://github.com/sel4-cap/dev-kit-libs/tree/main/libubootdrivers">linked Git repository</a>.</li>
<li><code>project_libs/uboot</code>: Fork of the U-Boot project source code (note, this is also symlinked to <code>microkit/libubootdrivers/uboot</code>).</li>
</ul>
<h2 id="required-reading"><a class="header" href="#required-reading">Required Reading</a></h2>
<p>The developer should be familiar with the following tools and concepts in order to add platform and driver support to the library.</p>
<ul>
<li>
<p><em>Device Tree</em>: An introduction to device tree data is <a href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html">provided by the Linux documentation</a> and by the <a href="https://docs.zephyrproject.org/2.6.0/guides/dts/intro.html">Zephyr project</a>.</p>
</li>
<li>
<p><em>CMake</em>: Reference documentation is provided by <a href="https://cmake.org/cmake/help/latest/">the CMake project</a>, including details of the structure and syntax of the CMakeLists.txt file.</p>
</li>
<li>
<p><em>CAmkES</em>: The seL4 foundation provides <a href="https://docs.sel4.systems/projects/camkes/">documentation on its use of CAmkES</a> including tutorials.</p>
</li>
<li>
<p><em>Microkit</em>: The seL4 foundation provides <a href="https://github.com/seL4/microkit/blob/main/docs/manual.md">documentation on its use of Microkit</a> including tutorials.</p>
</li>
</ul>
<h2 id="add-basic-support-to-library"><a class="header" href="#add-basic-support-to-library">Add basic support to library</a></h2>
<p>To allow the library to be successfully compiled for a new platform, the following changes will need to be made to the library.</p>
<h3 id="update-the-librarys-cmake-file-to-support-the-platform"><a class="header" href="#update-the-librarys-cmake-file-to-support-the-platform">Update the library's CMake file to support the platform</a></h3>
<p>The library's CMake file (located at <code>project_libs/libubootdrivers/CMakeLists.txt</code>) contains a section titled <code>Platform specific settings</code> to control the settings for each platform. This section:</p>
<ol>
<li>
<p>Declares a set of variables to control which drivers and optional capabilities are to be built for each platform. The default values produce a build including only a dummy timer driver; this is the minimum necessary to allow the library to be built.</p>
</li>
<li>
<p>Provides a conditional block of settings associated with each supported platform, e.g. to control which of the supported drivers to build. If no conditional block is supplied for a platform, the compilation of the library fails and an error message is returned.</p>
</li>
</ol>
<p>The minimal change to this section that allows the library to be built is therefore the inclusion of a conditional block for the platform, even if that section makes no changes to the default settings. For example, to add support for a platform that is named  <code>foo</code> within the seL4 build system, the following changes would be required:</p>
<pre><code class="language-makefile">    # Set up the applicable drivers and platform dependent configuration.
    if(KernelPlatImx8mq)
        ...
+   elseif("${KernelPlatform}" STREQUAL "foo")
+       # Platform specific settings for the Foo board.
    else()
        message(FATAL_ERROR "Unsupported platform. Aborting.")
    endif()
</code></pre>
<p>Note that where settings are shared across multiple platforms, this logic can be simplified to reflect the shared settings. An example of this is provided in the library's <code>CMakeLists.txt</code> for the <code>maaxboard</code> and <code>imx8mq-evk</code> platforms, which both use the iMX8MQ SoC.</p>
<p>It should also be noted that U-Boot drivers can support multiple devices. For example, many of the drivers added to support the Avnet MaaXBoard support multiple iMX SoCs. If previously supported drivers are compatible with the new platform, this support can be added now; for example, if platform <code>foo</code> has a GPIO device supported by the <code>gpio_mxc</code> driver (as used by the Avnet MaaXBoard), then the line <code>set(gpio_driver "gpio_mxc")</code> could be added to the <code>foo</code> platform's settings to enable support.</p>
<p>To enable access to platform specific header files it is necessary to create a symlink within the U-Boot code structure named <code>arch</code> to one of the many <code>arch-xxx</code> folders provided by U-Boot; this mimics an equivalent action taken by U-Boot's native build system. As an example it can be seen that for the iMX8MQ based platforms the <code>arch</code> symlink points to the <code>arch-imx8m</code> folder. It is expected that identification of the correct folder to link to will in most cases will be possible through naming convention alone. To definitively determine the folder to link, the symlink created during a build of U-Boot could be inspected.</p>
<h3 id="define-platform-specific-linker-lists-data-structure"><a class="header" href="#define-platform-specific-linker-lists-data-structure">Define platform specific Linker Lists data structure</a></h3>
<p>As documented within the <a href="activity/device_drivers/uboot_driver_library.html#linker-lists">Linker Lists section of the library overview</a>, the library requires a global data structure named <code>driver_data</code> to be declared to allow the U-Boot source code to access optional functionality included in the executable.</p>
<p>To define <code>driver_data</code> for the new platform, new platform-specific files must be added to the library. The code blocks that follow provide minimal templates for these files that include the base device classes, drivers for those classes, and base commands that are required by all platforms.</p>
<p>File <code>include/plat/foo/plat_driver_data.h</code>:</p>
<pre><code class="language-c">/*
 * This file defines which drivers, driver classes, driver entries and commands
 * are to be included in the compiled library for this platform.
 *
 * This allows only the drivers compatible with the targeted platform to be
 * included with all non-compatible drivers excluded.
 *
 * It should be noted that some of these are fundamental to allowing the U-Boot
 * driver model to function (e.g. the nop, root and simple bus drivers).
 */

/* Define the number of different driver elements to be used on this platform */
#define _u_boot_uclass_driver_count     5
#define _u_boot_driver_count            2
#define _u_boot_usb_driver_entry_count  0
#define _u_boot_part_driver_count       0
#define _u_boot_cmd_count               3
#define _u_boot_env_driver_count        0
#define _u_boot_env_clbk_count          0
#define _u_boot_driver_info_count       0
#define _u_boot_udevice_count           0

/* Define the uclass drivers to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_uclass_driver_count */
extern struct uclass_driver _u_boot_uclass_driver__nop;
extern struct uclass_driver _u_boot_uclass_driver__root;
extern struct uclass_driver _u_boot_uclass_driver__simple_bus;
extern struct uclass_driver _u_boot_uclass_driver__phy;
extern struct uclass_driver _u_boot_uclass_driver__blk;

/* Define the drivers to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_driver_count */
extern struct driver _u_boot_driver__root_driver;
extern struct driver _u_boot_driver__simple_bus;

/* Define the driver entries to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_usb_driver_entry_count */

/* Define the disk partition types to be used. The count of declarations
 * in this section must match the value of _u_boot_part_driver_count */

/* Define the u-boot commands to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_cmd_count */
extern struct cmd_tbl _u_boot_cmd__dm;
extern struct cmd_tbl _u_boot_cmd__env;
extern struct cmd_tbl _u_boot_cmd__setenv;

/* Define the u-boot environment variables callbacks to be used on this platform. The
 * count of declarations in this section must match the value of _u_boot_env_clbk_count */
</code></pre>
<p>File <code>src/plat/foo/plat_driver_data.c</code>:</p>
<pre><code class="language-c">#include &lt;uboot_helper.h&gt;
#include &lt;driver_data.h&gt;

#include &lt;dm/device.h&gt;
#include &lt;dm/uclass.h&gt;
#include &lt;dm/platdata.h&gt;
#include &lt;usb.h&gt;
#include &lt;part.h&gt;

void initialise_driver_data(void) {
    /* The number of elements in the uclass_driver_array must match the
     * _u_boot_uclass_driver_count constant (see plat_driver_data.h) */
    driver_data.uclass_driver_array[0]  = _u_boot_uclass_driver__nop;
    driver_data.uclass_driver_array[1]  = _u_boot_uclass_driver__root;
    driver_data.uclass_driver_array[2]  = _u_boot_uclass_driver__simple_bus;
    driver_data.uclass_driver_array[3]  = _u_boot_uclass_driver__phy;
    driver_data.uclass_driver_array[4]  = _u_boot_uclass_driver__blk;

    /* The number of elements in the driver_array must match the
     * _u_boot_driver_count constant (see plat_driver_data.h) */
    driver_data.driver_array[0]  = _u_boot_driver__root_driver;
    driver_data.driver_array[1]  = _u_boot_driver__simple_bus;

    /* The number of elements in the cmd_array must match the
     * _u_boot_cmd_count constant (see plat_driver_data.h) */
    driver_data.cmd_array[0]  = _u_boot_cmd__dm;
    driver_data.cmd_array[1]  = _u_boot_cmd__env;
    driver_data.cmd_array[2]  = _u_boot_cmd__setenv;
}
</code></pre>
<p>As support for additional optional objects (e.g. drivers, driver classes, commands, etc.) are added for a platform, these files will be updated to reference the associated objects. See the files for the Avnet MaaXBoard platform for an example of these how these files provide more extensive support.</p>
<h2 id="add-support-to-example-application"><a class="header" href="#add-support-to-example-application">Add support to example application</a></h2>
<p>Section <a href="activity/device_drivers/uboot_driver_usage.html">Using the U-Boot Driver Library</a> introduced the demonstration application  <code>uboot-driver-example</code>. This section documents the changes required to the <code>uboot-driver-example</code> application to allow it to be built for the new platform.</p>
<p>The following empty template file needs to be added to the application <code>include/plat/foo/platform_devices.h</code>:</p>
<h3 id="camkes-4"><a class="header" href="#camkes-4">CAmkES</a></h3>
<pre><code class="language-c">#pragma once

/* List the set of device tree paths that include the 'reg' entries
 * for memory regions that will need to be mapped */
#define REG_PATHS {};
#define REG_PATH_COUNT 0

/* List the set of device tree paths for the devices we wish to access.
 * Note these need to be the root nodes of each device to be accessed */
#define DEV_PATHS {};
#define DEV_PATH_COUNT 0

/* Provide the hardware settings for CAmkES. Note that we only need to inform
 * CAmkES of the devices with memory mapped regions, i.e. the REG_xxx
 * devices. See https://docs.sel4.systems/projects/camkes for syntax */

#define HARDWARE_INTERFACES

#define HARDWARE_COMPOSITION

#define HARDWARE_CONFIGURATION
</code></pre>
<h3 id="microkit-4"><a class="header" href="#microkit-4">Microkit</a></h3>
<pre><code class="language-c">#pragma once

/* List the set of device tree paths that include the 'reg' entries
 * for memory regions that will need to be mapped */
#define REG_PATHS {};
#define REG_PATH_COUNT 0

/* List the set of device tree paths for the devices we wish to access.
 * Note these need to be the root nodes of each device to be accessed */
#define DEV_PATHS {};
#define DEV_PATH_COUNT 0
</code></pre>
<p>As support for devices is added for a platform, this file will be updated to reference those devices from the platform's device tree. See the file for the Avnet MaaXBoard platform for an example that provides more extensive support.</p>
<h2 id="guidance-on-next-steps"><a class="header" href="#guidance-on-next-steps">Guidance on next steps</a></h2>
<p>At this point, the library should compile cleanly for the new platform but will fail during library initialisation due to no devices being supplied.</p>
<p>The order in which drivers need to be added is likely to depend on the intended usage of the library; e.g. support for a single device or support for multiple devices, and the internal needs of the device drivers to be added.</p>
<p>The following drivers are likely to form the core of the support for a platform and underpin the capabilities of other drivers. It may be possible to support some devices without these core drivers, but that would need to checked on a case-by-case basis.</p>
<h3 id="timer-1"><a class="header" href="#timer-1">Timer</a></h3>
<p>As documented <a href="activity/device_drivers/uboot_driver_library.html#timer">in the library overview</a>, some U-Boot drivers rely upon access to a monotonic timer to underpin their timing needs.</p>
<p>By default a platform will be supported by the <code>dummy</code> timer driver (see library file <code>src/timer/timer_dummy.c</code>). Whilst the dummy timer driver allows the library to build cleanly, it will raise an assertion error / exception, thereby halting execution, should any of the timing routines be used. Some simple drivers (e.g. GPIO drivers) typically do not require any timing routines and so can be supported without the need to provide a functional timer; however, a functional timer will typically need to be provided to support more complex devices such as Ethernet or USB.</p>
<p>The means of providing a timer driver is architecture- and platform-dependent, so detailed guidance cannot be provided. A worked example of a timer driver for the iMX8MQ SoC is provided in file <code>src/timer/timer_imx8mq.c</code>; it is expected that this driver could be extended to cover multiple iMX SoCs.</p>
<h3 id="clock"><a class="header" href="#clock">Clock</a></h3>
<p>The U-Boot <code>CLK</code> subsystem is used to enable and reconfigure clocks. To enable the <code>CLK</code> subsystem, support for the platform's U-Boot clock driver will need to be added. See the configuration of the clock driver for the Avnet MaaXBoard in the library's <code>CMakeLists.txt</code> file as an example.</p>
<p>In many cases it may be possible to support devices without the need to add support for a clock driver. Simple devices, e.g. GPIO, may not use a clock source. Even for more complex devices that use a clock source, it may be possible for the device to function without providing a clock driver; e.g. if the device was previously set up and used by the bootloader prior to entry to seL4 then it is likely that the required clocks have already been configured and enabled.</p>
<h3 id="pin-multiplexing-iomux"><a class="header" href="#pin-multiplexing-iomux">Pin Multiplexing (IOMUX)</a></h3>
<p>SoCs typically contain a lot of functionality but a have limited number of pins (or pads). Pin multiplexing is used to configure pins for a specific purpose. An IOMUX driver must be supplied to allow the library to configure the pins from the default configuration.</p>
<p>As with the clock driver, in many cases it may be possible to support devices without the need to add support for an IOMUX driver. For example, if a device was previously set up and used by the bootloader prior to entry to seL4 then it is likely that the required pin configuration has already been configured.</p>
<h3 id="gpio"><a class="header" href="#gpio">GPIO</a></h3>
<p>Many drivers rely upon the availability of a GPIO driver to function correctly. For example: an MMC driver may use GPIO for card-detect and write-protect sensing; an Ethernet driver may use GPIO to reset an external PHY; an SPI driver may use GPIO for the chip select signal, etc.</p>
<p>As such it may be necessary to provide a GPIO driver for other drivers to function correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-driver"><a class="header" href="#library-extension---new-driver">Library Extension - New Driver</a></h1>
<p>This section provides guidance on the addition of a new device driver to support a device on an existing platform.</p>
<p>Adding support for a new device can be broken down into logical steps:</p>
<ol>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#identification-of-u-boot-device-driver">Identification of U-Boot Device Driver</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#updating-cmakeliststxt">Updating the library <code>CMakeLists.txt</code> to support the device driver</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#associating-driver-with-platform">Associating the device driver with an existing platform</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#resolving-compilation-issues">Resolving compilation issues</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#updating-sel4-application">Updating an seL4 application to access the device</a></p>
</li>
</ol>
<p>To further support this topic, documentation have been added to provide <a href="activity/device_drivers/add_driver_worked_example.html">a worked example</a> and to discuss <a href="activity/device_drivers/driver_troubleshooting.html">troubleshooting and common issues</a> that may be encountered.</p>
<h2 id="identification-of-u-boot-device-driver"><a class="header" href="#identification-of-u-boot-device-driver">Identification of U-Boot Device Driver</a></h2>
<p>The first step in adding a new device driver to the library is to positively identify the U-Boot source file providing the required support. U-Boot declares drivers through use of a macro of the following format:</p>
<pre><code class="language-c">U_BOOT_DRIVER(&lt;driver_id&gt;) = {
    .name = "&lt;driver_name&gt;",
    .id = UCLASS_&lt;driver_uclass_id&gt;,
    ...
};
</code></pre>
<p>An example of such a declaration from the GPIO driver for the Avnet MaaXBoard can be found in the U-Boot source code within file <code>drivers/gpio/mxc_gpio.c</code>.</p>
<p>If a build of U-Boot with support for the desired device is available, the name of the device driver can be obtained through use of U-Boot's <code>dm tree</code> command.</p>
<p>For example, to determine the GPIO device driver for a platform the following <code>dm tree</code> output would identify that the U-Boot driver with a <code>&lt;driver_name&gt;</code> of <code>gpio_mxc</code> provides the desired support. Note that the name of the device (as per the platform's device tree) is provided in the <code>Name</code> column whilst the <code>&lt;driver_name&gt;</code> is provided in the <code>Driver</code> column.</p>
<pre><code class="language-text">u-boot=&gt; dm tree
 Class     Index  Probed  Driver                Name
-----------------------------------------------------------
 root          0  [ + ]   root_driver           root_driver
 simple_bus    0  [ + ]   simple_bus            `-- soc@0
 simple_bus    1  [ + ]   simple_bus                |-- bus@30000000
 gpio          0  [ + ]   gpio_mxc                  |   |-- gpio@30200000
 gpio          1  [   ]   gpio_mxc                  |   |-- gpio@30210000
 gpio          2  [   ]   gpio_mxc                  |   |-- gpio@30220000
 gpio          3  [   ]   gpio_mxc                  |   |-- gpio@30230000
 gpio          4  [   ]   gpio_mxc                  |   |-- gpio@30240000
 ...
</code></pre>
<p>If no such build of U-Boot is available, the device driver can be obtained through manual matching of the <code>compatible</code> strings between the platform's device tree and a device driver.</p>
<p>For example, from the following device tree excerpt it can be seen that the GPIO device is compatible with a device driver that advertises compatibility to either <code>fsl,imx8mq-gpio</code> or <code>fsl,imx35-gpio</code> devices.</p>
<pre><code class="language-text">gpio@30200000 {
    compatible = "fsl,imx8mq-gpio\0fsl,imx35-gpio";
    ...
};
</code></pre>
<p>Performing a textual search for these compatibility strings within the U-Boot source code provides the following match for the <code>fsl,imx35-gpio</code> compatibility string:</p>
<pre><code class="language-c">static const struct udevice_id mxc_gpio_ids[] = {
    { .compatible = "fsl,imx35-gpio" },
    { }
};

U_BOOT_DRIVER(gpio_mxc) = {
    .name = "gpio_mxc",
    .id = UCLASS_GPIO,
    ...
    .of_match = mxc_gpio_ids,
    ...
};
</code></pre>
<p>Through either method, the U-Boot source file declaring the driver can be identified.</p>
<h2 id="updating-cmakeliststxt"><a class="header" href="#updating-cmakeliststxt">Updating <code>CMakeLists.txt</code></a></h2>
<p>Once the source file declaring the driver has been established, this information can be captured in the library CMake file (<code>CMakeLists.txt</code>).</p>
<p>The CMake file contains sections devoted to each class of driver (also known as a <code>UCLASS</code> in U-Boot), e.g. Ethernet drivers, MMC drivers, etc. If the driver to be added is of a previously unsupported class then a new section will need to be added; this will typically have the following structure (using the GPIO driver class as an example supporting a single driver):</p>
<pre><code class="language-makefile">#############################
# Settings for GPIO drivers #
#############################

if(gpio_driver MATCHES "none")
    # Nothing to do
else()
    # Enable GPIO support
    add_definitions("-DCONFIG_DM_GPIO=1")
    add_definitions("-DCONFIG_GPIO_EXTRA_HEADER=1")
    add_definitions("-DCONFIG_CMD_GPIO_READ=1")
    # Generic GPIO source files
    list(APPEND uboot_deps uboot/cmd/gpio.c)
    list(APPEND uboot_deps uboot/drivers/gpio/gpio-uclass.c)

    # Driver specific settings / files
    if(gpio_driver MATCHES "gpio_mxc")
        list(APPEND uboot_deps uboot/drivers/gpio/mxc_gpio.c)
    else()
        message(FATAL_ERROR "Unrecognised GPIO driver. Aborting.")
    endif()
endif()
</code></pre>
<p>This structure allows configuration settings to be defined, such as configuration macros and source files, which are set regardless of the driver to be used, as well as configuration settings specific to each driver.</p>
<p>To identify the required configuration macros (using <code>add_definitions("-D&lt;macro_name&gt;=1")</code>) it is suggested that the macros generated by a build of U-Boot are examined (contained in the <code>.config</code> file following configuration of U-Boot). If a build of U-Boot is unavailable, the <code>defconfig</code> file for the platform can be examined (see U-Boot files <code>config/&lt;platform&gt;_defconfig</code>). Alternatively, how the configuration macros themselves are used within the U-Boot source code can be examined (see instances of <code>#if ...</code>).</p>
<p>For a new driver class, it is recommended that two source files are listed for all drivers (using <code>list(APPEND uboot_deps &lt;file&gt;)</code>):</p>
<ol>
<li>The source file declaring U-Boot commands related to the driver class. For example, U-Boot commands related to GPIO are stored in the <code>uboot/cmd/gpio.c</code> file.</li>
<li>The source file declaring the UCLASS driver for the driver class. A UCLASS driver is declared in U-Boot using the <code>UCLASS_DRIVER</code> macro. For example, the U-Boot GPIO UCLASS driver is declared in the <code>uboot/drivers/gpio/gpio-uclass.c</code> file.</li>
</ol>
<p>For a new driver it is recommended that the single source file declaring the driver (as identified in the <a href="activity/device_drivers/uboot_library_add_driver.html#identification-of-u-boot-device-driver">previous step</a>) is set.</p>
<p>It is accepted at this stage that the set of source files may not be complete; this is resolved in a later step.</p>
<p>Note that by convention, the driver naming used in <code>CMakeLists.txt</code> matches the driver name used by U-Boot, e.g. in its <code>dm tree</code> output (e.g. <code>gpio_mxc</code>).</p>
<h2 id="associating-driver-with-platform"><a class="header" href="#associating-driver-with-platform">Associating Driver With Platform</a></h2>
<p>To associate the driver with the platform, the following changes need to be made.</p>
<h3 id="cmakeliststxt"><a class="header" href="#cmakeliststxt"><code>CMakeLists.txt</code></a></h3>
<p>Within the platform specific section of the library <code>CMakeLists.txt</code> file, the variable holding the selected driver for the driver class must be set. For example, if a GPIO driver named <code>gpio_foo</code> has been added for platform <code>foo</code> then the following would be added:</p>
<pre><code class="language-makefile">    # Set up the applicable drivers and platform dependent configuration.
    if(KernelPlatImx8mq)
        ...
    elseif("${KernelPlatform}" STREQUAL "foo")
        # Platform specific settings for the Foo board.
+       set(gpio_driver "gpio_foo")
    else()
        message(FATAL_ERROR "Unsupported platform. Aborting.")
    endif()
</code></pre>
<h3 id="plat_driver_datah"><a class="header" href="#plat_driver_datah"><code>plat_driver_data.h</code></a></h3>
<p>The <code>plat_driver_data.h</code> and <code>plat_driver_data.c</code> files are used to create arrays of objects, such as drivers or commands, that U-Boot normally stores in dedicated linker sections (see <a href="activity/device_drivers/uboot_driver_library.html#linker-lists">documentation on linker lists</a> for details). The objects are declared in U-Boot source files via macros of the form <code>U_BOOT_&lt;object_type&gt; = { ... };</code>. All objects that the library needs to access must be declared and enumerated in  <code>plat_driver_data.h</code> and added to the <code>driver_data</code> structure within <code>plat_driver_data.c</code>.</p>
<p>Within the platform's <code>include/plat/&lt;platform&gt;/plat_driver_data.h</code> file, the new objects from the added source files (e.g. driver, UCLASS driver, commands, etc.) need to be declared, and the counts of each class of object needs to be updated. It should be noted that sometimes multiple drivers or UCLASS drivers are required to support a single device.</p>
<p>For example, if a GPIO driver were to be added then it is expected that the GPIO driver, the GPIO UCLASS driver, and the GPIO command objects would be added as follows:</p>
<pre><code class="language-c">extern struct uclass_driver _u_boot_uclass_driver__gpio;
extern struct driver        _u_boot_driver__gpio_foo;
extern struct cmd_tbl       _u_boot_cmd__gpio;
</code></pre>
<p>Each declaration is of the form <code>extern struct &lt;type&gt; _u_boot_&lt;class&gt;__&lt;name&gt;</code> to match the declaration generated by the expansion of the <code>U_BOOT_&lt;object_Type&gt;</code> macro, where:</p>
<ul>
<li><code>&lt;name&gt;</code> is the parameter provided to the macro that declared the object, e.g. a driver is declared with <code>U_BOOT_DRIVER(&lt;name&gt;)</code>;</li>
<li><code>&lt;type&gt;</code> and <code>&lt;class&gt;</code> directly correspond to the type of object. Worked examples of the correct format for each object type are provided in the Avnet MaaXBoard's <code>plat_driver_data.h</code> file. Alternatively, the format for each type of object can be determined from the expansion of the macro for that object type; e.g. for a driver, see the expansion of <code>#define U_BOOT_DRIVER</code>.</li>
</ul>
<h3 id="plat_driver_datac"><a class="header" href="#plat_driver_datac"><code>plat_driver_data.c</code></a></h3>
<p>Within the platform's <code>include/plat/&lt;platform&gt;/plat_driver_data.c</code> file, the objects declared in the <code>plat_driver_data.h</code> file need to be added to the <code>driver_data</code> global structure. A worked example covering multiple object types is provided in the Avnet MaaXBoard's <code>plat_driver_data.c</code> file.</p>
<h2 id="resolving-compilation-issues"><a class="header" href="#resolving-compilation-issues">Resolving Compilation Issues</a></h2>
<p>At this stage, compilation of the library should be attempted, e.g. through compilation of the <code>uboot-driver-example</code> test application.</p>
<p>It is expected that the set of source files referenced in the library <code>CMakeLists.txt</code> may not be complete, leading to compilation or linker errors;  whilst the source files declaring the driver, UCLASS driver and commands have been added, these may rely upon routines from source files not currently referenced.</p>
<p>For each error some judgement needs to be made:</p>
<ul>
<li>
<p>If the required routine is fundamental to correct operation of the driver (this is the normal case) then the source file should be added to the <code>CMakeLists.txt</code> section for the driver class. It must be determined by the developer whether the source file is likely to be required by all drivers of the driver class or is specific to the driver.</p>
</li>
<li>
<p>If the required routine is not required, e.g. it can be seen that it should never be called or a 'null' implementation would be sufficient, then the routine can be added to the wrapper file <code>src/wrapper/unimplemented.c</code>.</p>
</li>
<li>
<p>If an alternative implementation of the routine / source file needs to be provided, e.g. because the original implementation is incompatible with use within the context of an seL4 user-mode application, then a stub version of the source file can be added to the <code>uboot_stub</code> folder.</p>
</li>
</ul>
<h2 id="updating-sel4-application"><a class="header" href="#updating-sel4-application">Updating seL4 Application</a></h2>
<p>At this stage, the library with the newly added driver should compile cleanly.</p>
<p>What remains is to update the application utilising the library to:</p>
<ol>
<li>
<p>Ensure that seL4 permits access to the necessary devices from the platform's device tree; this is performed through the configuration of the application's CAmkES project file or Microkit's system file. For a worked example, see the  <code>uboot-driver-example.camkes</code> or <code>uboot-driver-example.system</code> file from the <code>uboot-driver-example</code> <a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example">test application</a>.</p>
</li>
<li>
<p>Provide the identity of those devices from the platform's device tree to the library; this is performed by providing the names of the devices when initialising the library through the <code>initialise_uboot_drivers</code> interface on the library's public API. Note that only those devices from the device tree listed in the call to <code>initialise_uboot_drivers</code> will be used by the library; all other devices in the device tree will be considered to be disabled.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-driver-worked-example"><a class="header" href="#library-extension---new-driver-worked-example">Library Extension - New Driver Worked Example</a></h1>
<p>A helpful way to show the process of adding a driver is to work through an example step-by-step. The I<sup>2</sup>C driver is relatively straightforward and can be readily tested on the MaaXBoard as there is a power management IC (BD71837MWV) already installed on the board's I<sup>2</sup>C bus. In this worked example, we shall not go as far as installing a driver for the BD71837MWV device itself, but we can probe the I<sup>2</sup>C bus, identify the address of the BD71837MWV device, and perform a sample memory read.</p>
<h2 id="establishing-the-driver"><a class="header" href="#establishing-the-driver">Establishing the driver</a></h2>
<p>The first place to look is the relevant source code for the driver in U-Boot. This file may be identified as follows.</p>
<p>A <code>dm tree</code> command from the U-Boot prompt<sup class="footnote-reference"><a href="#2">1</a></sup> should reveal an <code>i2c</code> entry, which uses driver <code>i2c_mxc</code>.</p>
<pre><code class="language-text"> Class     Index  Probed  Driver                Name
-----------------------------------------------------------
       ...
 i2c           0  [   ]   i2c_mxc                   |   |-- i2c@30a20000
 i2c           1  [   ]   i2c_mxc                   |   |-- i2c@30a30000
</code></pre>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p>If the MaaXBoard is powered on and autoboot is interrupted (e.g. press the <code>Enter</code> key during the countdown shown in line 37 of the output in the <a href="activity/device_drivers/../first_boot.html#boot-to-u-boot-prompt">First Boot</a> section), then the <code>dm tree</code> command may be entered at the U-Boot prompt.</p>
</div>
<p>A search for <code>i2c_mxc</code> within U-Boot's github repository <a href="https://github.com/u-boot/u-boot">https://github.com/u-boot/u-boot</a> reveals the relevant file to be <code>uboot/drivers/i2c/mxc_i2c.c</code>:</p>
<p><img src="activity/device_drivers/../figures/github_search_i2c_1.png" alt="i2c GitHub search-1" /></p>
<p><img src="activity/device_drivers/../figures/github_search_i2c_2.png" alt="i2c GitHub search-2" /></p>
<p>This file is in the equivalent location within our <code>libubootdrivers</code> library, at <code>projects_libs/libubootdrivers/uboot/drivers/i2c/mxc_i2c.c</code>.</p>
<p>In the code snippet from the screenshot above, we can see that the driver relies on the <code>UCLASS_I2C</code> uclass. This is provided by the file <code>i2c-uclass.c</code> in the same directory. At the end of <code>i2c-uclass.c</code>, we can see that driver and the other relevant drivers:</p>
<pre><code class="language-c">UCLASS_DRIVER(i2c) = {
    .id = UCLASS_I2C,
    .name = "i2c",
    ...

UCLASS_DRIVER(i2c_generic) = {
    .id = UCLASS_I2C_GENERIC,
    .name = "i2c_generic",
    ...

U_BOOT_DRIVER(i2c_generic_chip_drv) = {
    .name = "i2c_generic_chip_drv",
    .id = UCLASS_I2C_GENERIC,
    ...
</code></pre>
<p>This provides the driver references that we need to add to <code>libubootdrivers</code> via <code>projects_libs/libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code>:</p>
<pre><code class="language-c">/* Define the uclass drivers to be used on this platform */
...
extern struct uclass_driver _u_boot_uclass_driver__i2c;
extern struct uclass_driver _u_boot_uclass_driver__i2c_generic;

/* Define the drivers to be used on this platform */
...
extern struct driver _u_boot_driver__i2c_mxc;
extern struct driver _u_boot_driver__i2c_generic_chip_drv;
...
</code></pre>
<p>and <code>projects_libs/libubootdrivers/src/plat/maaxboard/plat_driver_data.c</code>:</p>
<pre><code class="language-c">void initialise_driver_data(void) {
    ...
    driver_data.uclass_driver_array[17] = _u_boot_uclass_driver__i2c;
    driver_data.uclass_driver_array[18] = _u_boot_uclass_driver__i2c_generic;
    ...
    driver_data.driver_array[19] = _u_boot_driver__i2c_mxc;
    driver_data.driver_array[20] = _u_boot_driver__i2c_generic_chip_drv;
    ...
</code></pre>
<p>We can see that the latter change has added to the arrays. In this example, the two arrays had previously extended to elements [16] and [18] respectively. The increased sizes need to be reflected back in <code>libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code> by increasing the size counts:</p>
<pre><code class="language-c">/* Define the number of different driver elements to be used on this platform */
#define _u_boot_uclass_driver_count  19  // In this example previous count was 17, so +2
#define _u_boot_driver_count         21  // In this example previous count was 19, so +2
...
</code></pre>
<p>In order to build the new driver files, we need to add them to the <code>libubootdrivers/CMakeLists.txt</code> makefile.</p>
<p>There are also some U-Boot configuration macros relevant to I<sup>2</sup>C that are needed, which are also set within the makefile. In this example, we can use the guidance in the <a href="activity/device_drivers/uboot_library_add_driver.html#updating-cmakeliststxt">Library Extension - New Driver</a> section, and refer to the <code>.config</code> file created during the <a href="activity/device_drivers/appendices/building_uboot.html">Building U-Boot for the MaaXBoard</a> appendix. Using the suggested directory name from that appendix, the filepath would be: <code>maaxboard_dockerimage/maaxboard-uboot-build/maaxboard-uboot/uboot-imx/.config</code>.</p>
<p>Extracting I2C-related items (e.g. using <code>grep -i I2C .config</code>), we would see:</p>
<pre><code class="language-text">CONFIG_SYS_I2C_MXC_I2C1=y
CONFIG_SYS_I2C_MXC_I2C2=y
CONFIG_SYS_I2C_MXC_I2C3=y
# CONFIG_SYS_I2C_MXC_I2C4 is not set
CONFIG_SPL_I2C_SUPPORT=y
CONFIG_CMD_I2C=y
# I2C support
CONFIG_DM_I2C=y
# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
# CONFIG_DM_I2C_GPIO is not set
# CONFIG_SYS_I2C_IPROC is not set
# CONFIG_SYS_I2C_FSL is not set
# CONFIG_SYS_I2C_CADENCE is not set
# CONFIG_SYS_I2C_DW is not set
# CONFIG_SYS_I2C_INTEL is not set
# CONFIG_SYS_I2C_IMX_LPI2C is not set
# CONFIG_SYS_I2C_IMX_VIRT_I2C is not set
CONFIG_SYS_I2C_MXC=y
# CONFIG_SYS_I2C_MXC_I2C5 is not set
# CONFIG_SYS_I2C_MXC_I2C6 is not set
# CONFIG_SYS_I2C_MXC_I2C7 is not set
# CONFIG_SYS_I2C_MXC_I2C8 is not set
CONFIG_SYS_MXC_I2C1_SPEED=100000
CONFIG_SYS_MXC_I2C1_SLAVE=0
CONFIG_SYS_MXC_I2C2_SPEED=100000
CONFIG_SYS_MXC_I2C2_SLAVE=0
CONFIG_SYS_MXC_I2C3_SPEED=100000
CONFIG_SYS_MXC_I2C3_SLAVE=0
# CONFIG_SYS_I2C_NEXELL is not set
# CONFIG_SYS_I2C_OCORES is not set
# CONFIG_SYS_I2C_ROCKCHIP is not set
# CONFIG_SYS_I2C_MVTWSI is not set
# CONFIG_SYS_I2C_XILINX_XIIC is not set
# CONFIG_SYS_I2C_IHS is not set
# CONFIG_I2C_MUX is not set
# CONFIG_I2C_EDID is not set
</code></pre>
<p>Removing (most of) the commented items and reordering slightly leaves:</p>
<pre><code class="language-text">CONFIG_CMD_I2C=y
CONFIG_DM_I2C=y
CONFIG_SYS_I2C_MXC=y
CONFIG_SYS_I2C_MXC_I2C1=y
CONFIG_SYS_I2C_MXC_I2C2=y
CONFIG_SYS_I2C_MXC_I2C3=y
CONFIG_SYS_MXC_I2C1_SPEED=100000
CONFIG_SYS_MXC_I2C1_SLAVE=0
CONFIG_SYS_MXC_I2C2_SPEED=100000
CONFIG_SYS_MXC_I2C2_SLAVE=0
CONFIG_SYS_MXC_I2C3_SPEED=100000
CONFIG_SYS_MXC_I2C3_SLAVE=0
# CONFIG_SYS_I2C_MXC_I2C4 is not set
CONFIG_SPL_I2C_SUPPORT=y
</code></pre>
<p>This is an excellent starting point and may well be complete; however, we may still need to apply some reasoning. For example, we do not need the final item (although it would do no harm), as SPL is only used when compiling the secondary bootloader and <code>CONFIG_SPL_I2C_SUPPORT</code> does not appear in our U-Boot code. The penultimate item concerning I2C4 (currently commented) is inaccurate and is an omission from this <code>maaxboard-uboot/uboot-imx</code> build. Examining the DTS file <code>maaxboard.dts</code> confirms that there are four I<sup>2</sup>C buses, so we will include a set of I2C4 macros. Note that, although inconsistent, it is not an issue that these macros use I2C1-I2C4 labels, whereas the DTS labels them 0-3. Our convention, such as in the following <a href="activity/device_drivers/add_driver_worked_example.html#integrating-the-driver-with-camkes">CAmkES</a> section, will be to use 0-3 labels.</p>
<p>Combining the previous paragraphs, we update the <code>libubootdrivers/CMakeLists.txt</code> makefile as follows (showing only extracts relevant to I<sup>2</sup>C).</p>
<p>The <code>i2c_driver</code> variable, which by default is <code>"none"</code>, is set to <code>"i2c_mxc"</code>:</p>
<pre><code class="language-makefile"># Set up the applicable drivers and platform dependent configuration.
if(KernelPlatImx8mq)
...
    # Define the drivers used for this platform
    ...
    set(i2c_driver "i2c_mxc")
    ...
</code></pre>
<p>Then a new section is added to handle this:</p>
<pre><code class="language-makefile">...
############################
# Settings for I2C drivers #
############################

if(i2c_driver MATCHES "none")
    # Nothing to do
else()
    # Enable I2C support
    add_definitions("-DCONFIG_DM_I2C=1")
    # Generic I2C source files
    list(APPEND uboot_deps uboot/drivers/i2c/i2c-uclass.c)

    # Driver specific settings / files
    if(i2c_driver MATCHES "i2c_mxc")
        add_definitions("-DCONFIG_SYS_I2C_MXC=1")
        add_definitions("-DCONFIG_SYS_I2C_MXC_I2C1=1")
        add_definitions("-DCONFIG_SYS_I2C_MXC_I2C2=1")
        add_definitions("-DCONFIG_SYS_I2C_MXC_I2C3=1")
        add_definitions("-DCONFIG_SYS_I2C_MXC_I2C4=1")
        add_definitions("-DCONFIG_SYS_MXC_I2C1_SPEED=100000")
        add_definitions("-DCONFIG_SYS_MXC_I2C1_SLAVE=0")
        add_definitions("-DCONFIG_SYS_MXC_I2C2_SPEED=100000")
        add_definitions("-DCONFIG_SYS_MXC_I2C2_SLAVE=0")
        add_definitions("-DCONFIG_SYS_MXC_I2C3_SPEED=100000")
        add_definitions("-DCONFIG_SYS_MXC_I2C3_SLAVE=0")
        add_definitions("-DCONFIG_SYS_MXC_I2C4_SPEED=100000")
        add_definitions("-DCONFIG_SYS_MXC_I2C4_SLAVE=0")

        list(APPEND uboot_deps uboot/drivers/i2c/mxc_i2c.c)
    else()
        message(FATAL_ERROR "Unrecognised I2C driver. Aborting.")
    endif()
endif()
</code></pre>
<p>The <code>list(APPEND uboot_deps ...)</code> lines add the driver files that were identified earlier, ensuring that they are picked out from the rest of the files held in the <code>libubootdrivers/uboot</code> directory and compiled. When they are compiled, they will require extra header files, but those will be picked up automatically from the <code>uboot</code> directory.</p>
<p>The <code>add_definitions</code> lines establish the configuration macros. Note that <code>CONFIG_CMD_I2C</code>, which was in our previous list of candidates, has been excluded, but only until we discuss it further in the forthcoming <a href="activity/device_drivers/add_driver_worked_example.html#establishing-the-driver-api">API</a> section.</p>
<p>After these changes, within our <code>build</code> directory, <code>init_build</code> followed by <code>ninja</code> should result in a clean build.</p>
<h2 id="integrating-the-driver-with-camkes"><a class="header" href="#integrating-the-driver-with-camkes">Integrating the driver with CAmkES</a></h2>
<p>We have established the underlying driver code, but it is not yet integrated within the CAmkES component that we shall be using. Assuming that we use the <code>uboot-driver-example</code> test application introduced earlier – see <a href="activity/device_drivers/uboot_driver_usage.html#instructions-for-running-the-uboot-driver-example-test">Using the U-Boot Driver Library</a> – we need to modify the file <code>camkes/apps/uboot-driver-example/include/plat/maaxboard/platform_devices.h</code> as follows.</p>
<p>Firstly, we need to add path definitions so that the devices can be located in the device tree:</p>
<pre><code class="language-c">#define REG_I2C_0_PATH      "/soc@0/bus@30800000/i2c@30a20000"
#define REG_I2C_1_PATH      "/soc@0/bus@30800000/i2c@30a30000"
#define REG_I2C_2_PATH      "/soc@0/bus@30800000/i2c@30a40000"
#define REG_I2C_3_PATH      "/soc@0/bus@30800000/i2c@30a50000"
...
#define DEV_I2C_0_PATH      REG_I2C_0_PATH
#define DEV_I2C_1_PATH      REG_I2C_1_PATH
#define DEV_I2C_2_PATH      REG_I2C_2_PATH
#define DEV_I2C_3_PATH      REG_I2C_3_PATH
</code></pre>
<p>These need to be added to <code>DEV_PATHS</code> and <code>DEV_PATH_COUNT</code> should be modified accordingly:</p>
<pre><code class="language-c">#define DEV_PATH_COUNT 19 // In this example previous size was 15 so +4

#define DEV_PATHS {   \
    ...               \
    DEV_I2C_0_PATH,   \
    DEV_I2C_1_PATH,   \
    DEV_I2C_2_PATH,   \
    DEV_I2C_3_PATH,   \
    ...
    };
</code></pre>
<p>Entries for the devices need to be added to <code>HARDWARE_INTERFACES</code>:</p>
<pre><code class="language-c">#define HARDWARE_INTERFACES  \
    ...                      \
    consumes Dummy i2c_0;    \
    consumes Dummy i2c_1;    \
    consumes Dummy i2c_2;    \
    consumes Dummy i2c_3;    \
    ...                      \
    emits Dummy dummy_source;
</code></pre>
<p>And also added to <code>HARDWARE_COMPOSITION</code>:</p>
<pre><code class="language-c">#define HARDWARE_COMPOSITION                                             \
    ...                                                                  \
    connection seL4DTBHardware i2c_0_conn(from dummy_source, to i2c_0);  \
    connection seL4DTBHardware i2c_1_conn(from dummy_source, to i2c_1);  \
    connection seL4DTBHardware i2c_2_conn(from dummy_source, to i2c_2);  \
    connection seL4DTBHardware i2c_3_conn(from dummy_source, to i2c_3);  \
    ...
</code></pre>
<p>And also added to <code>HARDWARE_CONFIGURATION</code>:</p>
<pre><code class="language-c">#define HARDWARE_CONFIGURATION                         \
    ...                                                \
    i2c_0.dtb     = dtb({ "path" : REG_I2C_0_PATH });  \
    i2c_1.dtb     = dtb({ "path" : REG_I2C_1_PATH });  \
    i2c_2.dtb     = dtb({ "path" : REG_I2C_2_PATH });  \
    i2c_3.dtb     = dtb({ "path" : REG_I2C_3_PATH });  \
    ...
</code></pre>
<h2 id="establishing-the-driver-api"><a class="header" href="#establishing-the-driver-api">Establishing the driver API</a></h2>
<p>We now need to work on the driver's API. We are going to access the driver via the U-Boot <code>i2c</code> command, such as is available at the U-Boot command line:</p>
<pre><code class="language-text">u-boot=&gt; i2c
i2c - I2C sub-system

Usage:
i2c bus [muxtype:muxaddr:muxchannel] - show I2C bus info
i2c crc32 chip address[.0, .1, .2] count - compute CRC32 checksum
i2c dev [dev] - show or set current I2C bus
i2c loop chip address[.0, .1, .2] [# of objects] - looping read of device
i2c md chip address[.0, .1, .2] [# of objects] - read from I2C device
i2c mm chip address[.0, .1, .2] - write to I2C device (auto-incrementing)
i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)
i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)
i2c probe [address] - test for and show device(s) on the I2C bus
i2c read chip address[.0, .1, .2] length memaddress - read to memory
i2c write memaddress chip address[.0, .1, .2] length [-s] - write memory
          to I2C; the -s option selects bulk write in a single transaction
i2c flags chip [flags] - set or get chip flags
i2c olen chip [offset_length] - set or get chip offset length
i2c reset - re-init the I2C Controller
i2c speed [speed] - show or set I2C bus speed
u-boot=&gt;
</code></pre>
<p>We return to <code>libubootdrivers/src/plat/maaxboard/plat_driver_data.c</code> to add a new entry to the <code>cmd_array</code>:</p>
<pre><code class="language-c">void initialise_driver_data(void) {
    ...
    driver_data.cmd_array[16] = _u_boot_cmd__i2c;
    ...
</code></pre>
<p>Corresponding changes are made in <code>libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code>:</p>
<pre><code class="language-c">/* Define the number of different driver elements to be used on this platform */
...
#define _u_boot_cmd_count  17  // In this example previous count was 16, so +1
...

/* Define the u-boot commands to be used on this platform */
...
extern struct cmd_tbl _u_boot_cmd__i2c;
...
</code></pre>
<p>We need to pull in the U-Boot source code for the <code>i2c</code> command from the file <code>i2c.c</code> (<code>projects_libs/libubootdrivers/uboot/cmd/i2c.c</code>).</p>
<p>As with the previous addition of <code>.c</code> files, this needs to be added to the <code>libubootdrivers/CMakeLists.txt</code> makefile, along with the CMD configuration macro that we identified earlier. The previous extract from the makefile is repeated below, with two additional lines marked.</p>
<pre><code class="language-makefile">    ############################
    # Settings for I2C drivers #
    ############################

    if(i2c_driver MATCHES "none")
        # Nothing to do
    else()
        # Enable I2C support
+       add_definitions("-DCONFIG_CMD_I2C=1")
        add_definitions("-DCONFIG_DM_I2C=1")
        # Generic I2C source files
+       list(APPEND uboot_deps uboot/cmd/i2c.c)
        list(APPEND uboot_deps uboot/drivers/i2c/i2c-uclass.c)

        # Driver specific settings / files
        if(i2c_driver MATCHES "i2c_mxc")
            add_definitions("-DCONFIG_SYS_I2C_MXC=1")
            add_definitions("-DCONFIG_SYS_I2C_MXC_I2C1=1")
            add_definitions("-DCONFIG_SYS_I2C_MXC_I2C2=1")
            add_definitions("-DCONFIG_SYS_I2C_MXC_I2C3=1")
            add_definitions("-DCONFIG_SYS_I2C_MXC_I2C4=1")
            add_definitions("-DCONFIG_SYS_MXC_I2C1_SPEED=100000")
            add_definitions("-DCONFIG_SYS_MXC_I2C1_SLAVE=0")
            add_definitions("-DCONFIG_SYS_MXC_I2C2_SPEED=100000")
            add_definitions("-DCONFIG_SYS_MXC_I2C2_SLAVE=0")
            add_definitions("-DCONFIG_SYS_MXC_I2C3_SPEED=100000")
            add_definitions("-DCONFIG_SYS_MXC_I2C3_SLAVE=0")
            add_definitions("-DCONFIG_SYS_MXC_I2C4_SPEED=100000")
            add_definitions("-DCONFIG_SYS_MXC_I2C4_SLAVE=0")

            list(APPEND uboot_deps uboot/drivers/i2c/mxc_i2c.c)
        else()
            message(FATAL_ERROR "Unrecognised I2C driver. Aborting.")
        endif()
    endif()
</code></pre>
<p>Within our <code>build</code> directory, after <code>init_build</code> and <code>ninja</code>, this should build successfully.</p>
<h2 id="testing-the-driver"><a class="header" href="#testing-the-driver">Testing the driver</a></h2>
<p>Now that we have the I<sup>2</sup>C driver and its API, we can call <code>i2c</code> commands from our test application. For example, the following lines can be used within a CAmkES component (in our example, these would be added to file <code>camkes/apps/uboot-driver-example/components/Test/src/test.c</code>):</p>
<pre><code class="language-c">    // I2C test
    run_uboot_command("i2c dev 0"); // Set current i2c bus to zero
    run_uboot_command("i2c probe"); // Probe i2c bus 0
</code></pre>
<p>On the MaaXBoard, the <code>i2c probe</code> command returns <code>Valid chip addresses: 4B</code>, which is the address of the BD71837MWV power management IC on the bus. Extending the test case as follows:</p>
<pre><code class="language-c">    // I2C test
    run_uboot_command("i2c dev 0"); // Set current i2c bus to zero
    run_uboot_command("i2c probe"); // Probe i2c bus 0
    run_uboot_command("i2c md 0x4b 0x0.1 0x20"); // Read 32 bytes from device at address 0x4b
    run_uboot_command("dm tree");
</code></pre>
<p>will read the first 32 bytes from the BD71837MWV, displaying:</p>
<pre><code class="language-text">0000: a3 04 03 a2 00 40 40 44 44 00 00 00 00 14 14 14    .....@@DD.......
0010: 1e 14 1e 1e 02 03 03 28 03 00 00 00 00 00 0f 48    .......(.......H
</code></pre>
<p>Before the <code>i2c probe</code>, a <code>dm tree</code> command would reveal the presence of the <code>i2c_mxc</code> driver:</p>
<pre><code class="language-text"> Class     Index  Probed  Driver                Name
-----------------------------------------------------------
       ...
 i2c           0  [   ]   i2c_mxc               |   |   |-- i2c@30a20000
 i2c           1  [   ]   i2c_mxc               |   |   |-- i2c@30a30000
 i2c           2  [   ]   i2c_mxc               |   |   |-- i2c@30a40000
 i2c           3  [   ]   i2c_mxc               |   |   |-- i2c@30a50000
</code></pre>
<p>Following the <code>i2c probe</code>, the <code>dm tree</code> command shows the instantiation of the <code>i2c_generic_chip_drv</code> driver that we ported earlier:</p>
<pre><code class="language-text"> Class     Index  Probed  Driver                Name
-----------------------------------------------------------
       ...
 i2c           0  [ + ]   i2c_mxc               |   |   |-- i2c@30a20000
 i2c_generi    0  [ + ]   i2c_generic_chip_drv  |   |   |   `-- generic_4b
 i2c           1  [   ]   i2c_mxc               |   |   |-- i2c@30a30000
 i2c           2  [   ]   i2c_mxc               |   |   |-- i2c@30a40000
 i2c           3  [   ]   i2c_mxc               |   |   |-- i2c@30a50000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odroid-c2-platform---worked-example"><a class="header" href="#odroid-c2-platform---worked-example">Odroid-C2 Platform - Worked Example</a></h1>
<p>As part of the review of the <a href="activity/device_drivers/uboot_library_add_platform.html">New Platform</a>
and <a href="activity/device_drivers/uboot_library_add_driver.html">New Driver</a> sections of this guide, we ported the
U-Boot Driver Library to build with seL4 on the Odroid-C2 platform for the CAmkES framework.</p>
<p>This document gives details of how this was achieved, following the structure
of those earlier sections, but adding details of exact changes to each file.</p>
<p>Our goal is to get the U-Boot <a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example">test application</a> running
on the Odroid-C2.</p>
<h2 id="repository-setup-and-forks"><a class="header" href="#repository-setup-and-forks">Repository setup and forks</a></h2>
<p>To work on a new platform build, we need to modify some of the existing repositories.
To do that, we need to "fork" those repositores and do the work in our own local
branches until it's all working. Finally, we would need to open a "Pull Request"
to merge our changes back into the "upstream" repositories.</p>
<p>Additionally, we need to tell the <code>repo</code> tool that we want to build from our
own forked repositories (so that the <code>repo sync</code> step gets the sources from
our forks, not from the upstream repositories).</p>
<p>You'll need to your own GitHub account to do this. From here on, we'll be using the
GitHub account name <code>rod-chapman</code> for our local forks.</p>
<ol>
<li>
<p>Using the GitHub web GUI, create your own forks of the <code>camkes-manifest</code>, <code>camkes</code>,
and <code>projects_libs</code> repositories.</p>
</li>
<li>
<p>Clone the <code>camkes-manifest</code> fork into your local machine, and create
a new branch called <code>addc2</code> to make our changes. In the following commands, remember to change <code>rod-chapman</code> to your own GitHub user name:</p>
<pre><code class="language-text">git clone https://github.com/rod-chapman/camkes-manifest.git
cd camkes-manifest
git checkout -b addc2
git push --set-upstream origin addc2
cd ..
</code></pre>
</li>
<li>
<p>Similarly, clone the <code>camkes</code> and <code>projects_libs</code> forks, and add a new branch
to each with the same name.</p>
<pre><code class="language-text">git clone https://github.com/rod-chapman/camkes.git
cd camkes
git checkout -b addc2
git push --set-upstream origin addc2
cd ..
</code></pre>
<pre><code class="language-text">git clone https://github.com/rod-chapman/projects_libs.git
cd projects_libs
git checkout -b addc2
git push --set-upstream origin addc2
cd ..
</code></pre>
</li>
<li>
<p>Edit the <code>default.xml</code> file in the <code>camkes-manifest</code> repository to add a new remote (in our
case called <code>rod</code>) pointing at our own GitHub account.</p>
<p>For example, the line to add is</p>
<pre><code class="language-text">&lt;remote name="rod" fetch="https://github.com/rod-chapman"/&gt;
</code></pre>
</li>
<li>
<p>Similarly, edit the <code>default.xml</code> file to specify that the <code>camkes</code> and <code>projects_libs</code> repositories
should come from the <code>addc2</code> branches of our own forked repositories. Find the <code>project</code> line for each
repository and modify its entry to specify our own remote (<code>rod</code>) and branch (<code>addc2</code>).</p>
<p>For example, the <code>project</code> lines for our forks are:</p>
<pre><code class="language-text">&lt;project name="camkes.git" path="projects/camkes" remote="rod" revision="addc2" upstream="addc2" dest-branch="addc2"&gt;
  &lt;linkfile src="easy-settings.cmake" dest="easy-settings.cmake"/&gt;
&lt;/project&gt;
&lt;project name="projects_libs.git" path="projects/projects_libs" remote="rod" revision="addc2" upstream="addc2" dest-branch="addc2"/&gt;
</code></pre>
</li>
<li>
<p>Commit and push that change:</p>
<pre><code class="language-text">cd camkes-manifest
git add default.xml
git commit -m "Add remote and forked repositories for adding Odroid-C2 platform."
git push
cd ..
</code></pre>
</li>
</ol>
<h2 id="test-application-build-for-the-maaxboard"><a class="header" href="#test-application-build-for-the-maaxboard">Test Application Build for the MaaxBoard</a></h2>
<p>Having made no other changes at this point, we should be able to build and run
the U-Boot Driver Example program for the MaaxBoard from those newly forked
repositories, just to make sure that creating the forks hasn't broken anything.</p>
<p>The earlier instructions in the <a href="activity/device_drivers/../uboot_library_add_platform.html">New Platform</a>
section should be followed with one significant change: the first <code>repo init</code> command
specifies our fork and branch of the <code>camkes-manifest</code> repository.</p>
<p>For example:</p>
<pre><code class="language-text">repo init -u https://github.com/rod-chapman/camkes-manifest.git -b addc2
</code></pre>
<p>Assuming that works, then we can start to make modifications to support the Odroid-C2.</p>
<h2 id="root-directory-platform-name-and-basic-platform-details"><a class="header" href="#root-directory-platform-name-and-basic-platform-details">Root Directory, Platform Name, and basic Platform Details</a></h2>
<p>To build the test application, we need to create a new root directory
to hold a <code>repo</code> structure and perform the build.</p>
<p>The root directory name is <code>c2new</code>. From here on, all directory names given in this section
are relative to that new root directory.</p>
<p>We also know that the Odroid-C2 is already supported by seL4. Its device tree
appears in <code>kernel/tools/dts/odroidc2.dts</code>.</p>
<p>The seL4 "platform name" is <code>odroidc2</code>.</p>
<p>The system-on-chip device at the heart of the C2 is Amlogic S905, also known as
a "meson" SoC.</p>
<p>We create that root directory, and initialise our build environment. Remember to use the
Docker container from the <a href="activity/device_drivers/../build_environment_setup.html#usage">build environment setup</a> section
from here on:</p>
<pre><code class="language-text"># In the docker container with working directory at /host
mkdir c2new
cd c2new
repo init -u https://github.com/rod-chapman/camkes-manifest.git -b addc2
repo sync
</code></pre>
<p>At this point, we return to the structure of the <a href="activity/device_drivers/../uboot_library_add_platform.html">New Platform</a>
section.</p>
<h2 id="update-the-librarys-cmake-file-to-support-the-platform-1"><a class="header" href="#update-the-librarys-cmake-file-to-support-the-platform-1">Update the library's CMake file to support the platform</a></h2>
<p>We need to update the file <code>projects/projects_libs/libubootdrivers/CMakeLists.txt</code> to
include bare-minimum support for our new platform.</p>
<p>From the seL4 documentation we can find that the value of the <code>${KernelPlatform}</code>
variable is <code>odroidc2</code>. We also need to locate the correct C header files for this
platform and create a sym-link to them, so we add:</p>
<pre><code class="language-makefile">+ elseif("${KernelPlatform}" STREQUAL "odroidc2")
+     # Define the drivers used for this platform
+     set(arch_source "./arch-meson")
+     set(arch_target "../projects/uboot/arch/arm/include/asm/arch")
+     execute_process(COMMAND ln -fsn ${arch_source} ${arch_target})
</code></pre>
<p>in the "Platform specific settings" section of the file.</p>
<h2 id="adding-the-gpio-driver"><a class="header" href="#adding-the-gpio-driver">Adding the GPIO Driver</a></h2>
<p>At this point, we decided to add support for the U-Boot "General Purpose IO" device
driver, also known as "GPIO".</p>
<p>We start by searching the Odroid-C2 device tree file for the string "gpio-controller" in
the file <code>kernel/tools/dts/odroidc2.dts</code>.</p>
<p>This appears in two places in the Device Tree, with path-names <code>/soc/bus@c8100000/pinctrl@14/bank@14</code>
and <code>/soc/periphs@c8834000/pinctrl@4b0/bank@4b0</code>.</p>
<p>From those nodes of the tree we search "up" the tree (towards the "soc" root node) for a
"compatible" string. We find</p>
<pre><code class="language-text">compatible = "amlogic,meson-gxbb-aobus-pinctrl";
</code></pre>
<p>for the former entry, and</p>
<pre><code class="language-text">compatible = "amlogic,meson-gxbb-periphs-pinctrl";
</code></pre>
<p>for the latter.</p>
<h2 id="finding-the-driver-source-code"><a class="header" href="#finding-the-driver-source-code">Finding the driver source code</a></h2>
<p>Those "compatible" strings give us the key to finding the correct source file from the U-Boot sources
that we need to support the C2's GPIO device(s).</p>
<p>We can search the sources for all the U-Boot drivers for either of those strings with:</p>
<pre><code class="language-text">cd projects/uboot/drivers
grep -r "meson-gxbb-.*-pinctrl" .
</code></pre>
<p>which yields a result:</p>
<pre><code class="language-text">./pinctrl/meson/pinctrl-meson-gxbb.c:           .compatible = "amlogic,meson-gxbb-periphs-pinctrl",
./pinctrl/meson/pinctrl-meson-gxbb.c:           .compatible = "amlogic,meson-gxbb-aobus-pinctrl",
</code></pre>
<p>showing us that the single source file <code>pinctrl-meson-gxbb.c</code> implements a
driver that is compatible with both of the devices we're interested in.</p>
<p>At the bottom of that source file, we find the declarations:</p>
<pre><code class="language-c">static const struct udevice_id meson_gxbb_pinctrl_match[] = {
        {
                .compatible = "amlogic,meson-gxbb-periphs-pinctrl",
                .data = (ulong)&amp;meson_gxbb_periphs_pinctrl_data,
        },
        {
                .compatible = "amlogic,meson-gxbb-aobus-pinctrl",
                .data = (ulong)&amp;meson_gxbb_aobus_pinctrl_data,
        },
        { /* sentinel */ }
};

U_BOOT_DRIVER(meson_gxbb_pinctrl) = {
        .name = "meson-gxbb-pinctrl",
        .id = UCLASS_PINCTRL,
        .of_match = of_match_ptr(meson_gxbb_pinctrl_match),
        .probe = meson_pinctrl_probe,
        .priv_auto      = sizeof(struct meson_pinctrl),
        .ops = &amp;meson_gx_pinctrl_ops,
};
</code></pre>
<p>so we know the driver is called "meson-gxbb-pinctrl" and it is compatible with both
the "aobus" and "periphs" instances of that device on the C2.</p>
<h2 id="adding-a-source-dependency-for-the-gpio-driver"><a class="header" href="#adding-a-source-dependency-for-the-gpio-driver">Adding a source dependency for the GPIO driver</a></h2>
<p>Having identified which source file we need to build, we can add it to the CMake file.</p>
<p>Firstly, we set the variable "iomux_driver" to the value we just found - "meson-gxbb-pinctrl" -
by adding</p>
<pre><code class="language-makefile">     elseif("${KernelPlatform}" STREQUAL "odroidc2")
         # Define the drivers used for this platform
+        set(iomux_driver "meson-gxbb-pinctrl")
         ...
</code></pre>
<p>in the "Platform Specific Settings" section of the <code>CMakeLists.txt</code> file as above.</p>
<p>In the same file, we then go to the "Settings for IOMUX Drivers" section and add
an <code>elseif</code> branch to add the required source code dependencies when that driver is selected:</p>
<pre><code class="language-makefile">    elseif(iomux_driver MATCHES "meson-gxbb-pinctrl")
        list(APPEND uboot_deps uboot/drivers/pinctrl/meson/pinctrl-meson-gxbb.c)
</code></pre>
<h2 id="resolving-compilation-issues-1"><a class="header" href="#resolving-compilation-issues-1">Resolving Compilation Issues</a></h2>
<p>An attempt to compile the U-Boot Driver Test application fails owing to missing sources, where
our new driver code depends on some other code that we have not included yet.</p>
<p>Identification of the missing units (and further searching of the U-Boot driver sources) shows that
we additionally need the <code>pinctrl-meson.c</code> and <code>pinctrl-meson-gx-pmx.c</code> source files to be included, so
we update <code>CMakeLists.txt</code> to include them:</p>
<pre><code class="language-makefile">    elseif(iomux_driver MATCHES "meson-gxbb-pinctrl")
        list(APPEND uboot_deps uboot/drivers/pinctrl/meson/pinctrl-meson-gxbb.c)
        list(APPEND uboot_deps uboot/drivers/pinctrl/meson/pinctrl-meson.c)
        list(APPEND uboot_deps uboot/drivers/pinctrl/meson/pinctrl-meson-gx-pmx.c)
</code></pre>
<h2 id="platform-specific-linker-lists"><a class="header" href="#platform-specific-linker-lists">Platform Specific Linker Lists</a></h2>
<p>Next, we need to add the "Linker Lists" data structures for this platform
and for the set of device drivers that we want to support.</p>
<p>First, we create two new directories in our fork of the projects_libs repository:</p>
<pre><code class="language-text">projects_libs/libubootdrivers/include/plat/odroidc2
</code></pre>
<p>and</p>
<pre><code class="language-text">projects_libs/libubootdrivers/src/plat/odroidc2
</code></pre>
<p>Following the templates from the <a href="activity/device_drivers/uboot_library_add_platform.html">New Platform</a> section,
we create <code>plat_driver_data.h</code> in the former of those directories.</p>
<p>There are five UClass Drivers that are effectively mandatory (<code>nop</code>, <code>root</code>, <code>simple_bus</code>, <code>phy</code> and <code>blk</code>),
and we want to add two more (<code>pinconfig</code> and <code>pinctrl</code>), making a total of 7, so we declare in
<code>plat_driver_data.h</code>:</p>
<pre><code class="language-c">#define _u_boot_uclass_driver_count     7

/* Define the uclass drivers to be used on this platform */
extern struct uclass_driver _u_boot_uclass_driver__nop;
extern struct uclass_driver _u_boot_uclass_driver__root;
extern struct uclass_driver _u_boot_uclass_driver__simple_bus;
extern struct uclass_driver _u_boot_uclass_driver__phy;
extern struct uclass_driver _u_boot_uclass_driver__blk;
extern struct uclass_driver _u_boot_uclass_driver__pinconfig;
extern struct uclass_driver _u_boot_uclass_driver__pinctrl;
</code></pre>
<p>We require a total of 4 drivers, so:</p>
<pre><code class="language-c">#define _u_boot_driver_count            4

/* Define the drivers to be used on this platform */
extern struct driver _u_boot_driver__root_driver;
extern struct driver _u_boot_driver__simple_bus;
extern struct driver _u_boot_driver__pinconfig_generic;
extern struct driver _u_boot_driver__meson_gxbb_pinctrl;
</code></pre>
<p>and 4 commands:</p>
<pre><code class="language-c">#define _u_boot_cmd_count               4

/* Define the u-boot commands to be used on this platform */
extern struct cmd_tbl _u_boot_cmd__dm;
extern struct cmd_tbl _u_boot_cmd__env;
extern struct cmd_tbl _u_boot_cmd__setenv;
extern struct cmd_tbl _u_boot_cmd__pinmux;
</code></pre>
<p>We can now create <code>plat_driver_data.c</code> in the <code>src/plat/odroidc2</code> directory to initialise
the actual data structures thus:</p>
<pre><code class="language-c">void initialise_driver_data(void) {
    driver_data.uclass_driver_array[0]  = _u_boot_uclass_driver__nop;
    driver_data.uclass_driver_array[1]  = _u_boot_uclass_driver__root;
    driver_data.uclass_driver_array[2]  = _u_boot_uclass_driver__simple_bus;
    driver_data.uclass_driver_array[3]  = _u_boot_uclass_driver__phy;
    driver_data.uclass_driver_array[4]  = _u_boot_uclass_driver__blk;
    driver_data.uclass_driver_array[5]  = _u_boot_uclass_driver__pinconfig;
    driver_data.uclass_driver_array[6]  = _u_boot_uclass_driver__pinctrl;

    driver_data.driver_array[0]  = _u_boot_driver__root_driver;
    driver_data.driver_array[1]  = _u_boot_driver__simple_bus;
    driver_data.driver_array[2]  = _u_boot_driver__pinconfig_generic;
    driver_data.driver_array[3]  = _u_boot_driver__meson_gxbb_pinctrl;

    driver_data.cmd_array[0]  = _u_boot_cmd__dm;
    driver_data.cmd_array[1]  = _u_boot_cmd__env;
    driver_data.cmd_array[2]  = _u_boot_cmd__setenv;
    driver_data.cmd_array[3]  = _u_boot_cmd__pinmux;
}
</code></pre>
<p>Note how the number of assignments and array elements initialised must exactly match
the values of the constants defined in the <code>plat_driver_data.h</code> file.</p>
<h2 id="add-odroid-c2-support-in-the-u-boot-driver-example-test-program"><a class="header" href="#add-odroid-c2-support-in-the-u-boot-driver-example-test-program">Add Odroid-C2 support in the U-Boot Driver Example test program</a></h2>
<p>We now need to modify the CAmkES configuration of our test program to tell CAmkES that our program is
configured for this platform and our code can have capabilities allocation to access certain devices.</p>
<p>This is done by creating a specific <code>platform_devices.h</code> file for the Odroid-C2 in the example application.</p>
<p>We create <code>camkes/apps/uboot-driver-example/include/plat/odroidc2/platform_devices.h</code> with the following
content:</p>
<pre><code class="language-c">#pragma once

/* List the set of device tree paths that include the 'reg' entries
 * for memory regions that will need to be mapped */
#define BUS_PATH     "/soc/bus@c8100000"
#define PERIPHS_PATH "/soc/periphs@c8834000"
#define REG_PATHS { BUS_PATH, PERIPHS_PATH };
#define REG_PATH_COUNT 2

/* List the set of device tree paths for the devices we wish to access.
 * Note these need to be the root nodes of each device to be accessed */
#define PINCTRL1_PATH "/soc/bus@c8100000/pinctrl@14"
#define PINCTRL2_PATH "/soc/periphs@c8834000/pinctrl@4b0"
#define DEV_PATHS { PINCTRL1_PATH, PINCTRL2_PATH };
#define DEV_PATH_COUNT 2

/* Provide the hardware settings for CAmkES. Note that we only need to inform
 * CAmkES of the devices with memory mapped regions, i.e. the REG_xxx
 * devices. See https://docs.sel4.systems/projects/camkes for syntax */

#define HARDWARE_INTERFACES                                                   \
    consumes Dummy bus;                                                       \
    consumes Dummy periphs;                                                   \
    emits Dummy dummy_source;

#define HARDWARE_COMPOSITION                                                \
    connection seL4DTBHardware bus_conn(from dummy_source, to bus);         \
    connection seL4DTBHardware periphs_conn(from dummy_source, to periphs);

#define HARDWARE_CONFIGURATION                                              \
    bus.dtb     = dtb({ "path" : BUS_PATH });                               \
    periphs.dtb = dtb({ "path" : PERIPHS_PATH });                           \
</code></pre>
<p>Refer to the <a href="https://docs.sel4.systems/Tutorials/hello-camkes-0.html">CAmkES tutorial</a>
and <a href="https://docs.sel4.systems/projects/camkes/">documentation</a> for the exact syntax
and semantics of these declarations.</p>
<p>We also need to update the main test program to enable the specific tests that we want to run
on the Odroid-C2. The source file is in <code>projects/camkes/apps/uboot-driver-example/components/Test/src/test.c</code>.</p>
<p>Each specific test for device <code>XXX</code> is only run if a C preprocessor symbol <code>TEST_XXX</code> is defined. A set of these are defined by testing each appropriate <code>CONFIG_PLAT_YYY</code> symbol that might be defined by CMake. <code>test.c</code> already defines a set of tests are are appropriate for the MaaxBoard, so we need to add a set for the Odroid-C2. At this point, only the <code>pinmux</code> command is implemented, so we add:</p>
<pre><code class="language-text">  /* Determine which functionality to test based upon the platform */
  #if defined(CONFIG_PLAT_MAAXBOARD)
      ...
+ #elif defined(CONFIG_PLAT_ODROIDC2)
+     #define TEST_PINMUX
  #else
      ...
  #endif
</code></pre>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>At this point, the U-Boot Driver Example test program should build for the C2.</p>
<p>Make sure all your changes are committed and pushed to GitHub, then (in the Docker container):</p>
<pre><code class="language-text">cd /host/c2new
repo sync
mkdir build
cd build
../init-build.sh -DCAMKES_APP=uboot-driver-example -DPLATFORM=odroidc2 -DSIMULATION=FALSE
ninja
</code></pre>
<p>This should result in a binary image in the <code>images</code> subdirectory that can be copied to a
USB memory stick or a TFTP server of your choice. As before, we assume that the image is renamed
to <code>sel4_image</code> if that is the default set up in your U-Boot configuration.</p>
<h2 id="running-the-test-application"><a class="header" href="#running-the-test-application">Running the test application</a></h2>
<p>In our case, we download using TFTP, so we start the TFTP Server Application as before, start CoolTerm,
reboot the Odroid-C2, and hit <code>Return</code> immediately to interrupt whatever default boot
sequence is installed.  Then we set the <code>ipaddr</code> and <code>serverip</code> environment variables in
U-Boot, and use the <code>tftpboot sel4_image</code> command to download the image.</p>
<p>On our system, our ethernet subnet is <code>192.168.2.x</code> and the image is built to
run with a start address of <code>0x20000000</code>, so the entire
sequence of commands to setup, download and start the test program is:</p>
<pre><code class="language-text">odroidc2# setenv ipaddr 192.168.2.2
odroidc2# setenv serverip 192.168.2.1
odroidc2# tftpboot sel4_image
odroidc2# go 0x20000000
</code></pre>
<h2 id="test-results"><a class="header" href="#test-results">Test results</a></h2>
<p>Most of the commands that are expected to work on the MaaxBoard
will fail on the Odroid-C2 owing to missing drivers, but the <code>dm tree</code> command
should work and show the <code>pinctrl</code> devices that we have added. The output that we see,
truncated to only show the first 4 levels of the device tree, is as follows:</p>
<pre><code class="language-text">Starting U-Boot driver example
run_uboot_command@uboot_wrapper.c:176 --- running command 'dm tree' ---
 Class     Index  Probed  Driver                Name
-----------------------------------------------------------
 root          0  [ + ]   root_driver           root_driver
 simple_bus    0  [   ]   simple_bus            `-- soc
 simple_bus    1  [   ]   simple_bus                |-- bus@c8100000
 pinctrl       0  [   ]   meson-gxbb-pinctrl        |   `-- pinctrl@14
 pinconfig     0  [   ]   pinconfig                 |       |-- uart_ao_a
 pinconfig     1  [   ]   pinconfig                 |       |   `-- mux
 pinconfig     2  [   ]   pinconfig                 |       |-- # and many more - truncated here
 pinconfig     3  [   ]   pinconfig                 |       |   `-- mux
 simple_bus    2  [   ]   simple_bus                `-- periphs@c8834000
 pinctrl       1  [   ]   meson-gxbb-pinctrl            `-- pinctrl@4b0
 pinconfig    40  [   ]   pinconfig                         |-- emmc
 pinconfig    41  [   ]   pinconfig                         |   `-- mux
 pinconfig    42  [   ]   pinconfig                         |-- # and many more - truncated here
 pinconfig    43  [   ]   pinconfig                         |   `-- mux
run_uboot_command@uboot_wrapper.c:181 --- command 'dm tree' completed with return code 0 ---
Completed U-Boot driver example
</code></pre>
<h2 id="adding-support-for-the-led-and-gpio-commands"><a class="header" href="#adding-support-for-the-led-and-gpio-commands">Adding support for the LED and GPIO commands</a></h2>
<p>At this point, we can go further and add support for the U-Boot <code>led</code> and <code>gpio</code> commands.</p>
<p>The LEDs are driven by the lower-level GPIO <code>pinctrl</code> and <code>pinmux</code> subsystems, so we look in the Odroid-C2's device tree for the tell-tale "compatible" string for the appropriate driver. We find:</p>
<pre><code class="language-text">leds {
    compatible = "gpio-leds";
    blue {
        label = "c2:blue:alive";
        gpios = &lt; 0x2e 0x0d 0x01 &gt;;
        linux,default-trigger = "heartbeat";
        default-state = "off";
    };
};
</code></pre>
<p>This tells is to look for the declaration of a <code>gpio-leds</code> driver in the U-Boot sources. Indeed, in <code>uboot/drivers/led/led_gpio.c</code>, we find:</p>
<pre><code class="language-c">U_BOOT_DRIVER(led_gpio) = {
        .name   = "gpio_led",
        .id     = UCLASS_LED,
        .ops    = &amp;gpio_led_ops,
        .priv_auto      = sizeof(struct led_gpio_priv),
        .probe  = led_gpio_probe,
        .remove = led_gpio_remove,
};

static const struct udevice_id led_gpio_ids[] = {
        { .compatible = "gpio-leds" },
        { }
};

U_BOOT_DRIVER(led_gpio_wrap) = {
        .name   = "gpio_led_wrap",
        .id     = UCLASS_NOP,
        .of_match = led_gpio_ids,
        .bind   = led_gpio_bind,
};
</code></pre>
<p>showing that we need to add the <code>led_gpio</code> and <code>led_gpio_wrap</code> drivers to our build.</p>
<p>In addition, we need to add the general GPIO driver which, for this platform, is called <code>meson_gx_gpio_driver</code>.</p>
<p>In summary, we need to:</p>
<ul>
<li>add 2 more UClass Drivers, 3 more Drivers, and 2 more U-Boot commands to the library configuration in <code>plat_driver_data.h</code>:</li>
</ul>
<pre><code class="language-text">#define _u_boot_uclass_driver_count     9 // was 7 previously
#define _u_boot_driver_count            7 // was 4 previously
#define _u_boot_cmd_count               6 // was 4 previously

  extern struct uclass_driver _u_boot_uclass_driver__pinconfig;
  extern struct uclass_driver _u_boot_uclass_driver__pinctrl;
+ extern struct uclass_driver _u_boot_uclass_driver__gpio;
+ extern struct uclass_driver _u_boot_uclass_driver__led;

  extern struct driver _u_boot_driver__pinconfig_generic;
  extern struct driver _u_boot_driver__meson_gxbb_pinctrl;
+ extern struct driver _u_boot_driver__meson_gx_gpio_driver;
+ extern struct driver _u_boot_driver__led_gpio_wrap;
+ extern struct driver _u_boot_driver__led_gpio;

  extern struct cmd_tbl _u_boot_cmd__pinmux;
+ extern struct cmd_tbl _u_boot_cmd__gpio;
+ extern struct cmd_tbl _u_boot_cmd__led;
</code></pre>
<ul>
<li>initialise these structures properly in <code>plat_driver_data.c</code>, adding:</li>
</ul>
<pre><code class="language-text">  driver_data.uclass_driver_array[5]  = _u_boot_uclass_driver__pinconfig;
  driver_data.uclass_driver_array[6]  = _u_boot_uclass_driver__pinctrl;
+ driver_data.uclass_driver_array[7]  = _u_boot_uclass_driver__gpio;
+ driver_data.uclass_driver_array[8]  = _u_boot_uclass_driver__led;

  driver_data.driver_array[2]  = _u_boot_driver__pinconfig_generic;
  driver_data.driver_array[3]  = _u_boot_driver__meson_gxbb_pinctrl;
+ driver_data.driver_array[4]  = _u_boot_driver__meson_gx_gpio_driver;
+ driver_data.driver_array[5]  = _u_boot_driver__led_gpio_wrap;
+ driver_data.driver_array[6]  = _u_boot_driver__led_gpio;

  driver_data.cmd_array[3]  = _u_boot_cmd__pinmux;
+ driver_data.cmd_array[4]  = _u_boot_cmd__gpio;
+ driver_data.cmd_array[5]  = _u_boot_cmd__led;
</code></pre>
<ul>
<li>modify <code>CMakeLists.txt</code> to enable those drivers and sources in the CMake build process:</li>
</ul>
<pre><code class="language-makefile">     elseif("${KernelPlatform}" STREQUAL "odroidc2")
         # Define the drivers used for this platform
         set(iomux_driver "meson-gxbb-pinctrl")
+        set(gpio_driver "meson_gx_gpio_driver")
+        set(led_driver "gpio_led")
         ...
</code></pre>
<p>Next, we declare the <code>/leds</code> device tree path in the configuration of the U-Boot Driver Example program in <code>camkes/apps/uboot-driver-example/include/plat/odroidc2/platform_devices.h</code> and add that to the list of <code>DEV_PATHS</code> that are required by our test application:</p>
<pre><code class="language-text">#define LEDS_PATH "/leds"
#define DEV_PATHS { PINCTRL1_PATH, PINCTRL2_PATH, LEDS_PATH };
#define DEV_PATH_COUNT 3
</code></pre>
<p>Finally, the main test program <code>test.c</code> is modified to run tests for the <code>gpio</code> and <code>led</code> commands</p>
<pre><code class="language-text">  #elif defined(CONFIG_PLAT_ODROIDC2)
      #define TEST_PINMUX
+     #define TEST_GPIO
+     #define TEST_LED
+     #define TEST_LED_NAME_1 "c2:blue:alive"
+     #define TEST_LED_NAME_2 "c2:blue:alive"
</code></pre>
<p>If we run the test program, we first notice the tail of the output of the <code>dm tree</code> command now includes:</p>
<pre><code class="language-text"> gpio          1  [ + ]   meson-gx-gpio         |           `-- meson-gpio
 nop           0  [ + ]   gpio_led_wrap         `-- leds
 led           0  [ + ]   gpio_led                  `-- blue
</code></pre>
<p>Secondly the <code>led list</code> command produces:</p>
<pre><code class="language-text">c2:blue:alive   off
</code></pre>
<p>The <code>pinmux status -a</code> command also works, and lists the current assignment of the general GPIO pins to their current specific function.</p>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>This section has given a detailed walkthrough of how the U-Boot driver framework and test application
have been built and run under seL4 on the Odroid-C2. We've also shown how the basic GPIO "pinctrl"
driver from U-Boot can be added to our configuration for that platform and how the
U-Boot <code>dm tree</code> command works and shows the presence of that device. We then went on to add support for the <code>pinmux</code> and <code>led</code> commands and demonstrated their use in a simple test application.</p>
<p><img src="activity/device_drivers/../figures/odroidc2_boots.png" alt="C2_Boots" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---troubleshooting"><a class="header" href="#library-extension---troubleshooting">Library Extension - Troubleshooting</a></h1>
<p>This section attempts to provide guidance to help resolve issues that may be encountered when adding new device drivers to the library.</p>
<h2 id="increase-logging"><a class="header" href="#increase-logging">Increase logging</a></h2>
<p>Whenever an issue is encountered, one of the simplest actions that can be taken to provide additional data is to increase the verbosity of the library's output.</p>
<p>The library's logging level is controlled by the <code>LIB_UBOOT_LOGGING_LEVEL</code> variable in the library <code>CMakeLists.txt</code> file:</p>
<pre><code class="language-makefile">set(LIB_UBOOT_LOGGING_LEVEL "ZF_LOG_INFO")
</code></pre>
<p>This can be increased by changing the default <code>ZF_LOG_INFO</code> level to a higher logging level, e.g. <code>ZF_LOG_DEBUG</code> or <code>ZF_LOG_VERBOSE</code>.</p>
<h2 id="dma-1"><a class="header" href="#dma-1">DMA</a></h2>
<p>As documented in the <a href="activity/device_drivers/uboot_driver_library.html#dma">library overview</a> section, drivers utilising DMA may need manual modifications.</p>
<h3 id="detecting-dma-usage"><a class="header" href="#detecting-dma-usage">Detecting DMA usage</a></h3>
<p>When adding support for a new device and associated driver, it should be determined whether the driver utilises DMA.</p>
<p>The single most reliable method for determining DMA usage is to read and understand the device reference manual; however, there are a number of strong indicators from the U-Boot source code that can assist, such as:</p>
<ol>
<li>
<p>Search the driver source code for references to <code>DMA</code>.</p>
</li>
<li>
<p>Allocation of aligned memory (i.e. usage of <code>memalign</code>). Memory allocated with the intent of being used for DMA transfers tends to be aligned on cache line boundaries. Examples of U-Boot source code allocating memory for DMA are <code>ptr = memalign(cachline_size, ...)</code> and <code>tmp = memalign(ARCH_DMA_MINALIGN, ...)</code>.</p>
</li>
<li>
<p>Data cache flushing or invalidation (i.e. usage of <code>flush_dcache_range</code> and <code>invalidate_dcache_range</code>). Such manipulation of the data cache is a strong indicator that the associated memory is utilised for communication with a device.</p>
</li>
</ol>
<h3 id="resolving-dma-issues"><a class="header" href="#resolving-dma-issues">Resolving DMA issues</a></h3>
<p>Once it has been determined that an area of memory is being used by the driver for DMA purposes, it must be converted to use an seL4 DMA region.</p>
<p>Where the memory is managed through standard <code>malloc</code>, <code>memalign</code>, and <code>free</code>, these must be converted to the directly equivalent routines <code>sel4_dma_malloc</code>, <code>sel4_dma_memalign</code>, and <code>sel4_dma_free</code> provided by the library wrapper. Note that no changes are required to usage of <code>flush_dcache_range</code> and <code>invalidate_dcache_range</code>; these routines are automatically mapped to the seL4 DMA equivalents by the library wrapper.</p>
<p>In cases where the existing memory allocation cannot be easily modified, e.g. the memory was allocated by a variable declaration on the stack or is only used for DMA in limited cases, then an alternative approach can be taken. Prior to communicating the DMA address to the device (usually performed via memory-mapped IO) a DMA region can be allocated to mirror the original memory and the data manually copied between them as required.</p>
<p>If a driver performs conversions between the DMA region's virtual and physical addresses, such conversions must be replaced with usage of the <code>sel4_dma_virt_to_phys</code> and <code>sel4_dma_phys_to_virt</code> routines provided by the library wrapper.</p>
<h3 id="worked-examples"><a class="header" href="#worked-examples">Worked Examples</a></h3>
<p>All of the above techniques have been used in the modifications made to the Ethernet driver file <code>drivers/net/fec_mxc.c</code> in <a href="https://github.com/sel4devkit/u-boot/commit/6a4512f1d3b8427a4e192a14c52319a6228c7bbe">this Git commit</a>:</p>
<ul>
<li>Within routine <code>fec_alloc_descs</code>, calls to <code>memalign</code> have been replaced with <code>sel4_dma_memalign</code>.</li>
<li>Within routine <code>fec_free_descs</code>, the corresponding calls to <code>free</code> have been replaced with <code>sel4_dma_free</code>.</li>
<li>Within routine <code>fecmxc_send</code>, an seL4 DMA region is allocated to mirror the contents of the provided packet (and subsequently freed in <code>fecmxc_free_pkt</code>).</li>
<li>Address translations using <code>sel4_dma_virt_to_phys</code> and <code>sel4_dma_phys_to_virt</code> are performed around use of the <code>.data_pointer</code> pointers into the receive buffers (which are communicated with the device) to ensure that the device is only sent the physical address of the DMA region.</li>
</ul>
<h2 id="live-device-tree-support"><a class="header" href="#live-device-tree-support">Live Device Tree support</a></h2>
<p>As documented in the <a href="activity/device_drivers/../uboot_driver_library.html#library-limitations">library overview</a> section, the library only supports drivers that are compatible with U-Boot's live tree format for holding the device tree.</p>
<p>Guidance on porting an old driver to the live device tree interface is provided <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html#porting-drivers">here</a>.</p>
<p>A worked example of porting can be seen in the Pin Multiplexing driver file <code>drivers/pinctrl/nxp/pinctrl-imx.c</code> in <a href="https://github.com/sel4devkit/u-boot/commit/6a4512f1d3b8427a4e192a14c52319a6228c7bbe">this Git commit</a>.</p>
<h2 id="missing-initialisation"><a class="header" href="#missing-initialisation">Missing Initialisation</a></h2>
<p>When a new device class has been added to the library, it may be necessary to perform explicit initialisation of the associated U-Boot subsystems. Currently this has only been required for the Ethernet and MMC device classes as shown below in the extract from <code>uboot_wrapper.c</code>:</p>
<pre><code class="language-c">int initialise_uboot_wrapper(char* fdt_blob)
{
    ...

#ifdef CONFIG_DM_MMC
    // Initialize the MMC system.
    ret = mmc_initialize(NULL);
    if (0 != ret)
        goto error;
#endif

#ifdef CONFIG_NET
    // Initialize the ethernet system.
    puts("Net:   ");
    eth_initialize();
#ifdef CONFIG_RESET_PHY_R
    debug("Reset Ethernet PHY\n");
    reset_phy();
#endif
#endif

    ...
}
</code></pre>
<p>Whether initialisation is required, and the required initialisation, can be determined by referencing U-Boot's own initialisation code held in U-Boot source file <code>common/board_r.c</code>.</p>
<h2 id="environment-variables-not-working"><a class="header" href="#environment-variables-not-working">Environment Variables Not Working</a></h2>
<p>Setting or changing certain environment variables in U-Boot can trigger callback routines. If these callback routines are not called then the setting of the environment variable will appear to have no effect.</p>
<p>Environment variable callbacks are declared by the U-Boot macro <code>U_BOOT_ENV_CALLBACK</code> and need to be referenced in the platform's <code>plat_driver_data.h</code> and <code>plat_driver_data.c</code> files, if required.</p>
<p>An example of this are the callbacks associated with networking related environment variables (e.g. setting of the IP address). The following excerpts from the Avnet MaaXBoard's <code>plat_driver_data.h</code> and <code>plat_driver_data.c</code> enable all networking related callbacks:</p>
<pre><code class="language-c">#define _u_boot_env_clbk_count 8
...
extern struct env_clbk_tbl _u_boot_env_clbk__ethaddr;
extern struct env_clbk_tbl _u_boot_env_clbk__ipaddr;
extern struct env_clbk_tbl _u_boot_env_clbk__gatewayip;
extern struct env_clbk_tbl _u_boot_env_clbk__netmask;
extern struct env_clbk_tbl _u_boot_env_clbk__serverip;
extern struct env_clbk_tbl _u_boot_env_clbk__nvlan;
extern struct env_clbk_tbl _u_boot_env_clbk__vlan;
extern struct env_clbk_tbl _u_boot_env_clbk__dnsip;
</code></pre>
<pre><code class="language-c">void initialise_driver_data(void) {
    ...
    driver_data.env_clbk_array[0] = _u_boot_env_clbk__ethaddr;
    driver_data.env_clbk_array[1] = _u_boot_env_clbk__ipaddr;
    driver_data.env_clbk_array[2] = _u_boot_env_clbk__gatewayip;
    driver_data.env_clbk_array[3] = _u_boot_env_clbk__netmask;
    driver_data.env_clbk_array[4] = _u_boot_env_clbk__serverip;
    driver_data.env_clbk_array[5] = _u_boot_env_clbk__nvlan;
    driver_data.env_clbk_array[6] = _u_boot_env_clbk__vlan;
    driver_data.env_clbk_array[7] = _u_boot_env_clbk__dnsip;
}
</code></pre>
<h2 id="incomplete-device-tree"><a class="header" href="#incomplete-device-tree">Incomplete Device Tree</a></h2>
<p>Device drivers commonly access settings stored within the platform's Device Tree. If the device does not appear to be functioning, it can be related to information missing from the Device Tree; such issues can be resolved by including the missing information in the platform's Device Tree overlay.</p>
<p>If the Device Tree is suspected of being incomplete it is suggested that the equivalent entries could be compared from Device Tree files for similar platforms (e.g. those using the same or similar SoC) held within the Linux and U-Boot repositories.</p>
<h3 id="example---dwc3-generic-usb-driver"><a class="header" href="#example---dwc3-generic-usb-driver">Example - DWC3 Generic USB Driver</a></h3>
<p>The widely used DWC3 USB device is supported by the DWC3 Generic USB driver. This driver has been found to expect a specific format of the USB device entries in the device tree with some settings held within a sub-node. Without the correct format, the USB device will not function.</p>
<p>An example of the required format is provided in the <a href="https://github.com/seL4/seL4/blob/master/src/plat/maaxboard/overlay-maaxboard.dts">overlay file for the Avnet MaaXBoard</a>.</p>
<h3 id="example---missing-pin-multiplexing-settings"><a class="header" href="#example---missing-pin-multiplexing-settings">Example - Missing Pin Multiplexing Settings</a></h3>
<p>Another potential reason for a non-functioning device is a failure to correctly configure the SoC's pin multiplexer, thereby failing to correctly connect the device to the external pins / pads on the SoC. This issue was encountered when adding SPI support for the Avnet MaaXBoard.</p>
<p>Pin multiplexing settings are held within <code>pinctrl-&lt;index&gt;</code> properties in the Device Tree, for example:</p>
<pre><code class="language-text">i2c@30a20000 {
    compatible = "fsl,imx8mq-i2c\0fsl,imx21-i2c";
    ...
    pinctrl-names = "default";
    pinctrl-0 = &lt;0x25&gt;;
</code></pre>
<p>Note that not all devices require pin multiplexer settings; e.g. device outputs may be routed to dedicated SoC pins / pads. The SoC's reference manual should be consulted to determine whether configuration is required for a device.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-3"><a class="header" href="#todo-3">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream
This section works through an example to show some of our device drivers being used within a larger application. It is nominally labelled as a 'security domain' demonstrator (named <code>security_demo</code>) but this is mainly in the context of being a keyboard-based encryption device that was inspired by an Enigma machine! It is intentionally simple and its main purpose is to show data separation and to provide worked examples of inter-component communications using different seL4 mechanisms.</p>
<h1 id="extra-functionality-within-the-demonstration-application-is-deliberately-kept-to-a-minimum-to-leave-the-source-code-less-cluttered-so-that-the-developer-can-readily-see-the-more-interesting-sel4-inter-component-and-device-interactions-without-too-much-extra-feature-supporting-code-in-line-with-the-rest-of-the-developer-kit-the-demonstration-application-is-intended-to-be-more-of-a-springboard-for-a-developer-kit-user-than-a-polished-product-for-an-end-user"><a class="header" href="#extra-functionality-within-the-demonstration-application-is-deliberately-kept-to-a-minimum-to-leave-the-source-code-less-cluttered-so-that-the-developer-can-readily-see-the-more-interesting-sel4-inter-component-and-device-interactions-without-too-much-extra-feature-supporting-code-in-line-with-the-rest-of-the-developer-kit-the-demonstration-application-is-intended-to-be-more-of-a-springboard-for-a-developer-kit-user-than-a-polished-product-for-an-end-user">Extra functionality within the demonstration application is deliberately kept to a minimum to leave the source code less cluttered, so that the developer can readily see the 'more interesting' seL4 inter-component and device interactions without too much extra, feature-supporting code. In line with the rest of the developer kit, the demonstration application is intended to be more of a springboard for a developer kit user than a polished product for an end user.</a></h1>
<p>This case study works through an example to show some of our device drivers being used within a larger application. It is nominally labelled as a 'security domain' demonstrator (named <code>security_demo</code>) but this is mainly in the context of being a keyboard-based encryption device that was inspired by an Enigma machine! It is intentionally simple and its main purpose is to show data separation and to provide worked examples of inter-component communications using different seL4 mechanisms.</p>
<p>Extra functionality within the demonstration application is deliberately kept to a minimum to leave the source code less cluttered, so that the developer can readily see the 'more interesting' seL4 inter-component and device interactions without too much extra, feature-supporting code. In line with the rest of the developer kit, the demonstration application is intended to be more of a springboard for a developer kit user than a polished product for an end user.</p>
<p>The case study has been produced for both frameworks (CAmkES and Microkit):</p>
<ul>
<li>
<p><a href="activity/case_study_application/../camkes_case_study_application/main.html">CAmkES case study</a></p>
</li>
<li>
<p><a href="activity/case_study_application/../microkit_case_study_application/main.html">Microkit case study</a></p>
</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Stashed changes</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-4"><a class="header" href="#todo-4">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>We defer to the seL4 Foundation's documentation of CAmkES as the primary source of understanding of CAmkES, but this section will cover aspects of the use of CAmkES where appropriate.</p>
<h2 id="basic-description"><a class="header" href="#basic-description">Basic Description</a></h2>
<p>An operator types a plaintext message using a USB-connected keyboard. The application encrypts the message and transmits the resulting ciphertext via Ethernet to a client that has connected to a predetermined port. The application also records the ciphertext messages in a logfile on the SD card of the device.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The architecture of the demonstrator is shown below.</p>
<p><img src="activity/camkes_case_study_application/encrypter_arch.png" alt="Demonstrator architecture" /></p>
<p>Blue blocks show CAmkES components created specifically for the security demonstrator (or previously created within the developer kit in the case of <a href="activity/camkes_case_study_application/../device_drivers/uboot_driver_usage.html#test-application-picoserver_uboot">EthDriverUboot</a>); grey blocks show CAmkES <a href="https://github.com/seL4/global-components">global components</a>.</p>
<p>Arrow directions show an abstracted view of data flow. Arrow labels refer to seL4 connector types (some concerned with data flow, some with control flow), which are elaborated in the key. More details about seL4 connector types may be found in the <a href="https://docs.sel4.systems/projects/camkes/manual.html">CAmkES manual</a>, but the fundamental types are <em>RPC</em> (Remote Procedure Call), <em>SharedData</em>, and <em>Notification</em> (see examples such as <code>seL4RPCCall</code> in the key).</p>
<p>As the KeyReader and Crypto components handle plaintext and cryptographic data (e.g. keys), they are considered as 'high-side' in terms of security and must be kept separate from the downstream 'low-side' components that handle ciphertext. It is not the role of this developer kit to re-justify the credentials of seL4 (the <a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4 whitepaper</a> is a good starting point), but suffice to say that seL4's capability-based access controls guarantee protection and separation between all components, regardless of the notional high and low sides that we have overlaid, only allowing interactions between components where explicitly established via the seL4 connector types.</p>
<p>The following paragraphs briefly describe the data flow, from left to right, highlighting the different seL4 mechanisms used for inter-component communications.</p>
<h3 id="components-and-connector-types"><a class="header" href="#components-and-connector-types">Components and Connector Types</a></h3>
<p>Plaintext characters are typed on a keyboard and read by the KeyReader component. These characters are then 'encrypted' by the Crypto component to transform them into ciphertext. <em>RPC</em> is an appropriate connector type for the character-by-character data flow between KeyReader and Crypto (labelled as RPC-1 on the diagram), employing <code>seL4RPCCall</code>. Since this application is more concerned with demonstrating seL4 concepts than crypto-algorithms, the Enigma machine's rotors and plugboard are replaced with a simple <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> algorithm!</p>
<p>The encrypted characters are transferred to the Transmitter component via a shared circular buffer, where Crypto writes to the <em>head</em> of the buffer and Transmitter reads from its <em>tail</em>. The buffer is implemented as a <em>SharedData</em> connection (labelled as SharedData-1 on the diagram) using <code>seL4SharedData</code>. (Note that within CAmkES, shared memory is abstracted as a <em>Dataport</em>, so this terminology is often seen associated with this connection type.)</p>
<p>If the buffer is full, Crypto discards characters; otherwise, each time Crypto writes a character to the buffer, it sends a <em>Notification</em> to Transmitter (labelled as Notification-1 on the diagram) to signify that there is data to read, using <code>seL4Notification</code>. Transmitter acts upon notifications by reading all available characters until the buffer is empty.</p>
<p>The shared buffer is protected from concurrent access by use of a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>. The mutex is owned by Crypto, and Transmitter accesses its lock and unlock operations via an <em>RPC</em> connection (labelled as RPC-2); note that this is a control flow and is in the opposite direction to the arrow, which shows the data flow of encrypted characters.</p>
<p>The Transmitter component interfaces to PicoServer via three connections, as shown in the <code>picoserver_uboot</code> <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot">test application diagram</a>: <code>send</code>, <code>receive</code>, and <code>control</code>. The <code>send</code> and <code>receive</code> connections are defined as global connector type <code>seL4PicoServer</code>, which is fundamentally <code>seL4RPCDataport</code> (<em>SharedData</em> combined with <em>RPC</em>). The <code>control</code> connection has a global connector type of <code>seL4PicoServerSignal</code>, which is fundamentally <code>seL4RPCCallSignal</code> (<em>RPC</em> combined with <em>Notification</em>). Note that although the interface between Transmitter and PicoServer configures <code>receive</code> in order to satisfy the CAmkES connections, the application does not process any Ethernet traffic in this direction, and only <code>send</code> is used.</p>
<p>The interface between PicoServer and EthDriverUboot uses the <code>seL4Ethdriver</code> global connector type, which is fundamentally another instance of <code>seL4RPCDataport</code> (<em>SharedData</em> combined with <em>RPC</em>).</p>
<p>TimeServer, which supports timing functionality for PicoServer, uses the <code>seL4TimeServer</code> global connector type, which is fundamentally another instance of <code>seL4RPCCallSignal</code> (<em>RPC</em> combined with <em>Notification</em>).</p>
<h3 id="device-drivers"><a class="header" href="#device-drivers">Device Drivers</a></h3>
<p>As can be seen from the architecture diagram, three hardware devices are involved in the operation of the application.</p>
<ol>
<li>
<p>The KeyReader component requires access to the USB device to allow for plaintext characters to be input from a USB keyboard.</p>
</li>
<li>
<p>The Transmitter component requires access to the SD/MMC device to allow for the ciphertext message to be output to a log file.</p>
</li>
<li>
<p>The EthDriverUboot component requires access to the Ethernet device to allow for ciphertext message to be output to the network.</p>
</li>
</ol>
<p>Device drivers for the required hardware access are supplied by the <a href="activity/camkes_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a> previously introduced by this development kit.</p>
<p>Three separate instances of the library are used by the application, one per component with a need for hardware device access. The capabilities of each component, and their associated library instances, are configured such that each component is only capable of accessing the minimum set of hardware devices required to perform the desired function.</p>
<p>For example, the Transmitter component only has a need to access the SD/MMC device to write the ciphertext log file. As such, the capabilities of the Transmitter component permit it to access the memory-mapped interface of the SD/MMC device; however no such capabilities are provided for the USB or Ethernet devices. Any attempt by the Transmitter component to access the memory-mapped interface of the USB device (e.g. in an attempt to read the plaintext keypresses) would therefore be prevented by seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-detail"><a class="header" href="#design-detail">Design Detail</a></h1>
<p>Following on from the <a href="activity/camkes_case_study_application/architecture.html">Architecture document</a>, this section provides further details on the design and functionality of the 'security domain' demonstrator application.</p>
<p>It is expected that the reader is familiar with the <a href="https://docs.sel4.systems/projects/camkes/manual.html">seL4 CAmkES manual</a>.</p>
<h2 id="code-structure-1"><a class="header" href="#code-structure-1">Code Structure</a></h2>
<p>The application is held within the following structure (all within the <code>camkes/apps</code> folder), with key folders and files shown:</p>
<pre><code class="language-text">security_demo
│
├───components
│   ├───&lt;component_1&gt;
│   │   ├───src
│   │   │   └───&lt;component_source_file&gt;.c
│   │   └───&lt;component_camkes_file&gt;.camkes
│   ...
│   └───&lt;component_n&gt;
│       ├───src
│       │   └───&lt;component_source_file&gt;.c
│       └───&lt;component_camkes_file&gt;.camkes
│
├───include
│   └───plat
│       ├───&lt;platform&gt;
│       │   ├───eth_platform_devices.h
│       │   ├───mmc_platform_devices.h
│       │   └───usb_platform_devices.h
│       └───dataport_buffer.h
│
├───interfaces
│   ├───Character_RPC.idl4
│   └───Lock_RPC.idl4
│
├───CMakeLists.txt
└───security_demo.camkes
</code></pre>
<ul>
<li><code>CMakeLists.txt</code>: Application build file.</li>
<li><code>security_demo.camkes</code>: Top-level CAmkES file for the project, declaring the application's CAmkES 'assembly' including declaration of all inter-component connections.</li>
<li><code>components/&lt;component&gt;/&lt;component_camkes_file&gt;.camkes</code>: A component's CAmkES file, declaring the component's attributes including declaration of all interfaces (i.e. exposed inter-component interaction points).</li>
<li><code>interfaces/Character_RPC.idl4</code>: Declaration of a remote procedure call method used to communicate a character between components.</li>
<li><code>interfaces/Lock_RPC.idl4</code>: Declaration of remote procedure call methods used to access a mutex held by another component.</li>
<li><code>include/dataport_buffer.h</code>: Declaration of a C data type for a circular buffer to be stored in a dataport.</li>
<li><code>include/&lt;platform&gt;/&lt;eth|mmc|usb&gt;_platform_devices.h</code>: Declaration of (platform specific) CAmkES attributes to grant a component with capabilities access to a hardware device.</li>
</ul>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<p>From a concurrency perspective, the security demonstrator can be summarised as threads of execution on the 'high-side' managing plaintext data running asynchronously to threads of execution on the 'low-side' managing ciphertext data.</p>
<p>Threads of execution on the high-side perform the following functions:</p>
<ol>
<li>Reading plaintext keypresses from the USB keyboard;</li>
<li>Encrypting those keypresses from plaintext to ciphertext; and</li>
<li>Placing ciphertext keypresses into a shared circular buffer between the high-side and low-side.</li>
</ol>
<p>Asynchronously, threads of execution on the low-side perform the following functions:</p>
<ol>
<li>Reading ciphertext keypresses from a shared circular buffer between the high-side and low-side;</li>
<li>Periodically writing received ciphertext to a log file; and</li>
<li>Outputting ciphertext to a network socket (if connected).</li>
</ol>
<p>All data is passed from the high-side to the low-side through a shared circular buffer stored within a dataport. It is this circular buffer between the high-side and low-side that permits:</p>
<ol>
<li>Data transfer from the high-side to the low-side; and</li>
<li>Threads of execution on the high-side and threads of execution on the low-side to run asynchronously.</li>
</ol>
<h2 id="example-of-inter-component-communication"><a class="header" href="#example-of-inter-component-communication">Example of Inter-Component Communication</a></h2>
<p>The circular buffer shared between the Crypto component (high-side) and the Transmitter component (low-side) is used in this section as a detailed worked example of CAmkES inter-component data flow and control flow.</p>
<p>The buffer has been deliberately designed for the purpose of this worked example to use of all three types of component interface listed in the <a href="https://docs.sel4.systems/projects/camkes/manual.html">seL4 CAmkES manual</a>, i.e. <em>procedure</em>, <em>event</em> and <em>port</em>.</p>
<h3 id="port"><a class="header" href="#port">Port</a></h3>
<p>At its core the circular buffer is a simple character array with <em>head</em> and <em>tail</em> holding indexes associated with the start and end of the used portion of the array.</p>
<ul>
<li>Further details are documented alongside the definition of the <code>dataport_buffer_t</code> type definition in <code>include/dataport_buffer.h</code>.</li>
<li><em>Port</em> interfaces of data type <code>dataport_buffer_t</code> are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4SharedData</code> connection between the two <em>port</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in an instance of the circular buffer type being made available in an area of memory shared by both the Crypto and Transmitter components.</p>
<h3 id="procedure"><a class="header" href="#procedure">Procedure</a></h3>
<p>Reading data from, or writing data to, the circular buffer requires the data array, <em>head</em> index, and <em>tail</em> index to be modified. Such modification of the buffer cannot be allowed to occur concurrently by both the Crypto and Transmitter components, otherwise corruption of the buffer may occur. Access to the buffer by the two components must therefore be protected to avoid concurrent access.</p>
<p>Within the security demonstrator, a mutex is used to enforce this critical section; each component must hold the lock on the mutex prior to accessing the circular buffer, and must release the lock when access to the circular buffer has been completed.</p>
<p>The mutex is owned by the Crypto component; see definition of <code>circular_buffer_mutex</code> in the Crypto component's CAmkES file. To allow the Transmitter component to access the mutex, a <em>procedure</em> interface is used providing <code>lock</code> and <code>unlock</code> routines.</p>
<ul>
<li>Declaration of the <code>lock</code> and <code>unlock</code> <em>procedure</em> templates are provided by <code>interfaces/Lock_RPC.idl4</code>.</li>
<li><em>Procedure</em> interfaces using the <code>lock</code> and <code>unlock</code> templates are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4RPCCall</code> connection between the two <em>procedure</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in the Crypto component being supplied with a mutex and remote procedure call interfaces being supplied to the Transmitter component to allow it to access the mutex.</p>
<h3 id="event"><a class="header" href="#event">Event</a></h3>
<p>Whilst a functional system could be produced with just the <em>port</em> and <em>procedure</em> interfaces described above, there would be no mechanism for the Transmitter component to determine whether the circular buffer contains any data other than to periodically poll the contents of the circular buffer; this would be needlessly inefficient.</p>
<p>Instead, an <em>event</em> interface is used to allow the Crypto component to notify Transmitter when a character has been written into the circular buffer. This allows the Transmitter component to wait or poll for such a notification before locking the mutex and accessing the circular buffer.</p>
<ul>
<li><em>Event</em> interfaces, with the Crypto component as the emitter and Transmitter as the consumer, are declared in the Crypto and Transmitter component CAmkES files.</li>
<li>An <code>seL4Notification</code> connection between the two <em>event</em> interfaces is then declared in the CAmkES assembly (see <code>security_demo.camkes</code>).</li>
</ul>
<p>This results in the creation of a notification that can be emitted from the Crypto component and can be either waited on, or polled, by the Transmitter component.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Putting all three interface types (<em>port</em>, <em>procedure</em>, and <em>event</em>) together results in:</p>
<ul>
<li>A shared circular buffer;</li>
<li>A mutex which can be accessed via remote procedure calls to protect the buffer against concurrent access; and</li>
<li>A notification mechanism to allow the producer to notify the consumer when new data is available.</li>
</ul>
<p>This thereby allows asynchronous data transfer and buffering between components such that the producer and consumer can work concurrently.</p>
<p>The example source code for the producer component demonstrating use of these inter-component communication mechanisms can be found in <code>components/Crypto/src/crypto.c</code>. The source code for the consumer component can be found in <code>components/Transmitter/src/transmitter.c</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-running"><a class="header" href="#building-and-running">Building and Running</a></h1>
<p>This section builds and runs the <code>security_demo</code> demonstration application described in <a href="activity/camkes_case_study_application/architecture.html">Architecture document</a>. All the host machine and target platform requirements described previously in this developer kit documentation are assumed.</p>
<h2 id="building-the-application"><a class="header" href="#building-the-application">Building the Application</a></h2>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/camkes_case_study_application/../../install_and_configure/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/security_demo
cd /host/security_demo
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The application requires an IP address to be allocated to PicoServer. This should be substituted for <code>xxx.xxx.xxx.xxx</code> below. From the <code>/host/security_demo</code> directory, we execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=security_demo -DPLATFORM=maaxboard -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
</code></pre>
<p>This command should be repeated as a workaround - see the <a href="activity/camkes_case_study_application/build.html#implementation-note">implementation note</a> below:</p>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=security_demo -DPLATFORM=maaxboard -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
</code></pre>
<p>Then run <code>ninja</code> as usual:</p>
<pre><code class="language-bash">ninja
</code></pre>
<h3 id="implementation-note-1"><a class="header" href="#implementation-note-1">Implementation note</a></h3>
<p>There is a known race condition with the CMake configuration of picoserver, which, if only run once, results in <code>fatal error: pico_device.h: No such file or directory</code>. A workaround is to run the command twice, or run CMake again, by typing <code>cmake .</code> (see <a href="https://lists.sel4.systems/hyperkitty/list/devel@sel4.systems/thread/O5B42BFF4FZ2WSCPUK6C6QUAJHD6DETN/">here</a>).</p>
<h2 id="preparing-to-run"><a class="header" href="#preparing-to-run">Preparing to Run</a></h2>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/camkes_case_study_application/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>Running the <code>security_demo</code> application requires the following:</p>
<ul>
<li>Connect a keyboard to the USB socket<sup class="footnote-reference"><a href="#1">1</a></sup> of the MaaXBoard;</li>
<li>Establish an Ethernet connection between the MaaXBoard and the host machine, which can be direct or via a network, as outlined in <a href="activity/camkes_case_study_application/bootloader.html#loading-via-tftp">an earlier section</a> (e.g. it will already be in place if TFTP is being used to transfer executables).</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<p>If the user has experience of running the <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot"><code>picoserver_uboot</code> test application</a>, then elements of the <code>security_demo</code> application will be familiar. For example, from a terminal window on the host machine, we will use the <code>netcat</code> (<code>nc</code>) command (native to Linux or macOS, or available as a <a href="https://nmap.org/ncat/">download</a> for Windows) to connect to the MaaXBoard, so this should be prepared.</p>
<h2 id="running-the-application"><a class="header" href="#running-the-application">Running the Application</a></h2>
<p>The application invokes three instances of the <a href="activity/camkes_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a>, so various sets of diagnostic messages are repeated on the CoolTerm display as the application starts. We should not be unduly concerned with some of the individual messages, such as <code>No ethernet found</code>, since in this case only one of the library instances is configured to use Ethernet (i.e. the library invoked by the EthDriverUboot component), and amongst the other messages there should be confirmation that it was successful, e.g. <code>Assigned ipv4 xxx.xxx.xxx.xxx to device eth0</code>. There are also some <code>clk_register: failed ... (parent ...)</code> messages, which are harmless (a fault in U-Boot's clock driver for the MaaXBoard).</p>
<p>When the application's initialisation has completed, we should see:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
Net:   transmitter_log.txt: doesn't exist
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 1 ---
</code></pre>
<p>Note that on subsequent runs, the log file will exist (unless the user has intentionally deleted it), and the output will instead read:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 0 ---
</code></pre>
<p>In either scenario, this is housekeeping by the application to delete any previous Transmitter logfile from the SD card, before it starts writing new log data. The logfile is named <code>transmitter_log.txt</code> and is expected on the third partition of the SD card - see the FAT partition <code>FILESYS</code> established during the <a href="activity/camkes_case_study_application/appendices/partitioning_sd_card.html">Partitioning the SD Card appendix</a>.</p>
<p>Just as with the <a href="activity/camkes_case_study_application/uboot_driver_usage.html#test-application-picoserver_uboot"><code>picoserver_uboot</code> test application</a>, the application may sporadically display <code>No such port ....</code> messages as it monitors traffic on the network. This is expected diagnostic behaviour that may be ignored; indeed, the lack of any such messages may indicate for example that the Ethernet driver has not initialised properly.</p>
<p>The application is now ready to perform various actions concurrently:</p>
<ol>
<li>If a key is pressed, the plaintext character will be encrypted into a ciphertext character;</li>
<li>If a client requests an Ethernet connection on port 1234, the application will establish the connection and transmit ciphertext to the client, continuing to do so until the client closes the connection;</li>
<li>Every 30 seconds, if there are any ciphertext characters that it has not yet logged to file, the application will append them to the logfile on the SD card.</li>
</ol>
<p>For item (2), from a terminal window on the host machine, start <code>netcat</code> with the command:</p>
<pre><code class="language-bash">nc xxx.xxx.xxx.xxx 1234
</code></pre>
<p>where <code>xxx.xxx.xxx.xxx</code> is the IP address of the MaaXBoard, as previously specified in the <code>init_build</code> call, and 1234 is the port number that has been programmed into the application.</p>
<p>In the CoolTerm window, a message such as the following will signify a successful connection:</p>
<pre><code class="language-text">transmitter: Connection established with yyy.yyy.yyy.yyy on socket 1
</code></pre>
<p>where <code>yyy.yyy.yyy.yyy</code> is the IP address of the host machine.</p>
<p>If this connection is not established promptly, please refer to the previous <a href="activity/camkes_case_study_application/uboot_driver_usage.html#implementation-note">implementation note</a> relating to network connection delays.</p>
<p>If characters have been typed at the USB keyboard before making the <code>netcat</code> connection, then (ciphertext) characters will appear straightaway on the host machine, since the application stores characters in a buffer while they cannot be sent.</p>
<p>Plaintext messages may be typed on the keyboard (note that these are not displayed anywhere), for example:</p>
<pre><code class="language-text">Hello world, testing 123. We love seL4!
</code></pre>
<p>Within the host machine's <code>netcat</code> session, the corresponding ciphertext message should appear:</p>
<pre><code class="language-text">Uryyb jbeyq, grfgvat 123. Jr ybir frY4!
</code></pre>
<p>Periodically, the CoolTerm window will show diagnostic messages concerning the logfile, such as:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' ---
38 bytes written in 5 ms (6.8 KiB/s)
run_uboot_command@uboot_wrapper.c:181 --- command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' completed with return code 0 ---
</code></pre>
<p>The application will continue indefinitely. <code>netcat</code> sessions on the host machine may be terminated (Ctrl-C) and restarted, whereupon the application will establish a new connection (buffering output in the meantime).</p>
<p>If the MaaXBoard is powered off and its SD card removed and transferred to the host machine, the <code>transmitter_log.txt</code> can be accessed from the <code>FILESYS</code> partition as one would expect.</p>
<p>To reduce the risk of corrupting the SD card, it is advisable to avoid powering off the MaaXBoard during a write operation of the logfile. As this operation lasts in the order of 10 ms and only occurs every 30 seconds (and only then if there are any ciphertext characters that have not yet been logged to file), the risk is both remote and avoidable (e.g. power off soon after a <code>fatwrite</code> command message, or wait for &gt;30 seconds after the last <code>fatwrite</code> command message).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-5"><a class="header" href="#todo-5">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<p>It is assumed the CAmkES case study <a href="activity/microkit_case_study_application/../camkes_case_study_application/architecture.html">architecture document</a> had been read previous to reading this document.</p>
<p>The architecture of the Microkit demonstrator is shown below.</p>
<p><img src="activity/microkit_case_study_application/encrypter_arch.png" alt="Demonstrator architecture" /></p>
<p>The CAmkES and Microkit architectures are the same up to the Picoserver module, the Microkit connector types are Protected Procedure and Notification.</p>
<h3 id="protection-domains-and-connector-types"><a class="header" href="#protection-domains-and-connector-types">Protection domains and Connector Types</a></h3>
<p>Protected procedure is an appropriate connector type for the character-by-character data flow between KeyReader and Crypto. The encrypted characters are transferred to the Transmitter PD via a shared circular buffer, where Crypto writes to the head of the buffer and Transmitter reads from its tail. The buffer is implemented as a shared memory region. When the buffer is full Crypto notifies Transmitter that the buffer is full and the data needs to be read via the notification mechanism. Transmitter acts upon notifications by reading all available characters until the buffer is empty.</p>
<h3 id="device-drivers-1"><a class="header" href="#device-drivers-1">Device Drivers</a></h3>
<p>As can be seen from the architecture diagram, three hardware devices are involved in the operation of the application.</p>
<ol>
<li>
<p>The KeyReader protection domain requires access to the USB device to allow for plaintext characters to be input from a USB keyboard.</p>
</li>
<li>
<p>The Transmitter protection domain requires access to the SD/MMC device to allow for the ciphertext message to be output to a log file.</p>
</li>
</ol>
<p>Device drivers for the required hardware access are supplied by the <a href="activity/microkit_case_study_application/uboot_driver_library.html">U-Boot Driver Library</a> previously introduced by this development kit.</p>
<p>Two separate instances of the library are used by the application, one per protection domain with a need for hardware device access. The capabilities of each protection domain, and their associated library instances, are configured such that each protection domain is only capable of accessing the minimum set of hardware devices required to perform the desired function.</p>
<p>For example, the Transmitter protection domain only has a need to access the SD/MMC device to write the ciphertext log file. As such, the capabilities of the Transmitter protection domain permit it to access the memory-mapped interface of the SD/MMC device; however no such capabilities are provided for the USB device. Any attempt by the Transmitter protection domain to access the memory-mapped interface of the USB device (e.g. in an attempt to read the plaintext keypresses) would therefore be prevented by seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study-design-detail"><a class="header" href="#case-study-design-detail">Case Study Design Detail</a></h1>
<p>Following on from the <a href="activity/microkit_case_study_application/architecture.html">architecture document</a>, this section provides further details on the design and functionality of the 'security domain' demonstrator application.</p>
<p>It is expected that the reader is familiar with the <a href="https://github.com/seL4/microkit/blob/main/docs/manual.md">seL4 Microkit manual</a>.</p>
<h2 id="code-structure-2"><a class="header" href="#code-structure-2">Code Structure</a></h2>
<p>The application is held within the following structure (all within the <code>microkit</code> folder), with key folders and files shown:</p>
<pre><code class="language-text">microkit
│
├───crypto
|   └───crytpo.c
├───keyreader
│   └───keyreader.c
├───transmitter
│   └───transmitter.c
│      
├───include
│   └───plat
│       └───&lt;platform&gt;
│            ├───mmc_platform_devices.h
│            └───usb_platform_devices.h
│
│
├───CMakeLists.txt
│
├───example
│   └───&lt;platform&gt;
│       └───security_demo
│           └───security_demo.system
</code></pre>
<ul>
<li><code>CMakeLists.txt</code>: Application build file.</li>
<li><code>security_demo.system</code>: Microkit file for the project, declaring the application's protection domains including declaration of all protection domain channels.</li>
<li><code>include/plat/&lt;mmc|usb&gt;_platform_devices.h</code>: Declaration of (platform specific) Microkit attributes to grant a protection domain with capabilities access to a hardware device.</li>
</ul>
<h2 id="concurrency-model-1"><a class="header" href="#concurrency-model-1">Concurrency Model</a></h2>
<p>From a concurrency perspective, the security demonstrator can be summarised as threads of execution on the 'high-side' managing plaintext data running asynchronously to threads of execution on the 'low-side' managing ciphertext data.</p>
<p>Threads of execution on the high-side perform the following functions:</p>
<ol>
<li>Reading plaintext keypresses from the USB keyboard;</li>
<li>Encrypting those keypresses from plaintext to ciphertext; and</li>
<li>Placing ciphertext keypresses into a shared circular buffer between the high-side and low-side.</li>
</ol>
<p>Asynchronously, threads of execution on the low-side perform the following functions:</p>
<ol>
<li>Reading ciphertext keypresses from a shared circular buffer between the high-side and low-side;</li>
<li>Periodically writing received ciphertext to a log file.</li>
</ol>
<p>All data is passed from the high-side to the low-side through a shared circular buffer stored within a dataport. It is this circular buffer between the high-side and low-side that permits:</p>
<ol>
<li>Data transfer from the high-side to the low-side; and</li>
<li>Threads of execution on the high-side and threads of execution on the low-side to run asynchronously.</li>
</ol>
<h2 id="example-of-protection-domain-communication"><a class="header" href="#example-of-protection-domain-communication">Example of Protection Domain Communication</a></h2>
<p>The circular buffer shared between the Crypto protection domain (high-side) and the Transmitter protection domain (low-side) is used in this section as a detailed worked example of Microkit data flow and control flow.</p>
<p>The buffer has been deliberately designed for the purpose of this worked example to use two types of protection domain interface listed in the <a href="https://github.com/sel4-cap/microkit-old/blob/main/docs/manual.md">seL4 Microkit manual</a>, i.e. Memory region and Notification.</p>
<h3 id="memory-region"><a class="header" href="#memory-region">Memory Region</a></h3>
<p>At its core the circular buffer is a simple character array with <em>head</em> and <em>tail</em> holding indexes associated with the start and end of the used portion of the array.</p>
<h3 id="procedure-1"><a class="header" href="#procedure-1">Procedure</a></h3>
<p>Reading data from, or writing data to, the circular buffer requires the data array, <em>head</em> index, and <em>tail</em> index to be modified. Such modification of the buffer cannot be allowed to occur concurrently by both the Crypto and Transmitter protection domains, otherwise corruption of the buffer may occur. Access to the buffer by the two protection domains must therefore be protected to avoid concurrent access.</p>
<p>Within the security demonstrator, a lock is used to enforce this critical section which takes the form of a boolean on the circular buffer data structure; each protection domain must lock the circular buffer prior to accessing the circular buffer, and must release the lock when access to the circular buffer has been completed.</p>
<ul>
<li>Function implementations for the circular buffer are included in <code>src/circular_buffer.c</code>.</li>
<li>A memory region is a contiguous range of physical memory and the memory region for the circular buffer is mapped onto both the Crypto and Transmitter protection domains. A virtual address, caching attributes and permissions (read, write and execute) are given to each protection domain.</li>
</ul>
<p>This results in an instance of the circular buffer type being made available in an area of memory shared by both the Crypto and Transmitter protection domains.</p>
<h3 id="notification"><a class="header" href="#notification">Notification</a></h3>
<p>A mechanism for the Transmitter protection domain to determine whether the circular buffer contains any data.</p>
<p>A Notification interface is used to allow the Crypto protection domain to notify Transmitter when the circular buffer is full. This allows the Transmitter protection domain to wait or poll for such a notification before accessing the circular buffer.</p>
<ul>
<li>Channels are set up between the Crypto and Transmitter protection domains in the applications system file which allow the protection domains to notify each other when there is data to read in a shared buffer.</li>
</ul>
<p>This results in the creation of a notification that can be emitted from the Crypto protection domain and can be either waited on, or polled, by the Transmitter protection domain.</p>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>Putting the two interface types (Memory region and Notification) together results in:</p>
<ul>
<li>A shared circular buffer;</li>
<li>A notification mechanism to allow the producer to notify the consumer when new data is available.</li>
</ul>
<p>This thereby allows asynchronous data transfer and buffering between protection domains such that the producer and consumer can work concurrently.</p>
<p>The example source code for the producer protection domain demonstrating use of these communication mechanisms can be found in <code>crypto/crypto.c</code>. The source code for the consumer protection domain can be found in <code>transmitter/transmitter.c</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study-building-and-running"><a class="header" href="#case-study-building-and-running">Case Study Building and Running</a></h1>
<p>This section builds and runs the <code>security_demo</code> demonstration application described in <a href="activity/microkit_case_study_application/intro.html">Case Study Introduction</a>. All the host machine and target platform requirements described previously in this developer kit documentation are assumed.</p>
<h2 id="building-the-application-1"><a class="header" href="#building-the-application-1">Building the Application</a></h2>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/microkit_case_study_application/../../install_and_configure/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/security_demo
cd /host/security_demo
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4-cap/dev-kit-microkit-manifest
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>From the <code>/host/security_demo</code> directory, we execute the following commands:</p>
<pre><code class="language-text">cd microkit
</code></pre>
<pre><code class="language-bash">./init-build.sh -DMICROKIT_APP=security_demo -DPLATFORM=maaxboard
</code></pre>
<h2 id="preparing-to-run-1"><a class="header" href="#preparing-to-run-1">Preparing to Run</a></h2>
<p>A successful build will result in an executable file called <code>sel4_image</code> in the <code>example/&lt;platform&gt;/security_demo/example-build</code> subdirectory. This file should be made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/microkit_case_study_application/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>Running the <code>security_demo</code> application requires the following:</p>
<ul>
<li>Connect a keyboard to the USB socket<sup class="footnote-reference"><a href="#1">1</a></sup> of the MaaXBoard;</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<h2 id="running-the-application-1"><a class="header" href="#running-the-application-1">Running the Application</a></h2>
<p>The application invokes two instances of the <a href="activity/microkit_case_study_application/../device_drivers/uboot_driver_library.html">U-Boot Driver Library</a>, so various sets of diagnostic messages are repeated on the CoolTerm display as the application starts. We should not be unduly concerned with some of the individual messages, such as <code>No ethernet found</code>, since in this case none of the library instances are configured to use ethernet. There are also some <code>clk_register: failed ... (parent ...)</code> messages, which are harmless (a fault in U-Boot's clock driver for the MaaXBoard).</p>
<p>When the application's initialisation has completed, we should see:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
Net:   transmitter_log.txt: doesn't exist
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 1 ---
</code></pre>
<p>Note that on subsequent runs, the log file will exist (unless the user has intentionally deleted it), and the output will instead read:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatrm mmc 0:2 transmitter_log.txt' ---
run_uboot_command@uboot_wrapper.c:181 --- command 'fatrm mmc 0:2 transmitter_log.txt' completed with return code 0 ---
</code></pre>
<p>In either scenario, this is housekeeping by the application to delete any previous Transmitter logfile from the SD card, before it starts writing new log data. The logfile is named <code>transmitter_log.txt</code> and is expected on the third partition of the SD card - see the FAT partition <code>FILESYS</code> established during the <a href="activity/microkit_case_study_application/partitioning_sd_card.html">Partitioning the SD Card appendix</a>.</p>
<p>The application is now ready to perform various actions concurrently:</p>
<ol>
<li>If a key is pressed, the plaintext character will be encrypted into a ciphertext character;</li>
<li>When the circular buffer is full, the application will append them to the logfile on the SD card.</li>
</ol>
<p>Periodically, the CoolTerm window will show diagnostic messages concerning the logfile, such as:</p>
<pre><code class="language-text">run_uboot_command@uboot_wrapper.c:176 --- running command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' ---
38 bytes written in 5 ms (6.8 KiB/s)
run_uboot_command@uboot_wrapper.c:181 --- command 'fatwrite mmc 0:2 0x55b010 transmitter_log.txt 26 1' completed with return code 0 ---
</code></pre>
<p>The application will continue indefinitely.</p>
<p>If the MaaXBoard is powered off and its SD card removed and transferred to the host machine, the <code>transmitter_log.txt</code> can be accessed from the <code>FILESYS</code> partition as one would expect.</p>
<p>To reduce the risk of corrupting the SD card, it is advisable to avoid powering off the MaaXBoard during a write operation of the logfile. As this operation lasts in the order of 10 ms, the risk is both remote and avoidable (e.g. power off soon after a <code>fatwrite</code> command message).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microkit-xhci-usb-driver"><a class="header" href="#microkit-xhci-usb-driver">Microkit xHCI USB Driver</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>For this activity the goal was to create an Sel4 native xHCI driver. Writing an entire xHCI driver from scratch is a long and complicated task, so we opted to re-work an existing solution. We chose to use NetBSD's xHCI driver because it has good portability, supports a wide range of hardware, is BSD licenced, is updated often and makes use of interrupts which are more performant compared to other solutions that use polling. The plan was to use this as a base to pull drivers from in the future.</p>
<h2 id="project-layout"><a class="header" href="#project-layout">Project Layout</a></h2>
<p>This project uses "repo" to initialise the xHCI driver repository and to clone the dependant repositories into specific directories. To install microkit we use "make get" and "make all" in the microkit directory.</p>
<p>The repository can be found here at https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-xhci-manifest.</p>
<p>The dependant projects can be found at:</p>
<ul>
<li>https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-xhci-driver - The xHCI driver</li>
<li>https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-netbsd-fork - Fork of NetBSD</li>
<li>https://github.com/sel4devkit/picolibc - C library</li>
</ul>
<h2 id="xhci"><a class="header" href="#xhci">xHCI</a></h2>
<p>xHCI is a standardised interface used for USB host controllers. Also known as the USB 3.0 host controller specification, it is designed to be backward compatible, supporting a wide range of USB devices from older USB 1.x to the more recent USB 3.x versions. Compared to its predecessors (OHCI, UHCI and EHCI) it is designed to handle multiple data transfer speeds within a single unified standard, making it more efficient at handling computer resources. The standard describes the basic communication between the software and the host controller including memory layout, data structures, MMIO and DMA.</p>
<h2 id="camkes-5"><a class="header" href="#camkes-5">CAmkES</a></h2>
<p>For our initial development we used CAmkES with the first goal of interfacing with the hardware. We compiled NetBSD, then traced the initialisation of the xHCI, noting down the input/output read and write commands. We then hardcoded the necessary memory register addresses and worked out the changes that we needed to make to the driver so that it was compatible with seL4 and CAmkES. We were then able to initialise the host controller by setting up the correct memory registers, DMA and interrupts. Once we got it to this point we decided to port the example to Microkit.</p>
<h2 id="microkit-5"><a class="header" href="#microkit-5">Microkit</a></h2>
<p>The first goal was to understand the differences between CAmkES and Microkit and become familiar with its features. Compared to CAmkES, Microkit has no standard libraries which meant that we had to export libraries for simple functionality such as logging and memory handling. We also had to create a simple DMA handler, and in the absence of a build system we opted to use GNU Make. Once we had an understanding of Microkit we got our new example to initialise the host controller as we did with CAmkES.</p>
<p>We created a separate DMA library which can be found here: LINK TBD</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p><img src="activity/microkit_usb_driver/system_architecture.png" alt="screenshot" /></p>
<p>One Protection Domain (PD) acts as a central driver which handles all of the initialization and communicates with the hardware via MMIO. There are additional PD's for the memory handler, software interrupts and hardware interrupts.</p>
<h3 id="memory-considerations"><a class="header" href="#memory-considerations">Memory considerations</a></h3>
<p>Between the core driver PD and the software interrupt PD there are some function pointers to callback functions. In NetBSD's it expects these function callbacks to be running in the same memory address space but with our setup this part of the communication is done between PD's, meaning that they don't have access to the same blocks of memory. Our first attempt at resolving this solution involved using a master PD that handles all of these functions, where the driver would call into the master PD, then the master PD would call into the software interrupt PD. This however was not a viable solution because the software interrupt PD was of a lower priority than the driver which had an affect on performance. Instead we opted to use a context switch, where both PD's at initialisation notify each other of the memory addresses that they will be using for the function pointers. The appropriate memory address is then selected during the function callback.</p>
<h3 id="devices"><a class="header" href="#devices">Devices</a></h3>
<p>Once we initialised host controller, we moved onto devices. We started with keyboard as it was straightforward to get an example up and running and easy to test as it is a human interface device. Next we added a mouse which was conceptually very similar to the keyboard as they were both human interface devices and had the same fundamental layer. Additionally we just needed to include the mouse set up files from NetBSD. We also added touchscreen support by making use of the generic code for the mouse and by implementing extra functionality to account for the Z axis. When probing the bus for drivers we needed to state what device was being attached. This meant modifying the code and recompiling the program when switching between devices. To resolve this we introduced NetBSD's autoconfiguration which reads from a  prebuilt list of devices created at kernel compile time to evaluate which USB devices drivers should be assigned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hdmi-driver"><a class="header" href="#hdmi-driver">HDMI Driver</a></h1>
<p>For this task the aim was to create an hdmi display driver. For inspiration we looked at U-Boot’s implementation of an imx8m display driver because it is BSD licensed and minimally featured, which was useful to build upon as an initial foundation.</p>
<p>The repository for this project is located at: <a href="https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-hdmi-driver">https://github.com/sel4-cap/sel4-hdmi </a></p>
<h2 id="displaying-a-static-image"><a class="header" href="#displaying-a-static-image">Displaying a static image</a></h2>
<p>The first goal was to understand U-Boot’s display driver and to set up our memory regions for the frame buffer and the physical devices required by the driver. After building and running the U-Boot example, we looked through the source code and found relevant sections in IMX8M technical specification to get a better understanding of how to write the display driver. We currently rely on the firmware provided by U-Boot which needs to be configured when setting up the development environment.</p>
<p>Through reading the technical specification we learnt that the two main components of the Maaxboard needed for the driver are the DCSS (Display Controller Subsystem) and the HDMI TX Controller. With this information we were able to understand the purpose of the memory register read and write operations and which register bits needed to be set for specific functionality. We decided to use one protection domain for the simplicity of having one area to handle all operations.</p>
<p>After gaining a deeper understanding of Maaxboard and U-Boots implementation, we set values for the essential memory registers including where to set the address of the frame buffer to. For the framebuffer, we defined a region of memory that was large enough for our currently selected screen resolution and bit depth.</p>
<p>In order to read and write from specific memory registers, they must be explicitly defined in the system file for the PD that they are being accessed from. This is an essential concept to grasp when working with microkit. The majority of the code was taken from U-Boot, so the main focus of this part of the task was to set up the parts of the code that directly interfaced with the hardware. For other projects this could include registering and handling interrupts.</p>
<p>Our initial display configuration had a screen resolution of 1280x720 and a colour depth of 32 bit RGB. This meant that each pixel was composed of 32 bits with 8 bits reserved for each colour and an additional alpha channel for colour transparency. With this information, we were able to create a simple image displaying 4 colours red, green, blue and white as 4 equally spaced bars across the screen. We then experimented with different screen resolutions which involved re-defining the size of the framebuffer so that it could accommodate larger screen resolutions.</p>
<h2 id="displaying-a-moving-image"><a class="header" href="#displaying-a-moving-image">Displaying a moving image</a></h2>
<p>The next goal was to display a moving image, which first involved learning about the theory of double buffering and understanding the capabilities of the Maaxboard’s DCSS. Double buffering makes use of two buffers. The first buffer stores the current frame and the second buffer stores the next frame. Whilst the current frame is being displayed the second buffer is being written to. During the window of time where the image on screen is not actively being redrawn, the pointers to each buffer are swapped.</p>
<p>U-Boot’s implementation did not provide any capability to drive video, so we needed to investigate and understand the technical specification in greater detail. We found a component of the DCSS called the Context Loader which can be configured to change various parts of the display state at specific timing intervals. This would act as the trigger to switch the pointers to each frame buffer.</p>
<p>For our implementation we decided to use two PD’s. One PD contains the display driver, consisting of the DCSS and the HDMI TX Controller. The other PD contains the api and examples which demonstrate different use cases of the driver. The system is designed such that the two PD’s communicate with each other through notifications and make use of a single shared DMA memory region. This memory region is split into different parts which are accessed by a pointer with a specific offset for different parts of the memory e.g frame buffer 1, frame buffer 2. This approach was implemented for simplicity so that the memory is easily accessible, however it would be better to define individual DMA regions for specific tasks, so that certain parts of the memory are only exposed to the PD that should have access to it.</p>
<p>The initial time to redraw the buffer was slow because we were writing 8 bits of the 32 bit pixel at a time. To combat this we optimised the code logic reducing loops and where possible, we wrote 16, 32 or 64 bits at a time to minimise the amount of separate cpu instructions. This example is limited by the technology that we have available to us. For fully-fledged display drivers, there will be extra bits of hardware that will be able to handle the different stages of processing video, drastically increasing performance.</p>
<p>For moving images a visible redraw is seen when switching between frames which is most noticeable when the entire screen has changed. Multiple attempts have been made to combat this issue, which have been listed in the repo for this activity.</p>
<p>The API contains the following examples:</p>
<ul>
<li>static_image - Displays 4 colour bars on the screen.</li>
<li>resolution_change - Displays a square of the same size in pixels one after another at three different resolutions.</li>
<li>rotating_bars - Displays 4 colour bars rotating across the screen.</li>
<li>moving_square - A small square that moves around the screen, changing direction each time it hits the side of the screen.</li>
</ul>
<p>Nice to have:</p>
<ul>
<li>Add some more specific code examples (What other things in this process could help someone to do something similar)</li>
<li>Information on how to read the specification to find the memory register and how each memory register is set up, how to toggle bits, read and write to memory etc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-linux-guest"><a class="header" href="#single-linux-guest">Single Linux guest</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>For this task, the goal was to load up a virtual machine (VM) on a host with serial TTY pass-through, so that we could type input to and recive output from the Linux guest. Our starting point for this activity was to rework an example from the Trustworthy Systems Libvmm repository so that it runs on the Maaxboard. This repo contains a virtual machine monitor for the seL4 microkernel with various examples built for the Odroid board and the open source emulator Qemu. Libvmm provides a virtual machine monitor (VMM) which is used to start and manage the guest VM.</p>
<p>The repository for this project is located at: https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-vmm-single-linux-guest</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>One Protection Domain (PD) is used which contains a virtual machine and physical devices such as the UART which are passed through to the Linux guest. This means that no driver code is needed in seL4 as the Linux guest will contain the driver and communicate directly with the Maaxboard's hardware.</p>
<h2 id="buildroot"><a class="header" href="#buildroot">Buildroot</a></h2>
<p>To create the Linux kernel image and the root filesystem we used Buildroot, which is an open source project that automates the process of building a complete and bootable Linux environment for an embedded system. We chose Buildroot because it makes the process to create a basic Linux kernel images straightforward. In this project the Linux kernel image, the root filesystem and the device tree are linked into the PD's image file.</p>
<h2 id="virtual-memory-faults"><a class="header" href="#virtual-memory-faults">Virtual memory faults</a></h2>
<p>The VM doesn’t necessarily know it's being virtualised, so it may try to perform read and write operations on certain devices and memory regions that it doesn’t have access to. When setting up the project there were a number of virtual memory faults, which were caused by the guest VM trying to access devices that it was not exposed to in the system file. Generally, there are three approaches to fix this.</p>
<p>One approach is to disable the device node in the device tree so that it does not try to access the device. This approach may not be feasible because the memory region may be required by a specific process in your system or dependent on another device in order to function. Another approach is to disable the device driver in the guest configuration (This can be configured with Buildroot). The last approach is to utilise device “pass-through” which is where the address of the device is mapped into the guest VM allowing access directly to the device. Ideally, in a virtualised environment the guest VM shouldn’t have access to physical devices. However, for simplicity and with the absence of a serial driver it was necessary to pass through the serial device and the devices that depend on it.</p>
<h2 id="pass-through"><a class="header" href="#pass-through">Pass-through</a></h2>
<p>Two memory regions that are required to be passed through for the use of Libvmm and our example are the RAM and the Generic Interrupt Controller Virtual CPU (GIC-VCPU). In order for the Linux guest to be able to run, it needs to have an area of contiguous space directly allocated for its own RAM. In its current implementation Libvmm expects the physical memory address and the virtual memory area for the RAM to be at the same address. At a minimum there needed to be enough memory to load the kernel image and other associated binaries. The size and position of this memory need to reflect the memory node in the device tree. The GIC-VCPU is used to signal virtual interrupts. Libvmm provides a driver to handle this device which is necessary for running any guest operating system with Libvmm.</p>
<h2 id="memory-considerations-1"><a class="header" href="#memory-considerations-1">Memory considerations</a></h2>
<p>In the current release of Microkit (1.2.6 At the time of writing), the way that Microkit allocates memory for untyped regions is not optimal for large amounts of memory. All of memory, including RAM, is split into regions based on some rules and then Microkit allocates kernel objects from those untypeds. It is thought that the Microkit allocator is for some reason only allocating from a maximum of one untyped for a single allocation. This means that for example, if you want 3GB of RAM then it will be split over a couple of untypeds. So if you're trying to create an MR of 512MiB, and the biggest untyped is only 256MB, then Microkit is failing even though technically there is 3GB of space.</p>
<p>An initramfs (initial ram file system) is used to prepare Linux systems during boot before the init process starts. If the memory allocated for the ram isn't big enough then this process will fail. It is not known why exactly, but currently the size is 0xf000000 because 0x9000000 was too small.</p>
<h2 id="smc-issue"><a class="header" href="#smc-issue">SMC issue</a></h2>
<p>Whilst developing this project, we came across an error when trying to boot up the VM:</p>
<p><code>VMM|ERROR: Unhandled SMC: unknown value service: 0x2, function number: 0x6</code></p>
<p>The MaaxBoard Firmware provides a small set of SiP Function Identifiers. The Linux Driver "drivers/soc/imx/soc-imx8m.c" compatible with "fsl,imx8mp" leverages MaaxBoard Firmware SiP Function Identifier "0xc2000006" to get version information. If SMC properly declares that "0xc2000006" is absent, this would be interpreted as detecting an earlier version of the Board (that lacked the Function Identifier). A work around has been implemented to handle this service which suppresses the error.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/sel4devkit/sel4devkit-maaxboard-linux-guest/blob/main/doc/MANUAL.md">Buildroot</a> - Buildroot configuration</li>
<li>https://github.com/au-ts/Libvmm - Libvmm repository</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vmm-with-dual-linux-guests-and-tty-multiplex"><a class="header" href="#vmm-with-dual-linux-guests-and-tty-multiplex">VMM with dual linux guests and TTY Multiplex</a></h1>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>For this activity the goal was to load two Linux Virtual Machines (VM) on one host. We built upon our previous single guest example and took inspiration from an existing libvmm contribution that makes use of VirtIO console.</p>
<p>The repository for this project is located at: https://github.com/sel4devkit/sel4devkit-maaxboard-microkit-vmm-dual-linux-guest-tty-multiplex</p>
<h2 id="design-1"><a class="header" href="#design-1">Design</a></h2>
<p>For this example five Protection Domains (PD) are used. Two PD’s are used for each virtual machine, one for the UART serial driver and the remaining two for the transmit (TX) and receive (RX) communication channels to handle the serial data. Input is routed to only one virtual machine and output from both VM's is seen regardless of which VM is currently being controlled. Currently there are only two VM's set up, but this can be tweaked to have multiple VM's running simultaneously.</p>
<h3 id="rx"><a class="header" href="#rx">RX</a></h3>
<p>For RX communication, an interrupt is generated by a key press that is processed by the driver. The driver then adds the keypress to a shared queue and notifies the RX PD to read from the queue and place the key press into a new shared queue with the virtual machine PD. The RX PD will then notify the virtual machine PD that there is data in the queue. In the virtual machine PD this then notifies the VirtIO console to handle the RX data ready to be processed in the guest VM.</p>
<h3 id="tx"><a class="header" href="#tx">TX</a></h3>
<p>For TX communication, the Linux guest puts data in a shared queue through VirtIO. The virtual machine PD receives a notification from the guest and the data is read from the queue and placed in a shared queue with TX PD. A notification is then sent to the TX PD so that it can read this data and place it in a shared queue with the driver. The driver then reads the data from the queue and outputs it to the hosts serial port.</p>
<h2 id="virtio"><a class="header" href="#virtio">VirtIO</a></h2>
<p>VirtIO is an interface used by virtual machines to use its hosts’ devices through the means of virtual devices. The main role of these devices is to get data to and from the hosts physical hardware. VirtIO consists of three main parts: front-end drivers, back-end devices, and VirtQueues.</p>
<h3 id="front-end-drivers"><a class="header" href="#front-end-drivers">Front-end drivers</a></h3>
<p>Typically, the front-end drivers exist in the hosts kernel. These can be turned on in the config file when creating a linux kernel with buildroot. They are responsible for accepting I/O requests from user processes, transfering I/O requests to its corresponding back-end VirtIO device and retrieving completed requests from the back-end device.</p>
<h3 id="back-end-devices"><a class="header" href="#back-end-devices">Back-end devices</a></h3>
<p>The back-end devices typically exist in the VMM. Libvmm provides implementations for console, network, block and sound devices. They are responsible for accepting I/O requests from the corresponding front-end driver,handling the requests by offloading the I/O operations to the host’s physical hardware, and making the processed and requested data available to the VirtIO driver.</p>
<h3 id="virtqueues"><a class="header" href="#virtqueues">VirtQueues</a></h3>
<p>VirtQueues are shared memory regions that are used by a VirtIO front-end driver and back-end device pair. A VRing is a data structure contained within the VirtQueue that facilitates data transfer between the VirtIO device and driver. Libvmm follows version 1.2 of the VirtIO specification and uses the seL4 Device Driver Framework (SDDF) to implement the VirtQueues for specific devices.</p>
<h3 id="virtio-console"><a class="header" href="#virtio-console">VirtIO Console</a></h3>
<p>In our example we make use of the VirtIO Console device to handle serial I/O data. To use VirtIO Console a node was created in the device tree and a multiple settings turned on in the Linux kernel config file. In the “chosen” node of the device tree, the stdout path and the boot arguemnts also needed to be set up specifically for the console device. In our initial implementation we passed through 8 additional devices. We then managed to remove the need for 7 of them by disabling them in the device tree. The remaining “gpc” device was needed by VirtIO Console, but at this stage it is not known why.</p>
<h2 id="timing-considerations"><a class="header" href="#timing-considerations">Timing considerations</a></h2>
<p>If the two virtual machine PD's have a different priority then the highest priority VM will be loaded first and there will be a long wait (&gt;10 minutes) before control is relinquished to the lower priority VM. To resolve this issue, both of the Virtual machine PD's were made the same priority. Although it is not an issue, this results in the output being muddled together because both VM's output is shown simultaneously.</p>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li>https://github.com/au-ts/libvmm - Libvmm repository</li>
<li><a href="https://blogs.oracle.com/linux/post/introduction-to-virtio">virtio oracle webiste</a> - For more information on VirtIO</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dual-linux-guest-with-usb-routing"><a class="header" href="#dual-linux-guest-with-usb-routing">Dual Linux Guest with USB routing</a></h1>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>In this activity we explored different options for USB routing. Largely, the need for USB routing comes from virtualisation, where the physical hardware has the physical USB port, and there is a virtual system that we wish the USB port is routed into. In our case we are working towards routing a USB device into one of multiple virtual machines (VM).</p>
<h2 id="usb-ip"><a class="header" href="#usb-ip">USB IP</a></h2>
<p>USB/IP Project to develops a general USB device sharing system over an IP network. It uses TCP/IP payloads to transmit USB I/O messages between two different computers. We ran a preconfigured Linux natively on the Maaxboard, which included USB IP functionality. We then connected to another server running Linux and routed the USB keyboard traffic from the Maaxboard to it over IP.</p>
<p>The next goal was to load a virtual Linux guest on the Maaxboard and pass through USB data to the guest. We were unable to transfer the data from the guest to another server because because the ethernet pass-through was not working properly. We have been notified that a newer version of Microkit may solve this issue. This exercise demonstrated the use of USB IP and helped us understand how to preconfigure a Linux kernel to include specific functionality.</p>
<h2 id="virtio-net"><a class="header" href="#virtio-net">VirtIO Net</a></h2>
<p>At the time of writing, the libvmm VirtIO Net contribution is still being developed. For our implementation we will rework the relevant parts of the example to work with our devkit setup using the Maaxboard. The Protection Domain (PD) structure will be similar to the VirtIO console implementation with specific net RX and TX queues and an Ethernet driver. In the console example the multiplexing is done in the driver code, but for this example a "vswitch" is implemented in its own PD to handle the switching between the different VM's. This “vswitch” code appears to be in the SDDF repository, so it will be important to make sure these projects are synced up correctly. Also, the TX and RX queues will be implemented with net specific functions from the SDDF.</p>
<p>The Ethernet device will need to be disabled in the device tree and an extra node for VirtIO Net will need to be added. Further investigation will need to be done to see if there are any other changes to the device tree that need to be made, such as changes to the boot arguments. Once VirtIO Net is available we will be able to extend our previous dual guest example such that the two VM's can communicate via IP. At this stage there would not be any USB routing, but it demonstrates a solution to communicate IP data between two VM's.</p>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>The exploration into USB IP gave us understanding on how we could send USB data between two instances of Linux. In theory we should be able to plug a USB device to the Maaxboard and pass it through to 1 of the Linux guests. If only one VM was given pass-through to the USB device then this VM could act as the USB IP "server" and using VirtIO Net it could route the USB traffic to the other VM over IP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="licensing"><a class="header" href="#licensing">Licensing</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
