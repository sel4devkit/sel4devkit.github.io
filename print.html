<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>seL4 Developer Kit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A developer kit for the seL4 microkernel on the Avnet MaaXBoard SBC (Single Board Computer).">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/audience.html"><strong aria-hidden="true">1.1.</strong> Audience</a></li><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="introduction/structure.html"><strong aria-hidden="true">1.3.</strong> Structure</a></li></ol></li><li class="chapter-item expanded "><a href="resources/main.html"><strong aria-hidden="true">2.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/sel4_microkernel.html"><strong aria-hidden="true">2.1.</strong> seL4 Microkernel</a></li><li class="chapter-item expanded "><a href="resources/avent_maaxboard.html"><strong aria-hidden="true">2.2.</strong> Avent MaaXBoard</a></li><li class="chapter-item expanded "><a href="resources/repositories.html"><strong aria-hidden="true">2.3.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="resources/glossary.html"><strong aria-hidden="true">2.4.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="development_platform/main.html"><strong aria-hidden="true">3.</strong> Development Platform</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development_platform/hardware_requirements.html"><strong aria-hidden="true">3.1.</strong> Hardware Requirements</a></li><li class="chapter-item expanded "><a href="development_platform/software_requirements.html"><strong aria-hidden="true">3.2.</strong> Software Requirements</a></li></ol></li><li class="chapter-item expanded "><a href="install_and_configure/main.html"><strong aria-hidden="true">4.</strong> Install and Configure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install_and_configure/host_setup.html"><strong aria-hidden="true">4.1.</strong> Host Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/build_environment_setup.html"><strong aria-hidden="true">4.2.</strong> Build Environment Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/target_setup.html"><strong aria-hidden="true">4.3.</strong> Target Setup</a></li><li class="chapter-item expanded "><a href="install_and_configure/bootloader_setup.html"><strong aria-hidden="true">4.4.</strong> Bootloader Setup</a></li></ol></li><li class="chapter-item expanded "><a href="first_boot/main.html"><strong aria-hidden="true">5.</strong> First Boot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_boot/bootloader.html"><strong aria-hidden="true">5.1.</strong> Bootloader</a></li><li class="chapter-item expanded "><a href="first_boot/sel4test.html"><strong aria-hidden="true">5.2.</strong> seL4Test</a></li><li class="chapter-item expanded "><a href="first_boot/camkes_adder.html"><strong aria-hidden="true">5.3.</strong> CAmkES Adder</a></li><li class="chapter-item expanded "><a href="first_boot/microkit_hello_world.html"><strong aria-hidden="true">5.4.</strong> Microkit Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="activities/main.html"><strong aria-hidden="true">6.</strong> Activities</a></li><li class="chapter-item expanded "><a href="activity/microkit_memory_probe/main.html"><strong aria-hidden="true">7.</strong> Activity: Microkit Memory Probe</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/main.html"><strong aria-hidden="true">8.</strong> Activity: Device Drivers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="activity/device_drivers/device_driver_intro.html"><strong aria-hidden="true">8.1.</strong> Device Driver Introduction</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_driver_library.html"><strong aria-hidden="true">8.2.</strong> U-Boot Driver Library Overview</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_driver_usage.html"><strong aria-hidden="true">8.3.</strong> Using the U-Boot Driver Library</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_library_add_platform.html"><strong aria-hidden="true">8.4.</strong> Library Extension - New Platform</a></li><li class="chapter-item expanded "><a href="activity/device_drivers/uboot_library_add_driver.html"><strong aria-hidden="true">8.5.</strong> Library Extension - New Driver</a></li></ol></li><li class="chapter-item expanded "><a href="activity/spi_bus_bmp280_pressure_sensor/main.html"><strong aria-hidden="true">9.</strong> Activity: SPI Bus BMP280 Pressure Sensor</a></li><li class="chapter-item expanded "><a href="activity/camkes_case_study_application/main.html"><strong aria-hidden="true">10.</strong> Activity: CAmkES Case Study Application</a></li><li class="chapter-item expanded "><a href="activity/microkit_case_study_application/main.html"><strong aria-hidden="true">11.</strong> Activity: Microkit Case Study Application</a></li><li class="chapter-item expanded "><a href="activity/microkit_usb_driver/main.html"><strong aria-hidden="true">12.</strong> Activity: Microkit USB Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_hdmi_driver/main.html"><strong aria-hidden="true">13.</strong> Activity: Microkit HDMI Driver</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_single_linux_guest/main.html"><strong aria-hidden="true">14.</strong> Activity: Microkit VMM Single Linux Guest</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_tty_multiplex/main.html"><strong aria-hidden="true">15.</strong> Activity: Microkit VMM Dual Linux Guest TTY Multiplex</a></li><li class="chapter-item expanded "><a href="activity/microkit_vmm_dual_linux_guest_usb_routing/main.html"><strong aria-hidden="true">16.</strong> Activity: Microkit VMM Dual Linux Guest USB Routing</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="licensing.html">Licensing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">seL4 Developer Kit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sel4devkit/sel4devkit-manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <a href="https://sel4.systems">seL4® Microkernel</a> is a technology of
increasing interest. It delivers specific capabilities and assurances, which
make it particularly suitable for applications that demand a trusted execution
environment and strong separation of concerns.</p>
<p>The seL4 Microkernel is engineered to deliver both high-assurance and
high-performance (<a href="https://sel4.systems/About/seL4-whitepaper.pdf">The seL4 Microkernel: An
Introduction</a>). High-assurance
is achieved through comprehensive formal verification. High-performance is
achieved through deliberate design and profiling, potentially accepting
greater complexity in the formal verification where this achieves higher
performance.</p>
<p>The development of the seL4 Microkernel is overseen by the <a href="https://sel4.systems/Foundation/">seL4
Foundation</a>, operating as project under The
<a href="https://www.linuxfoundation.org/">Linux Foundation</a>. The entirety of the seL4
Microkernel, and its associated components, are made available as Open Source,
on Git Hub (<a href="https://github.com/seL4">seL4 Microkernel and associated
components</a>).</p>
<p>In common with all Microkernels, the seL4 Microkernel provides a minimum set
of essential features as needed to frame a viable OS (Operating System). There
is an expectation that further components will be introduced atop this OS, in
developing useful applications (such as drivers, libraries, and services).</p>
<p>As a consequence, developing on top of the seL4 microkernel is currently
complex and time-consuming, and the expertise is limited to a small number of
individuals and organisations. Thus, this seL4 Developer Kit is created to
reduce the barrier to entry for developing on top of seL4 Microkernel. The
overall intention is to encourage and support more organisations in adopting
seL4 in their projects and products.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="audience"><a class="header" href="#audience">Audience</a></h2>
<p>The intended audience is an application developer:</p>
<ul>
<li>Experienced in programming within a Linux, macOS, or Windows environment.</li>
<li>Already familiar with seL4 concepts and benefits.</li>
<li>Looking for practical guidance in getting started with seL4.</li>
</ul>
<h3 id="complementary-approach"><a class="header" href="#complementary-approach">Complementary Approach</a></h3>
<p>This seL4 Developer Kit does not intend to cover or replace any of the
extensive material as maintained by the (<a href="https://sel4.systems">seL4
Foundation</a>) and associated organisations.</p>
<p>Instead, the purpose is to complement this existing material with practical
guidance about getting started with seL4. Throughout the seL4 Developer Kit,
reference is made to externally maintained material where appropriate.</p>
<h3 id="focus-on-sel4-details"><a class="header" href="#focus-on-sel4-details">Focus on seL4 Details</a></h3>
<p>Whilst the seL4 Developer Kit aims to cover all the important configuration
steps, it does assume a reasonable level of developer knowledge. In general,
priority and prominence is given to seL4 specific details, while more routine
aspects are explained at a higher level or through external reference (such as
installing software or interacting with configuration management).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The seL4 Developer Kit intends to support developers in gaining familiarity
with seL4 Microkernel, and ultimately to encourage more use of seL4 within
projects and products. It does this by:</p>
<ul>
<li>
<p>Selecting a readily available low-cost SBC (Single Board Computer) as the
target platform ((The <a href="introduction/%22../avent_maaxboard/main.html">Avnet MaaXBoard</a>).</p>
</li>
<li>
<p>Identifying the minimum needed to create a viable development platform, and
detailing specific hardware and software requirements to achieve this.</p>
</li>
<li>
<p>Supplying preconfigured build environments, plus associated examples, with
all the content required to generate seL4 executable programs.</p>
</li>
<li>
<p>Demonstrating how an seL4 executable program can be loaded and executed on
the chosen target platform.</p>
</li>
<li>
<p>Documenting the specific steps needed, along with more general guidance.</p>
</li>
</ul>
<p>Once the fundamentals of building and executing an seL4 program are
established, the seL4 Developer Kit seeks to explain and encourage further
development through the presentation of a diverse series of technical
(<a href="introduction/%22../activities/activities.html">Activities</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The seL4 Developer Kit is structured into the following sections to provide a
step-by-step guide:</p>
<ul>
<li>
<p><strong>Introduction</strong>: Introduce the potential benefits that the seL4 Microkernel
offers, acknowledge its steep learning curve, and position the seL4
Developer Kit as a means to help facilitate and encourage wider adoption.</p>
</li>
<li>
<p><strong>Resources</strong>: Provides an overview of the fundamental aspects of both the
seL4 Microkernel and the Avent MaaXBoard (our chosen SBC (Single Board
Computer)), highlighting relevant supporting material from other sources. The
technical scope of the seL4 Developer Kit is summerised though a list of its
associated repositories. Finally, a consolidated glossary of key terms is
presented for easy reference.</p>
</li>
<li>
<p><strong>Development Platform</strong>: Identify and explain the minimum hardware and
software requirements needed to assemble a viable development platform for
using the seL4 Developer Kit. It is expected that, to meet these requirements,
some equipment will need to be purchased (for example, an Avent MaaXBoard).</p>
</li>
<li>
<p><strong>Install and Configure</strong>: Provides guidance, and explores options, in
installing and configuring the development platform. Once complete, the
development platform will be ready for building sel4 programs, loading such
programs onto the target, and executing these programs on the target, with
terminal (text) input and output available.</p>
</li>
<li>
<p><strong>First Boot</strong>: Utilising a previously prepared development platform, walk
through the steps in powering up the target (Avnet MaaXBoard), interacting
with the bootloader, and building and executing a small number of example
programs. On completion of this step, the development platform is prepared and
proven to operate.</p>
</li>
<li>
<p><strong>Activities</strong>: With the development platform established, a series of
distinct technical activities are undertaken. Each Activity describes both
its approach, and the eventual outcome, seeking to illustrate how sel4
development may be practically progressed.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>Presents for immediate reference a summary of the various resources associated
with seL4 Developer Kit.</p>
<h1 id="supporting-material"><a class="header" href="#supporting-material">Supporting Material</a></h1>
<p>The seL4 Developer Kit makes use of a large collection of existing material.
Here, we summarise and reference this material, explaining its relevance to
the seL4 Developer Kit.</p>
<p>Distinct areas considered are listed below:</p>
<ul>
<li><a href="resources/%22../resources/sel4_microkernel.html">seL4 Microkernel</a></li>
<li><a href="resources/%22../resources/avent_maaxboard.html">Avent MaaXBoard</a></li>
</ul>
<h1 id="repositories"><a class="header" href="#repositories">Repositories</a></h1>
<p>A summarised list of all the repositories that form part of the seL4 Developer
Kit is presented to support their navigation:</p>
<ul>
<li><a href="resources/reference/repositories.html">Repositories</a></li>
</ul>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>A consolidated glossary of key terms is presented for easy reference:</p>
<ul>
<li><a href="resources/reference/glossary.html">Glossary</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-1"><a class="header" href="#resources-1">Resources</a></h1>
<p>Presents for immediate reference a summary of the various resources associated
with seL4 Developer Kit.</p>
<h1 id="supporting-material-1"><a class="header" href="#supporting-material-1">Supporting Material</a></h1>
<p>The seL4 Developer Kit makes use of a large collection of existing material.
Here, we summarise and reference this material, explaining its relevance to
the seL4 Developer Kit.</p>
<p>Distinct areas considered are listed below:</p>
<ul>
<li><a href="resources/%22../resources/sel4_microkernel.html">seL4 Microkernel</a></li>
<li><a href="resources/%22../resources/avent_maaxboard.html">Avent MaaXBoard</a></li>
</ul>
<h1 id="repositories-1"><a class="header" href="#repositories-1">Repositories</a></h1>
<p>A summarised list of all the repositories that form part of the seL4 Developer
Kit is presented to support their navigation:</p>
<ul>
<li><a href="resources/reference/repositories.html">Repositories</a></li>
</ul>
<h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<p>A consolidated glossary of key terms is presented for easy reference:</p>
<ul>
<li><a href="resources/reference/glossary.html">Glossary</a></li>
</ul>
<p>shaped in terms of a large collection of existing
material in framinig a</p>
<p>deliver a</p>
<p>brings together a large collection of existing
material, for the s</p>
<p>built can be framed as</p>
<p>brings together a large collection of</p>
<p>is built atop many</p>
<p>intends to support developers in gaining familiarity</p>
<p>There
An overview
We present a</p>
<ul>
<li>
<p><strong>seL4 Microkernel</strong>: A consolidated overview of the fundamental aspects of
the seL4 Microkernel, highlighting relevant material available from other
sources.</p>
</li>
<li>
<p><strong>Avent MaaXBoard</strong>: Explain the selection of our chosen SBC (Single Board
Computer), providing a consolidated overview of its core features,
highlighting relevant material available from other sources.</p>
</li>
</ul>
<p>The <a href="https://sel4.systems">seL4® Microkernel</a> is a technology of
increasing interest. It delivers specific capabilities and assurances, which
make it particularly suitable for applications that demand a trusted execution
environment and strong separation of concerns.</p>
<p>The seL4 Microkernel is engineered to deliver both high-assurance and
high-performance (<a href="https://sel4.systems/About/seL4-whitepaper.pdf">The seL4 Microkernel: An
Introduction</a>). High-assurance
is achieved through comprehensive formal verification. High-performance is
achieved through deliberate design and profiling, potentially accepting
greater complexity in the formal verification where this achieves higher
performance.</p>
<p>The development of the seL4 Microkernel is overseen by the <a href="https://sel4.systems/Foundation/">seL4
Foundation</a>, operating as project under The
<a href="https://www.linuxfoundation.org/">Linux Foundation</a>. The entirety of the seL4
Microkernel, and its associated components, are made available as Open Source,
on Git Hub (<a href="https://github.com/seL4">seL4 Microkernel and associated
components</a>).</p>
<p>In common with all Microkernels, the seL4 Microkernel provides a minimum set
of essential features as needed to frame a viable OS (Operating System). There
is an expectation that further components will be introduced atop this OS, in
developing useful applications (such as drivers, libraries, and services).</p>
<p>As a consequence, developing on top of the seL4 microkernel is currently
complex and time-consuming, and the expertise is limited to a small number of
individuals and organisations. Thus, this seL4 Developer Kit is created to
reduce the barrier to entry for developing on top of seL4 Microkernel. The
overall intention is to encourage and support more organisations in adopting
seL4 in their projects and products.</p>
<p>highlighting relevant material available from other
sources.</p>
<ul>
<li><strong>Avent MaaXBoard</strong>: Explain the selection of our chosen SBC (Single Board
Computer), providing a consolidated overview of its core features,
highlighting relevant material available from other sources.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-1"><a class="header" href="#todo-1">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-2"><a class="header" href="#todo-2">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-platform"><a class="header" href="#development-platform">Development Platform</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-boot"><a class="header" href="#first-boot">First Boot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-setup"><a class="header" href="#host-setup">Host Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-environment-setup"><a class="header" href="#build-environment-setup">Build Environment Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup"><a class="header" href="#bootloader-setup">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootloader-setup-1"><a class="header" href="#bootloader-setup-1">Bootloader Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="activities"><a class="header" href="#activities">Activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-3"><a class="header" href="#todo-3">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-drivers"><a class="header" href="#device-drivers">Device Drivers</a></h1>
<ul>
<li><a href="activity/device_drivers/%22device_driver_intro.html">Device Driver Introduction</a></li>
<li><a href="activity/device_drivers/%22uboot_driver_library.html">U-Boot Driver Library Overview</a></li>
<li><a href="activity/device_drivers/%22uboot_driver_usage.html">Using the U-Boot Driver Library</a></li>
<li><a href="activity/device_drivers/%22uboot_library_add_platform.html">Library Extension - New Platform</a></li>
<li><a href="activity/device_drivers/%22uboot_library_add_driver.html">Library Extension - New Driver</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-driver-introduction"><a class="header" href="#device-driver-introduction">Device Driver Introduction</a></h1>
<p>This section seeks to provide guidance on adding device drivers to seL4.</p>
<p>It should be noted that seL4 runs all device drivers in user mode; device support is therefore not the kernel’s problem.</p>
<p>This guide focuses on methods, complete with an extensive worked example, for adding device support to seL4.</p>
<p>The following sections describe the creation of an extensible library for seL4 allowing U-Boot device drivers to function under seL4 with either minimal or no modifications. As an example of its usage, the library provides an extensive set of device drivers for the Avnet MaaXBoard (support for USB, Ethernet, SD/MMC, I<sup>2</sup>C, GPIO, IOMUX, Clock and SPI devices). Guidance on the extension of this library to support other platforms and devices is also provided.</p>
<p>This guide provides guidance on adding device drivers atop of both the CAmkES and Microkit frameworks.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The goal of this guide is to lower the barrier to entry for the use of seL4. One such barrier is device driver support for seL4, both the relatively limited device driver support as well as the difficulty in the creation of new device drivers.</p>
<p>To help overcome this barrier, this guide attempts to provide a route for adding device support to seL4 with minimal effort and technical challenges. This goal has resulted in the following decisions and priorities being taken:</p>
<ol>
<li>
<p>A focus on porting existing open source device drivers from other projects (e.g. Linux or U-Boot) over the writing of new device drivers; detailed guidance on the writing of new device drivers is outside the scope of this guide.</p>
</li>
<li>
<p>Methods of porting that allow devices to be supported with minimal effort, e.g. minimising changes to driver source code, have been prioritised over factors such as performance and support for all features.</p>
</li>
<li>
<p>Consideration for device driver formal verification has not been applied. No guarantee of correctness, security, or anything else is given for the drivers ported, or the method described.</p>
</li>
</ol>
<h2 id="porting-drivers"><a class="header" href="#porting-drivers">Porting Drivers</a></h2>
<p>Device drivers can be ported from any source where the device driver source code is available under a suitable license. The most obvious such sources are Linux and U-Boot, both of which contain a very large selection of open source device drivers. It is suggested that porting drivers from U-Boot is easier than porting drivers from Linux for the following reasons:</p>
<ul>
<li>
<p>Porting a device driver requires either the driver to be made to function independently from the driver framework of its source project, or for the source project's driver framework to be made to function within seL4. The U-Boot driver framework is significantly less complex and extensive than the Linux driver framework.</p>
</li>
<li>
<p>U-Boot device drivers tend to be significantly simpler than device drivers found in Linux. This is because the use cases of a bootloader such as U-Boot do not require high performance, fully-featured drivers. Indeed it can be seen that many of the U-Boot device drivers are in fact actively simplified versions of Linux drivers that have been ported to the U-Boot driver framework.</p>
</li>
</ul>
<p>In line with the goals stated above this guide therefore focuses on the porting of drivers from U-Boot to seL4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u-boot-driver-library-overview"><a class="header" href="#u-boot-driver-library-overview">U-Boot Driver Library Overview</a></h1>
<p>To achieve the goals specified in <a href="activity/device_drivers/device_driver_intro.html">device driver introduction</a> section, an extensible library of device drivers ported from U-Boot has been created. This library provides an extensive set of drivers for the Avnet MaaXBoard platform as a worked example of its usage. The library is supported by documentation in the following sections on usage, maintenance, and guidance on the extension of the library to support additional platforms and devices.</p>
<p>Information on the design and structure of the library is provided under the following sections:</p>
<ul>
<li><a href="activity/device_drivers/uboot_driver_library.html#design-summary">Design Summary</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#build-system">Build System</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#library-limitations">Library Limitations</a></li>
<li><a href="activity/device_drivers/uboot_driver_library.html#code-structure">Code Structure</a></li>
</ul>
<h2 id="design-summary"><a class="header" href="#design-summary">Design Summary</a></h2>
<p>The primary goal of the library is to allow drivers from U-Boot to be used within seL4 with minimal or no code changes. To support this goal, the library comprises:</p>
<ul>
<li>
<p>A set of U-Boot drivers.</p>
</li>
<li>
<p>The U-Boot <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/index.html">Driver Model</a> driver framework and associated subsystems required to support device drivers.</p>
</li>
<li>
<p>Stubbed versions of U-Boot subsystems providing a compatibility / conversion layer between the U-Boot source code and underlying seL4 libraries.</p>
</li>
<li>
<p>A wrapper around the U-Boot code to provide an API for users of the library to interact with devices and manage library initialisation / shutdown.</p>
</li>
</ul>
<p>It should be noted that the library works with the intended security and isolation of seL4; capabilities to permit access to hardware devices and provide sufficient resources (e.g. heap and DMA memory) must be granted to components/protection domains using the library.</p>
<h2 id="detailed-design-information"><a class="header" href="#detailed-design-information">Detailed Design Information</a></h2>
<p>The following sections provide details on the design of stub or wrapper elements that are significant to support the functioning of the drivers within the Driver Model framework.</p>
<h3 id="linker-lists"><a class="header" href="#linker-lists">Linker Lists</a></h3>
<p>To allow variable levels of functionality to be built into a U-Boot executable, U-Boot utilises a concept of <a href="https://u-boot.readthedocs.io/en/latest/api/linker_lists.html">linker-generated arrays</a>. These are arrays of objects (e.g. drivers, supported commands, driver classes, etc.) which are stored by U-Boot within dedicated linker sections to be queried at runtime.</p>
<p>Access to the objects stored within these linker sections is provided by U-Boot through a set of macros defined in the <code>linker_lists.h</code> header file.</p>
<p>To mimic this functionality within the library, the following approach has been taken:</p>
<ol>
<li>
<p>Rather than storing the objects within linker sections of the executable, a global variable named <code>driver_data</code> is declared within <code>driver_data.h</code> which contains the equivalent object arrays.</p>
</li>
<li>
<p>During initialisation of the library, the platform-dependent contents of the <code>driver_data</code> global variable are set up.</p>
</li>
<li>
<p>A stubbed version of the <code>linker_lists.h</code> header file is provided. Rather than accessing data from the executable's linker sections as performed by the original version, the stubbed version accesses data from the arrays within the <code>driver_data</code> global variable.</p>
</li>
</ol>
<h3 id="global-data"><a class="header" href="#global-data">Global Data</a></h3>
<p>U-Boot maintains a <a href="https://u-boot.readthedocs.io/en/latest/develop/global_data.html">global data</a> structure for the storage of globally required fields.</p>
<p>The macro <code>DECLARE_GLOBAL_DATA_PTR</code> is used by U-Boot to provide a pointer to this data structure. On most architectures this pointer is stored in a dedicated register (e.g. register <code>x18</code> on ARM64); such a mechanism is not compatible with seL4.</p>
<p>Within the library the following approach has been taken to global data:</p>
<ol>
<li>
<p>A stub of the <code>global_data.h</code> header file has been provided to provide the macro <code>DECLARE_GLOBAL_DATA_PTR</code> as a pointer to a global variable.</p>
</li>
<li>
<p>At initialisation of the library, memory for the global data structure is allocated and initialised as follows:</p>
<ul>
<li>Most elements are unused and set to null values.</li>
<li>The global status <code>flags</code> are set up to mimic an instance of U-Boot that has been relocated to, and is executing from, RAM.</li>
<li>Pointers to the flattened device tree are setup to point to seL4's device tree.</li>
<li>A <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html">live device tree</a> is built from the flattened device tree and referenced.</li>
</ul>
</li>
</ol>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p>The U-Boot code expects to have access to a high-frequency, monotonic timer. The timer is accessed by the U-Boot source code through calls to routines <code>get_ticks</code>, <code>get_timer_*</code> and <code>timer_get_*</code>.</p>
<p>Provision of such a timer is platform dependent. For the Avnet MaaXBoard the timer has been implemented through use of the System Counter (SYS_CON) device provided by the iMX8MQ SoC; see file <code>timer_imx8mq.c</code> for details.</p>
<h3 id="memory-mapped-io"><a class="header" href="#memory-mapped-io">Memory Mapped IO</a></h3>
<p>One of the core mechanisms for providing a software interface to a hardware device is through the use of <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped IO</a>.</p>
<p>The memory addresses that a U-Boot driver uses for communication with a device can be either read from the device tree (i.e. from a device's <code>reg</code> property) or in some cases can be hard-coded into the driver.</p>
<p>At this point it should be noted that U-Boot source code is intended to be executed in an environment with direct access to the system's physical address space; however, the library is executed within a virtual address space provided by seL4. As such, the addresses used by U-Boot drivers are <em>physical</em> addresses which are not directly accessible by the library. To work around this issue:</p>
<h4 id="camkes"><a class="header" href="#camkes">CAmkES</a></h4>
<ol>
<li>
<p>During library initialisation the list of all platform-dependent devices that need to be accessed must be provided. For each device:</p>
<ul>
<li>The device's physical address range is read from the device tree.</li>
<li>The device's physical address range is mapped into the virtual address space through use of the IO mapping routines provided by seL4's platform support library.</li>
<li>The mapping between the physical address range and the mapped virtual address range is stored within the <code>sel4_io_map</code> package (part of the library's wrapper functionality).</li>
</ul>
</li>
<li>
<p>When a driver attempts to perform memory mapped IO it calls architecture-dependent routines from the <code>io.h</code> header, e.g. <code>readl</code> or <code>writel</code>. A stubbed version of the <code>io.h</code> header is provided that uses the <code>sel4_io_map</code> package to translate the physical addresses provided by the driver to the equivalent address mapped into the library's virtual address space.</p>
</li>
</ol>
<p>U-Boot drivers performing memory mapped IO should perform seamlessly without the need for any modifications to the driver.</p>
<h4 id="microkit"><a class="header" href="#microkit">Microkit</a></h4>
<p>The physical addresses of all platform-dependent devices must be provided in the system file in this format:</p>
<pre><code>&lt;system&gt;
    &lt;memory_region name="&lt;physical_device_name&gt;" size="&lt;physical_device_size&gt;" phys_addr="&lt;physical_device address&gt;"/&gt;
    ...
    &lt;protection_domain name="&lt;PD name&gt;"&gt;
      &lt;map mr="&lt;physical_device_name&gt;" vaddr="&lt;virtual_map_address&gt;" perms="rw" cached="false"/&gt;
      ...
   &lt;/protection_domain&gt;
&lt;/system&gt;
</code></pre>
<h3 id="dma"><a class="header" href="#dma">DMA</a></h3>
<p>As for <a href="activity/device_drivers/uboot_driver_library.html#memory-mapped-io">memory mapped IO</a>, it should be noted that U-Boot source code expects to be executed in an environment with direct access to the system's physical address space; however the library is executed within a virtual address space provided by seL4.</p>
<p>This can lead to U-Boot drivers that are executed within seL4 erroneously providing a <em>virtual</em> memory address to devices as the address to use for a DMA transfer; DMA transfers performed by devices can only be performed to <em>physical</em> addresses.</p>
<p>To support this issue, the library:</p>
<ol>
<li>
<p>Provides the <code>sel4_dma</code> package as part of its wrapper, which:</p>
<ul>
<li>Provides memory allocation / deallocation routines that utilise the underlying DMA functions provided by seL4's platform support library;</li>
<li>Maintains a mapping between the physical and virtual addresses, and provides routines to perform address translations;</li>
<li>Provides routines to perform flushing and invalidation of the allocated DMA regions.</li>
</ul>
</li>
<li>
<p>Provides an implementation of Linux's <code>dma_mapping.h</code> interface via the <code>sel4_dma</code> package.</p>
</li>
<li>
<p>Provides modifications to the XHCI USB stack, as used by USB 3.0 devices, intended to cover all DMA issues related to <em>users</em> of the USB stack (e.g. keyboard, mouse, or mass storage devices).</p>
</li>
</ol>
<p>It is an unfortunate fact that drivers utilising DMA may require manual modifications to function correctly:</p>
<ul>
<li>
<p>Drivers that use the DMA interface exported by <code>dma-mapping.h</code> should work without modification; drivers ported to U-Boot from Linux have been seen to use this interface. Examples of device drivers for the Avnet MaaXBoard using the <code>dma-mapping.h</code> DMA interface are the USB driver and the SD/MMC driver.</p>
</li>
<li>
<p>Drivers that do not use the DMA interface exported by <code>dma-mapping.h</code> will need to be modified to use the API exported by the <code>sel4_dma</code> wrapper package. An example of a device driver for the Avnet MaaXBoard that required manual modifications is the Ethernet driver (see <code>fec_mxc.c</code>).</p>
</li>
</ul>
<h3 id="console"><a class="header" href="#console">Console</a></h3>
<p>A minimal stub of U-Boot's console subsystem has been provided (see <code>console.c</code>). This stub provides the subset of functionality required to allow input and output devices to be registered and accessed by the driver library.</p>
<p>It should be noted that the console subsystems's <code>stdout</code> file is not used by the library; instead all output is routed directly to the C library output routines.</p>
<p>The console subsystem's <code>stdin</code> file, however, is used. For example, if a USB keyboard is registered with the console as the <code>stdin</code> device then subsequent calls to retrieve input from <code>stdin</code> will return keypresses that are input from the USB keyboard.</p>
<h3 id="standard-output-and-logging"><a class="header" href="#standard-output-and-logging">Standard Output and Logging</a></h3>
<p>The wrapper header file <code>uboot_print.h</code> provides a set of macros that map:</p>
<ul>
<li>All U-Boot standard output routines onto calls to the C library <code>printf</code> routine.</li>
<li>All U-Boot logging routines onto the seL4 platform support library <code>ZF_LOG*</code> routines at an equivalent logging level or <code>UBOOT_LOG</code> routines for Microkit.</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>As part of library initialisation, any U-Boot subsystems that require explicit initialisation are handled (see <code>uboot_wrapper.c:initialise_uboot_wrapper</code>). This mimics the initialisation that would normally be performed by <a href="https://github.com/u-boot/u-boot/blob/master/common/board_r.c">U-Boot's start-up routine</a>.</p>
<p>Initialisation of the library comprises:</p>
<h4 id="camkes-1"><a class="header" href="#camkes-1">CAmkES</a></h4>
<ul>
<li>Initialisation of the memory mapped IO and DMA wrappers;</li>
<li>Initialisation of the monotonic timer;</li>
<li>Initialisation of the Linker Lists data structure;</li>
<li>Initialisation of the Global Data data structure;</li>
<li>Initialisation of U-Boot's Environment subsystem (manages storage of environment variables);</li>
<li>Initialisation of U-Boot's Driver Model subsystem;</li>
<li>Initialisation of U-Boot's MMC subsystem (if SD/MMC drivers are used by the platform);</li>
<li>Initialisation of U-Boot's Network subsystem (if Ethernet drivers are used by the platform).</li>
</ul>
<p>When calling the <code>initialise_uboot_wrapper</code> routine the following must be provided:</p>
<ul>
<li>The I/O operations data structure from the platform support library. These routines enable the library to access the seL4 device tree and to perform memory mapping and DMA operations. The routines are provided by CAmkES on creation of a single threaded component.</li>
<li>The list of device tree paths containing physical addresses to be memory mapped (through the <code>reg</code> property).</li>
<li>The list of device tree paths for the devices to enable. Note that all sub-nodes of the device tree paths will be automatically enabled; only the root node for the required devices need to be listed. All other nodes in the device tree will be marked as disabled.</li>
</ul>
<h4 id="microkit-1"><a class="header" href="#microkit-1">Microkit</a></h4>
<ul>
<li>Initialisation of the DMA wrappers;</li>
<li>Initialisation of the monotonic timer;</li>
<li>Initialisation of the Linker Lists data structure;</li>
<li>Initialisation of the Global Data data structure;</li>
<li>Initialisation of U-Boot's Environment subsystem (manages storage of environment variables);</li>
<li>Initialisation of U-Boot's Driver Model subsystem;</li>
<li>Initialisation of U-Boot's MMC subsystem (if SD/MMC drivers are used by the platform);</li>
<li>Initialisation of U-Boot's Network subsystem (if Ethernet drivers are used by the platform).</li>
</ul>
<p>When calling the <code>initialise_uboot_wrapper</code> routine the following must be provided:</p>
<ul>
<li>A DMA manager which can be initialised with a call to the <code>microkit_dma_manager</code> routine.</li>
<li>A pointer to the device tree blob.</li>
<li>The list of device tree paths for the devices to enable. Note that all sub-nodes of the device tree paths will be automatically enabled; only the root node for the required devices need to be listed. All other nodes in the device tree will be marked as disabled.</li>
</ul>
<p>A worked example for use of the <code>initialise_uboot_wrapper</code> routine is provided by the <a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example"><code>uboot-driver-example</code> test application</a> for the Avnet MaaXBoard.</p>
<h2 id="build-system"><a class="header" href="#build-system">Build System</a></h2>
<p>U-Boot is, by necessity, highly configurable in terms of which functionality is included in a build and the configuration of default values / settings. The U-Boot source code relies upon a KConfig build system that results in the definition of a set of macros (typically named <code>CONFIG_xxx</code>), together with the identification of the required source code files, to manage this configuration; however, seL4 relies upon the CMake build system. To resolve this issue the following approach has been taken:</p>
<ol>
<li>
<p>Macros that are expected to be consistent across all platforms, e.g. those supporting the basic U-Boot subsystem configuration that the library relies upon, are defined in the <code>uboot_helper.h</code> header file within the library's wrapper.</p>
</li>
<li>
<p>All other configuration, i.e. macros, includes and sources files, are controlled by the library's CMake file (<code>CMakeLists.txt</code>).</p>
</li>
</ol>
<p>As such all architecture and platform dependent configuration is encapsulated within the library's CMake file. The general structure of this file is as follows:</p>
<ul>
<li>
<p>A section controlling architecture dependent settings. The settings necessary for ARM-based platforms (both ARMv7 and ARMv8) have been provided.</p>
</li>
<li>
<p>A section controlling platform dependent settings. This contains platform-specific macros, identification of drivers supporting the platform, and setup of platform specific header files.</p>
</li>
<li>
<p>One section for each class of device (e.g. clock devices, USB devices, etc.). For each class of device the generic settings are provided (i.e. settings required irrespective of the chosen driver) as well as the settings provided for each supported driver.</p>
</li>
<li>
<p>A section controlling configuration consistent across all architectures and platforms, e.g. the set of source files required by all platforms.</p>
</li>
</ul>
<p>This modular structure of the CMake file is intended to allow for the library to be incrementally extended, i.e. through the addition of support for new architectures, platforms, device classes and drivers.</p>
<h2 id="library-limitations"><a class="header" href="#library-limitations">Library Limitations</a></h2>
<p>Users of the library should be aware of its limitations, and potential workarounds for those limitations.</p>
<ol>
<li>
<p><strong>Thread safety</strong>: The library is not thread safe; as such it is the responsibility of the user to serialise access to any single instance of the library. Note, however, that multiple instances of the library may be used. For example, two instances of the library could be used concurrently, each held within separate CAmkES components/ Microkit protection domains. If multiple instances of the library are used, it is the responsibility of the user to ensure that each instance is using disjoint devices, i.e. two instances of the library would not both be able to access the same USB device; however, it should be possible for one instance to access an Ethernet device whilst a second instance accesses a USB device (see the <a href="activity/device_drivers/case_study_intro.html">case study application</a> for an example of this).</p>
</li>
<li>
<p><strong>Performance</strong>: Do not expect great performance from the library. The underlying U-Boot drivers have tended to prioritise simplicity over performance; for example the SPI driver for the Avnet MaaXBoard does not support the use of DMA transfers even though the underlying device can perform DMA transfers. Additionally, the library wrapper adds additional layers of address translations and data copying (e.g. in its support of memory mapped IO and DMA) as part of the trade-off for minimising changes necessary to the U-Boot drivers.</p>
</li>
<li>
<p><strong>U-Boot Live Device Tree</strong>: The decision has been taken for the library to utilise U-Boot's modern <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html">live device tree</a> functionality to read device tree properties rather than the historical <code>fdtdec</code> interface. Whilst this should result in improved long term support for the library, it may be necessary to make minor changes to a driver when porting an old driver to the live device tree interface. Porting is a simple activity and guidance is provided <a href="https://u-boot.readthedocs.io/en/latest/develop/driver-model/livetree.html#porting-drivers">here</a>.</p>
</li>
<li>
<p><strong>Interrupt Handling</strong>: The device drivers provided by U-Boot generally do not support interrupt handling; instead they rely on busy-waiting / polling of devices. There is, however, no inherent reason preventing the use of interrupt handlers. Should use of interrupt handling be required then it would need to be added by the user to the driver and the library's API would need to be enhanced to support such functionality.</p>
</li>
<li>
<p><strong>ARM Power Domains</strong>: ARM power domains are controlled through calls to the ARM Trusted Firmware (ATF). Accessing the ATF from within seL4 is not currently supported due to the need for elevated privileges. It is instead suggested that the power domains should be set as required during execution of the bootloader prior to seL4's startup. On the Avnet MaaXBoard, for example, power domains need to be enabled to power the USB PHY; therefore the USB devices need to be probed from the U-Boot bootloader prior to starting seL4 to ensure they are powered.</p>
</li>
</ol>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>The library code is held within the following structure:</p>
<pre><code class="language-text">libubootdrivers
│
├───include
│   ├───plat
│   ├───public_api
│   └───wrapper
│
├───src
│   ├───plat
│   ├───timer
│   └───wrapper
│
├───uboot
│
└───uboot_stub
</code></pre>
<p>The following conventions are maintained for each folder name:</p>
<ul>
<li><strong>plat</strong>: Folders holding platform specific source files. Contains one subfolder per platform.</li>
<li><strong>public_api</strong>: Holds header files defining the library's publicly accessible API.</li>
<li><strong>wrapper</strong>: Bespoke code written for the library.</li>
<li><strong>timer</strong>: Timer driver source code.</li>
<li><strong>uboot</strong>: A symlink to an unmodified, or minimally modified, fork of the U-Boot project. Note that the build system is responsible for creation of the symlink; for the <a href="activity/device_drivers/uboot_driver_usage.html">example test applications</a> the symlink is created by the <code>repo</code> tool.</li>
<li><strong>uboot_stub</strong>: Holds library specific replacements for U-Boot source code. Internal folder structure mirrors U-Boot code structure.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-u-boot-driver-library"><a class="header" href="#using-the-u-boot-driver-library">Using the U-Boot Driver Library</a></h1>
<p>This section outlines the library's API and provides instructions for running two test applications that demonstrate use of its drivers.</p>
<ul>
<li><a href="activity/device_drivers/uboot_driver_usage.html#library-api">Library API</a></li>
<li><a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example">Test application: <code>uboot-driver-example</code></a></li>
<li><a href="activity/device_drivers/uboot_driver_usage.html#test-application-picoserver_uboot">Test application: <code>picoserver_uboot</code></a></li>
</ul>
<h2 id="library-api"><a class="header" href="#library-api">Library API</a></h2>
<p>At the core of the library's public API (see library folder <code>include/public_api</code> for full details) are:</p>
<ul>
<li>
<p>Routines to initialise (<code>initialise_uboot_drivers</code>) and shutdown (<code>shutdown_uboot_drivers</code>) the library that must book-end the usage of all other API routines;</p>
</li>
<li>
<p>A routine (<code>run_uboot_command</code>) to allow execution of the same textual commands as used at the <a href="activity/device_drivers/first_boot.html#boot-to-u-boot-prompt">U-Boot prompt</a>. For example, in the <a href="activity/device_drivers/uboot_library_add_driver.html#establishing-the-driver-api">I<sup>2</sup>C worked example</a>, it is shown how the U-Boot <code>i2c</code> command is added and used, e.g. to probe the bus.</p>
</li>
</ul>
<p>Although this provides a relatively simple API, it is intuitive as it has a direct analogue to the commands available at the U-Boot command line. There are limitations, but the API can be readily developed further to expose more functionality, for example:</p>
<ul>
<li>
<p>To accept arguments through parameter passing rather than through a textual command;</p>
</li>
<li>
<p>To return data or results rather than printing outcomes to the console;</p>
</li>
<li>
<p>To expose lower-level interfaces than the U-Boot commands permit, for example access to raw Ethernet frames.</p>
</li>
</ul>
<p>It is expected that the source code of the U-Boot commands are likely to provide a starting point for extended API routines.</p>
<p>A number of worked examples have been provided for extensions to the core API described above:</p>
<ul>
<li>
<p>For accessing the <code>stdin</code> file maintained by U-Boot, routines <code>uboot_stdin_&lt;...&gt;</code> have been provided to enable testing whether characters are available and to retrieve them. The <code>uboot-driver-example</code> test application demonstrates usage of these API routines for retrieving characters typed on a connected USB keyboard.</p>
</li>
<li>
<p>For reading and sending raw Ethernet frames, routines <code>uboot_eth_&lt;...&gt;</code> have been provided. The <code>picoserver_uboot</code> test application demonstrates usage of these API routines to integrate the library with the picoTCP stack.</p>
</li>
</ul>
<p>Sections below give a basic overview of the test applications and how to build and run them.</p>
<h2 id="test-application-uboot-driver-example"><a class="header" href="#test-application-uboot-driver-example">Test application: <code>uboot-driver-example</code></a></h2>
<h3 id="overview-of-the-uboot-driver-example-test-application"><a class="header" href="#overview-of-the-uboot-driver-example-test-application">Overview of the <code>uboot-driver-example</code> test application</a></h3>
<p>The source file at <code>camkes/apps/uboot-driver-example/components/Test/src/test.c</code>/ <code>microkit/example/maaxboard/uboot-driver-example/uboot-driver-example.c</code> represents the script for the test application. It contains <code>run_uboot_cmd("...")</code> calls to U-Boot commands that are supported by the library. The set of supported commands can be readily seen in the <code>cmd_tbl</code> entries of <code>projects_libs/libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code> or <code>microkit/libubootdrivers/include/plat/maaxboard/plat_driver_data.h</code>.</p>
<p>It is left to the reader to look through the test script in detail, but the features demonstrated include the following.</p>
<ul>
<li>The MaaXBoard's two integral LEDs are toggled.</li>
<li>Ping operations.</li>
<li>USB operations<sup class="footnote-reference"><a href="#1">1</a></sup>, including:
<ul>
<li>identify and list (<code>ls</code>) the contents of a USB flash drive, if connected;</li>
<li>read and echo keypresses from a USB keyboard, if connected, during a defined period.</li>
</ul>
</li>
<li>SD/MMC operations to identify and list (<code>ls</code>) the contents of the SD card.</li>
<li>Filesystem operations to write a file to a FAT partition on the SD card before reading the contents back and deleting the file.</li>
<li>I<sup>2</sup>C operations to probe the bus and read the power management IC present on the MaaXBoard's I<sup>2</sup>C bus. (There are more details in the <a href="activity/device_drivers/appendices/add_driver_worked_example.html">worked example</a> that walks through the steps that were required to add this driver.)</li>
<li>SPI operations to access the SPI bus and read a BMP280 pressure sensor, if connected.
<ul>
<li>Procuring and connecting this sensor is an optional extra, described in the <a href="activity/device_drivers/appendices/spi_bmp280.html">SPI Bus Pressure Sensor appendix</a>; otherwise these operations still run but return nothing in the test application.</li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note: Currently, only the upper USB port on the Avnet MaaXBoard is active (i.e. the port furthest away from the PCB); the lower USB port does not function. This is a feature of the power domains on the board, not the USB driver.</p>
</div>
<p>Other utility commands are exercised, such as <code>dm tree</code>, which is useful to follow the instantiation of device drivers, and <code>clocks</code> which lists all the available clocks. As well as 'headline' drivers like USB and SPI above, there are also some fundamental 'building block' drivers in the library, for elements such as clocks, IOMUX, and GPIO, which are needed by other drivers.</p>
<h4 id="configuration-for-different-platforms"><a class="header" href="#configuration-for-different-platforms">Configuration for different platforms</a></h4>
<p>Although <code>uboot-driver-example</code> was created to demonstrate the device drivers developed for this MaaXBoard developer kit, it is configurable to support other platforms. For example, in the <a href="activity/device_drivers/appendices/add_odroidc2.html">worked example appendix for the Odroid-C2</a>, a small subset of drivers has been developed for that platform, and the <code>test.c</code> source file for <code>uboot-driver-example</code> uses the preprocessor macros <code>CONFIG_PLAT_MAAXBOARD</code> and <code>CONFIG_PLAT_ODROIDC2</code> to configure which commands are run for each platform. By default, all tests are enabled for an unrecognised platform, but this would be readily configured for a new platform's <code>CONFIG_PLAT_...</code> preprocessor macro.</p>
<h3 id="instructions-for-running-uboot-driver-example-camkes"><a class="header" href="#instructions-for-running-uboot-driver-example-camkes">Instructions for running <code>uboot-driver-example</code> (CAmkES)</a></h3>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_test
cd /host/uboot_test
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The test application includes an Ethernet operation (<code>ping</code>) with hard-coded IP addresses; these need to be customised for an individual's environment. The following lines of the source file <code>projects/camkes/apps/uboot-driver-example/components/Test/src/test.c</code> should be edited:</p>
<pre><code class="language-c">run_uboot_command("setenv ipaddr xxx.xxx.xxx.xxx"); // IP address to allocate to MaaXBoard
run_uboot_command("ping yyy.yyy.yyy.yyy"); // IP address of host machine
</code></pre>
<p>Optionally, to <code>ping</code> to an address beyond the local network:</p>
<pre><code class="language-c">run_uboot_command("setenv gatewayip zzz.zzz.zzz.zzz"); // IP address of router
run_uboot_command("setenv netmask 255.255.255.0");
run_uboot_command("ping 8.8.8.8"); // An example internet IP address (Google DNS)
</code></pre>
<p>From the <code>/host/uboot_test</code> directory, execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=uboot-driver-example -DPLATFORM=maaxboard -DSIMULATION=FALSE
</code></pre>
<pre><code class="language-bash">ninja
</code></pre>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<h3 id="instructions-for-running-uboot-driver-example-microkit"><a class="header" href="#instructions-for-running-uboot-driver-example-microkit">Instructions for running <code>uboot-driver-example</code> (Microkit)</a></h3>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_test
cd /host/uboot_test
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4-cap/seL4-dev-kit-microkit-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>The test application includes an Ethernet operation (<code>ping</code>) with hard-coded IP addresses; these need to be customised for an individual's environment. The following lines of the source file <code>microkit/example/maaxboard/uboot-driver-example/uboot-driver-example.c</code> should be edited:</p>
<pre><code class="language-c">run_uboot_command("setenv ipaddr xxx.xxx.xxx.xxx"); // IP address to allocate to MaaXBoard
run_uboot_command("ping yyy.yyy.yyy.yyy"); // IP address of host machine
</code></pre>
<p>Optionally, to <code>ping</code> to an address beyond the local network:</p>
<pre><code class="language-c">run_uboot_command("setenv gatewayip zzz.zzz.zzz.zzz"); // IP address of router
run_uboot_command("setenv netmask 255.255.255.0");
run_uboot_command("ping 8.8.8.8"); // An example internet IP address (Google DNS)
</code></pre>
<p>From the <code>/host/uboot_test/microkit</code> directory, execute the following command:</p>
<pre><code class="language-bash">./init-build.sh -DMICROKIT_APP=uboot-driver-example -DPLATFORM=maaxboard
</code></pre>
<p>A successful build will result in an executable file called <code>sel4_image</code> in the <code>microkit/example/maaxboard/uboot-driver-example/example-build</code> subdirectory. This file should be made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<h2 id="test-application-picoserver_uboot"><a class="header" href="#test-application-picoserver_uboot">Test application: <code>picoserver_uboot</code></a></h2>
<h3 id="overview-of-the-picoserver_uboot-test-application"><a class="header" href="#overview-of-the-picoserver_uboot-test-application">Overview of the <code>picoserver_uboot</code> test application</a></h3>
<p>It is not the purpose of this developer kit to give a CAmkES tutorial (e.g. see <a href="https://docs.sel4.systems/projects/camkes/">seL4's documentation</a>), but this application is based on the following CAmkES model:</p>
<p><img src="activity/device_drivers/figures/picoserver-camkes.png" alt="Picoserver CAmkES overview" /></p>
<p>EthDriverUboot is a simple implementation of an Ethernet driver that has been ported from U-Boot. PicoServer provides a picoTCP TCP/IP stack on top of this, and the Echo component simply listens on port 1234 of a given IP address, echoing received characters on the display. (An additional component TimeServer has been omitted from the diagram for clarity, but see the <a href="activity/device_drivers/case_study_intro.html">case study application</a> for more details.)</p>
<h3 id="instructions-for-running-picoserver_uboot"><a class="header" href="#instructions-for-running-picoserver_uboot">Instructions for running <code>picoserver_uboot</code></a></h3>
<p>As usual, this assumes that the user is already running a Docker container within the <a href="activity/device_drivers/build_environment_setup.html">build environment</a>, where we can create a directory and clone the code and dependencies.</p>
<pre><code class="language-text">mkdir /host/uboot_pico
cd /host/uboot_pico
</code></pre>
<pre><code class="language-bash">repo init -u https://github.com/sel4devkit/camkes-manifest.git
</code></pre>
<pre><code class="language-bash">repo sync
</code></pre>
<p>From the <code>/host/uboot_pico</code> directory, execute the following commands:</p>
<pre><code class="language-text">mkdir build
cd build
</code></pre>
<pre><code class="language-bash">../init-build.sh -DCAMKES_APP=picoserver_uboot -DPLATFORM=maaxboard -DSIMULATION=FALSE -DPICOSERVER_IP_ADDR=xxx.xxx.xxx.xxx
ninja
</code></pre>
<p>where <code>xxx.xxx.xxx.xxx</code> is the IP address to allocate to the MaaXBoard.</p>
<p>A successful build will result in an executable file called <code>capdl-loader-image-arm-maaxboard</code> in the <code>images</code> subdirectory. This should be copied to a file named <code>sel4_image</code> and then made available to the preferred loading mechanism, such as TFTP, as per <a href="activity/device_drivers/execution_on_target_platform.html">Execution on Target Platform</a>.</p>
<p>When the <code>picoserver_uboot</code> application is running on the MaaXBoard, it should confirm that it is listening on port 1234 of the supplied IP address. It will also confirm registration of the protocol stack layers. The application allocates a random MAC address.</p>
<p>At any time while running, the application may display <code>No such port ....</code> messages as it monitors traffic on the network; this is expected behaviour that may be ignored.</p>
<p>Meanwhile, from a terminal window on the host machine, use the <code>netcat</code> (<code>nc</code>) command (native to Linux or macOS, or available as a <a href="https://nmap.org/ncat/">download</a> for Windows), where <code>xxx.xxx.xxx.xxx</code> is the IP address of the MaaXBoard, as previously specified:</p>
<pre><code class="language-bash">nc xxx.xxx.xxx.xxx 1234
</code></pre>
<p>On the MaaXBoard (via CoolTerm as usual), a message like the following should be seen:</p>
<pre><code class="language-text">echo: Connection established with yyy.yyy.yyy.yyy on socket 1
</code></pre>
<p>where <code>yyy.yyy.yyy.yyy</code> is the IP address of the host machine.</p>
<p>From the host machine's terminal, strings may be typed until <code>nc</code> is terminated with Ctrl-C:</p>
<pre><code class="language-bash">hostmachine ~ % nc 192.168.0.111 1234
Hello world!
Goodbye
^C
hostmachine ~ %
</code></pre>
<p>Each time carriage return is entered, the <code>picoserver_uboot</code> application will display the string, until the <code>nc</code> session is terminated, upon which the connection will be closed:</p>
<pre><code class="language-text">echo: Connection established with 192.168.0.11 on socket 1
echo: Received message of length 13 --&gt; Hello world!
echo: Received message of length 8 --&gt; Goodbye
echo: Connection closing on socket 2
echo: Connection closed on socket 2
</code></pre>
<p>Connections can be re-established simply by issuing another <code>nc</code> command.</p>
<h4 id="implementation-note"><a class="header" href="#implementation-note">Implementation note</a></h4>
<p>Connecting, disconnecting, and reconnecting to a network can give rise to delays in the order of a few minutes while the elements in the network handshake and resynchronise, particularly in the case of our application, which assigns a random MAC address to the same IP address each time it runs. If the connection is not established promptly, the easiest remedial options are:</p>
<ul>
<li>Start from a clean reboot of the host machine (which will include flushing its DNS cache); or</li>
<li>Be patient! (If you are prepared to wait for a few minutes, the connection will be made. Note that <code>nc</code> may timeout after a while if no connection is made, so the command would need to be repeated.)</li>
</ul>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<ul>
<li><a href="activity/device_drivers/./appendices/spi_bmp280.html">SPI Bus Pressure Sensor</a></li>
<li><a href="activity/device_drivers/./appendices/add_odroidc2.html">Odroid-C2 Worked Example</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-platform"><a class="header" href="#library-extension---new-platform">Library Extension - New Platform</a></h1>
<p>This section documents the required actions and guidance to add support for a new platform to the library.</p>
<p>By the end of this section, an seL4 executable will be built for the new platform that can initialise the library (although the library may not support any of the platform's devices). Later sections of this guide cover the required actions to add driver support into the library for the new platform (e.g. see the <a href="activity/device_drivers/add_odroidc2.html">Odroid-C2 worked example</a>).</p>
<p>Throughout the sections of this guide devoted to extension of the U-Boot driver library, it is expected the developer is working within the folder structure created by the <code>repo</code> tool (e.g. as used to build the <a href="activity/device_drivers/uboot_driver_usage.html">test applications</a>). Key folders and files within the hierarchy are shown below:</p>
<h3 id="camkes-2"><a class="header" href="#camkes-2">CAmkES</a></h3>
<pre><code class="language-text">&lt;manifest root&gt;
|
├───kernel
│   └───tools
│       └───dts
│
└───projects
    ├───camkes
    │   └───apps
    │       └───uboot-driver-example
    │           └───include
    │               └───plat
    │                   └───&lt;platform name&gt;
    │                       └───platform_devices.h
    │
    ├───projects_libs
    │   └───libubootdrivers
    │       ├───include
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.h
    │       ├───src
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.c
    │       └───CMakeLists.txt
    │
    └───uboot
</code></pre>
<ul>
<li><code>kernel/tools/dts</code>: Location of platform device trees.</li>
<li><code>projects/project_libs/camkes/apps/uboot-driver-example</code>: <a href="activity/device_drivers/uboot_driver_usage.html">The test application</a>.</li>
<li><code>projects/project_libs/libubootdrivers</code>: Referred to as "the library" throughout. See <a href="https://github.com/sel4devkit/projects_libs/tree/master/libubootdrivers">linked Git repository</a>.</li>
<li><code>projects/uboot</code>: Fork of the U-Boot project source code (note, this is also symlinked to <code>projects/project_libs/libubootdrivers/uboot</code>).</li>
</ul>
<h3 id="microkit-2"><a class="header" href="#microkit-2">Microkit</a></h3>
<pre><code class="language-text">&lt;manifest root&gt;
|
└───microkit
    ├───include
    │   └───&lt;platform&gt;
    │       └───all_platform_devices.h
    │
    ├───libubootdrivers
    │       ├───include
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.h
    │       ├───src
    │       │   └───plat
    │       │       └───&lt;platform name&gt;
    │       │           └───plat_driver_data.c
    │       └───CMakeLists.txt
    │
    ├───boards
    │      └───&lt;platform&gt;.dts
    │ 
    ├───example
    │   └───&lt;platform&gt;
    │       └───uboot-driver-example
    │
    └───uboot
</code></pre>
<ul>
<li><code>microkit/boards</code>: Location of platform device trees.</li>
<li><code>example/&lt;platform&gt;/uboot-driver-example</code>: <a href="activity/device_drivers/uboot_driver_usage.html">The test application</a>.</li>
<li><code>microkit/libubootdrivers</code>: Referred to as "the library" throughout. See <a href="https://github.com/sel4-cap/dev-kit-libs/tree/main/libubootdrivers">linked Git repository</a>.</li>
<li><code>microkit/uboot</code>: Fork of the U-Boot project source code (note, this is also symlinked to <code>microkit/libubootdrivers/uboot</code>).</li>
</ul>
<h2 id="required-reading"><a class="header" href="#required-reading">Required Reading</a></h2>
<p>The developer should be familiar with the following tools and concepts in order to add platform and driver support to the library.</p>
<ul>
<li>
<p><em>Device Tree</em>: An introduction to device tree data is <a href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html">provided by the Linux documentation</a> and by the <a href="https://docs.zephyrproject.org/2.6.0/guides/dts/intro.html">Zephyr project</a>.</p>
</li>
<li>
<p><em>CMake</em>: Reference documentation is provided by <a href="https://cmake.org/cmake/help/latest/">the CMake project</a>, including details of the structure and syntax of the CMakeLists.txt file.</p>
</li>
<li>
<p><em>CAmkES</em>: The seL4 foundation provides <a href="https://docs.sel4.systems/projects/camkes/">documentation on its use of CAmkES</a> including tutorials.</p>
</li>
<li>
<p><em>Microkit</em>: The seL4 foundation provides <a href="https://github.com/seL4/microkit/blob/main/docs/manual.md">documentation on its use of Microkit</a> including tutorials.</p>
</li>
</ul>
<h2 id="add-basic-support-to-library"><a class="header" href="#add-basic-support-to-library">Add basic support to library</a></h2>
<p>To allow the library to be successfully compiled for a new platform, the following changes will need to be made to the library.</p>
<h3 id="update-the-librarys-cmake-file-to-support-the-platform"><a class="header" href="#update-the-librarys-cmake-file-to-support-the-platform">Update the library's CMake file to support the platform</a></h3>
<p>The library's CMake file (located at <code>projects/project_libs/libubootdrivers/CMakeLists.txt</code> or <code>microkit/libubootdrivers/CMakeLists.txt</code>) contains a section titled <code>Platform specific settings</code> to control the settings for each platform. This section:</p>
<ol>
<li>
<p>Declares a set of variables to control which drivers and optional capabilities are to be built for each platform. The default values produce a build including only a dummy timer driver; this is the minimum necessary to allow the library to be built.</p>
</li>
<li>
<p>Provides a conditional block of settings associated with each supported platform, e.g. to control which of the supported drivers to build. If no conditional block is supplied for a platform, the compilation of the library fails and an error message is returned.</p>
</li>
</ol>
<p>The minimal change to this section that allows the library to be built is therefore the inclusion of a conditional block for the platform, even if that section makes no changes to the default settings. For example, to add support for a platform that is named  <code>foo</code> within the seL4 build system, the following changes would be required:</p>
<pre><code class="language-makefile">    # Set up the applicable drivers and platform dependent configuration.
    if(KernelPlatImx8mq)
        ...
+   elseif("${KernelPlatform}" STREQUAL "foo")
+       # Platform specific settings for the Foo board.
    else()
        message(FATAL_ERROR "Unsupported platform. Aborting.")
    endif()
</code></pre>
<p>Note that where settings are shared across multiple platforms, this logic can be simplified to reflect the shared settings. An example of this is provided in the library's <code>CMakeLists.txt</code> for the <code>maaxboard</code> and <code>imx8mq-evk</code> platforms, which both use the iMX8MQ SoC.</p>
<p>It should also be noted that U-Boot drivers can support multiple devices. For example, many of the drivers added to support the Avnet MaaXBoard support multiple iMX SoCs. If previously supported drivers are compatible with the new platform, this support can be added now; for example, if platform <code>foo</code> has a GPIO device supported by the <code>gpio_mxc</code> driver (as used by the Avnet MaaXBoard), then the line <code>set(gpio_driver "gpio_mxc")</code> could be added to the <code>foo</code> platform's settings to enable support.</p>
<p>To enable access to platform specific header files it is necessary to create a symlink within the U-Boot code structure named <code>arch</code> to one of the many <code>arch-xxx</code> folders provided by U-Boot; this mimics an equivalent action taken by U-Boot's native build system. As an example it can be seen that for the iMX8MQ based platforms the <code>arch</code> symlink points to the <code>arch-imx8m</code> folder. It is expected that identification of the correct folder to link to will in most cases will be possible through naming convention alone. To definitively determine the folder to link, the symlink created during a build of U-Boot could be inspected.</p>
<h3 id="define-platform-specific-linker-lists-data-structure"><a class="header" href="#define-platform-specific-linker-lists-data-structure">Define platform specific Linker Lists data structure</a></h3>
<p>As documented within the <a href="activity/device_drivers/uboot_driver_library.html#linker-lists">Linker Lists section of the library overview</a>, the library requires a global data structure named <code>driver_data</code> to be declared to allow the U-Boot source code to access optional functionality included in the executable.</p>
<p>To define <code>driver_data</code> for the new platform, new platform-specific files must be added to the library. The code blocks that follow provide minimal templates for these files that include the base device classes, drivers for those classes, and base commands that are required by all platforms.</p>
<p>File <code>include/plat/foo/plat_driver_data.h</code>:</p>
<pre><code class="language-c">/*
 * This file defines which drivers, driver classes, driver entries and commands
 * are to be included in the compiled library for this platform.
 *
 * This allows only the drivers compatible with the targeted platform to be
 * included with all non-compatible drivers excluded.
 *
 * It should be noted that some of these are fundamental to allowing the U-Boot
 * driver model to function (e.g. the nop, root and simple bus drivers).
 */

/* Define the number of different driver elements to be used on this platform */
#define _u_boot_uclass_driver_count     5
#define _u_boot_driver_count            2
#define _u_boot_usb_driver_entry_count  0
#define _u_boot_part_driver_count       0
#define _u_boot_cmd_count               3
#define _u_boot_env_driver_count        0
#define _u_boot_env_clbk_count          0
#define _u_boot_driver_info_count       0
#define _u_boot_udevice_count           0

/* Define the uclass drivers to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_uclass_driver_count */
extern struct uclass_driver _u_boot_uclass_driver__nop;
extern struct uclass_driver _u_boot_uclass_driver__root;
extern struct uclass_driver _u_boot_uclass_driver__simple_bus;
extern struct uclass_driver _u_boot_uclass_driver__phy;
extern struct uclass_driver _u_boot_uclass_driver__blk;

/* Define the drivers to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_driver_count */
extern struct driver _u_boot_driver__root_driver;
extern struct driver _u_boot_driver__simple_bus;

/* Define the driver entries to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_usb_driver_entry_count */

/* Define the disk partition types to be used. The count of declarations
 * in this section must match the value of _u_boot_part_driver_count */

/* Define the u-boot commands to be used on this platform. The count of declarations
 * in this section must match the value of _u_boot_cmd_count */
extern struct cmd_tbl _u_boot_cmd__dm;
extern struct cmd_tbl _u_boot_cmd__env;
extern struct cmd_tbl _u_boot_cmd__setenv;

/* Define the u-boot environment variables callbacks to be used on this platform. The
 * count of declarations in this section must match the value of _u_boot_env_clbk_count */
</code></pre>
<p>File <code>src/plat/foo/plat_driver_data.c</code>:</p>
<pre><code class="language-c">#include &lt;uboot_helper.h&gt;
#include &lt;driver_data.h&gt;

#include &lt;dm/device.h&gt;
#include &lt;dm/uclass.h&gt;
#include &lt;dm/platdata.h&gt;
#include &lt;usb.h&gt;
#include &lt;part.h&gt;

void initialise_driver_data(void) {
    /* The number of elements in the uclass_driver_array must match the
     * _u_boot_uclass_driver_count constant (see plat_driver_data.h) */
    driver_data.uclass_driver_array[0]  = _u_boot_uclass_driver__nop;
    driver_data.uclass_driver_array[1]  = _u_boot_uclass_driver__root;
    driver_data.uclass_driver_array[2]  = _u_boot_uclass_driver__simple_bus;
    driver_data.uclass_driver_array[3]  = _u_boot_uclass_driver__phy;
    driver_data.uclass_driver_array[4]  = _u_boot_uclass_driver__blk;

    /* The number of elements in the driver_array must match the
     * _u_boot_driver_count constant (see plat_driver_data.h) */
    driver_data.driver_array[0]  = _u_boot_driver__root_driver;
    driver_data.driver_array[1]  = _u_boot_driver__simple_bus;

    /* The number of elements in the cmd_array must match the
     * _u_boot_cmd_count constant (see plat_driver_data.h) */
    driver_data.cmd_array[0]  = _u_boot_cmd__dm;
    driver_data.cmd_array[1]  = _u_boot_cmd__env;
    driver_data.cmd_array[2]  = _u_boot_cmd__setenv;
}
</code></pre>
<p>As support for additional optional objects (e.g. drivers, driver classes, commands, etc.) are added for a platform, these files will be updated to reference the associated objects. See the files for the Avnet MaaXBoard platform for an example of these how these files provide more extensive support.</p>
<h2 id="add-support-to-example-application"><a class="header" href="#add-support-to-example-application">Add support to example application</a></h2>
<p>Section <a href="activity/device_drivers/uboot_driver_usage.html">Using the U-Boot Driver Library</a> introduced the demonstration application  <code>uboot-driver-example</code>. This section documents the changes required to the <code>uboot-driver-example</code> application to allow it to be built for the new platform.</p>
<p>The following empty template file needs to be added to the application <code>include/plat/foo/platform_devices.h</code>:</p>
<h3 id="camkes-3"><a class="header" href="#camkes-3">CAmkES</a></h3>
<pre><code class="language-c">#pragma once

/* List the set of device tree paths that include the 'reg' entries
 * for memory regions that will need to be mapped */
#define REG_PATHS {};
#define REG_PATH_COUNT 0

/* List the set of device tree paths for the devices we wish to access.
 * Note these need to be the root nodes of each device to be accessed */
#define DEV_PATHS {};
#define DEV_PATH_COUNT 0

/* Provide the hardware settings for CAmkES. Note that we only need to inform
 * CAmkES of the devices with memory mapped regions, i.e. the REG_xxx
 * devices. See https://docs.sel4.systems/projects/camkes for syntax */

#define HARDWARE_INTERFACES

#define HARDWARE_COMPOSITION

#define HARDWARE_CONFIGURATION
</code></pre>
<h3 id="microkit-3"><a class="header" href="#microkit-3">Microkit</a></h3>
<pre><code class="language-c">#pragma once

/* List the set of device tree paths that include the 'reg' entries
 * for memory regions that will need to be mapped */
#define REG_PATHS {};
#define REG_PATH_COUNT 0

/* List the set of device tree paths for the devices we wish to access.
 * Note these need to be the root nodes of each device to be accessed */
#define DEV_PATHS {};
#define DEV_PATH_COUNT 0
</code></pre>
<p>As support for devices is added for a platform, this file will be updated to reference those devices from the platform's device tree. See the file for the Avnet MaaXBoard platform for an example that provides more extensive support.</p>
<h2 id="guidance-on-next-steps"><a class="header" href="#guidance-on-next-steps">Guidance on next steps</a></h2>
<p>At this point, the library should compile cleanly for the new platform but will fail during library initialisation due to no devices being supplied.</p>
<p>The order in which drivers need to be added is likely to depend on the intended usage of the library; e.g. support for a single device or support for multiple devices, and the internal needs of the device drivers to be added.</p>
<p>The following drivers are likely to form the core of the support for a platform and underpin the capabilities of other drivers. It may be possible to support some devices without these core drivers, but that would need to checked on a case-by-case basis.</p>
<h3 id="timer-1"><a class="header" href="#timer-1">Timer</a></h3>
<p>As documented <a href="activity/device_drivers/uboot_driver_library.html#timer">in the library overview</a>, some U-Boot drivers rely upon access to a monotonic timer to underpin their timing needs.</p>
<p>By default a platform will be supported by the <code>dummy</code> timer driver (see library file <code>src/timer/timer_dummy.c</code>). Whilst the dummy timer driver allows the library to build cleanly, it will raise an assertion error / exception, thereby halting execution, should any of the timing routines be used. Some simple drivers (e.g. GPIO drivers) typically do not require any timing routines and so can be supported without the need to provide a functional timer; however, a functional timer will typically need to be provided to support more complex devices such as Ethernet or USB.</p>
<p>The means of providing a timer driver is architecture- and platform-dependent, so detailed guidance cannot be provided. A worked example of a timer driver for the iMX8MQ SoC is provided in file <code>src/timer/timer_imx8mq.c</code>; it is expected that this driver could be extended to cover multiple iMX SoCs.</p>
<h3 id="clock"><a class="header" href="#clock">Clock</a></h3>
<p>The U-Boot <code>CLK</code> subsystem is used to enable and reconfigure clocks. To enable the <code>CLK</code> subsystem, support for the platform's U-Boot clock driver will need to be added. See the configuration of the clock driver for the Avnet MaaXBoard in the library's <code>CMakeLists.txt</code> file as an example.</p>
<p>In many cases it may be possible to support devices without the need to add support for a clock driver. Simple devices, e.g. GPIO, may not use a clock source. Even for more complex devices that use a clock source, it may be possible for the device to function without providing a clock driver; e.g. if the device was previously set up and used by the bootloader prior to entry to seL4 then it is likely that the required clocks have already been configured and enabled.</p>
<h3 id="pin-multiplexing-iomux"><a class="header" href="#pin-multiplexing-iomux">Pin Multiplexing (IOMUX)</a></h3>
<p>SoCs typically contain a lot of functionality but a have limited number of pins (or pads). Pin multiplexing is used to configure pins for a specific purpose. An IOMUX driver must be supplied to allow the library to configure the pins from the default configuration.</p>
<p>As with the clock driver, in many cases it may be possible to support devices without the need to add support for an IOMUX driver. For example, if a device was previously set up and used by the bootloader prior to entry to seL4 then it is likely that the required pin configuration has already been configured.</p>
<h3 id="gpio"><a class="header" href="#gpio">GPIO</a></h3>
<p>Many drivers rely upon the availability of a GPIO driver to function correctly. For example: an MMC driver may use GPIO for card-detect and write-protect sensing; an Ethernet driver may use GPIO to reset an external PHY; an SPI driver may use GPIO for the chip select signal, etc.</p>
<p>As such it may be necessary to provide a GPIO driver for other drivers to function correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-extension---new-driver"><a class="header" href="#library-extension---new-driver">Library Extension - New Driver</a></h1>
<p>This section provides guidance on the addition of a new device driver to support a device on an existing platform.</p>
<p>Adding support for a new device can be broken down into logical steps:</p>
<ol>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#identification-of-u-boot-device-driver">Identification of U-Boot Device Driver</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#updating-cmakeliststxt">Updating the library <code>CMakeLists.txt</code> to support the device driver</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#associating-driver-with-platform">Associating the device driver with an existing platform</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#resolving-compilation-issues">Resolving compilation issues</a></p>
</li>
<li>
<p><a href="activity/device_drivers/uboot_library_add_driver.html#updating-sel4-application">Updating an seL4 application to access the device</a></p>
</li>
</ol>
<p>To further support this topic, appendices have been added to provide <a href="activity/device_drivers/./appendices/add_driver_worked_example.html">a worked example</a> and to discuss <a href="activity/device_drivers/./appendices/driver_troubleshooting.html">troubleshooting and common issues</a> that may be encountered.</p>
<h2 id="identification-of-u-boot-device-driver"><a class="header" href="#identification-of-u-boot-device-driver">Identification of U-Boot Device Driver</a></h2>
<p>The first step in adding a new device driver to the library is to positively identify the U-Boot source file providing the required support. U-Boot declares drivers through use of a macro of the following format:</p>
<pre><code class="language-c">U_BOOT_DRIVER(&lt;driver_id&gt;) = {
    .name = "&lt;driver_name&gt;",
    .id = UCLASS_&lt;driver_uclass_id&gt;,
    ...
};
</code></pre>
<p>An example of such a declaration from the GPIO driver for the Avnet MaaXBoard can be found in the U-Boot source code within file <code>drivers/gpio/mxc_gpio.c</code>.</p>
<p>If a build of U-Boot with support for the desired device is available, the name of the device driver can be obtained through use of U-Boot's <code>dm tree</code> command.</p>
<p>For example, to determine the GPIO device driver for a platform the following <code>dm tree</code> output would identify that the U-Boot driver with a <code>&lt;driver_name&gt;</code> of <code>gpio_mxc</code> provides the desired support. Note that the name of the device (as per the platform's device tree) is provided in the <code>Name</code> column whilst the <code>&lt;driver_name&gt;</code> is provided in the <code>Driver</code> column.</p>
<pre><code class="language-text">u-boot=&gt; dm tree
 Class     Index  Probed  Driver                Name
-----------------------------------------------------------
 root          0  [ + ]   root_driver           root_driver
 simple_bus    0  [ + ]   simple_bus            `-- soc@0
 simple_bus    1  [ + ]   simple_bus                |-- bus@30000000
 gpio          0  [ + ]   gpio_mxc                  |   |-- gpio@30200000
 gpio          1  [   ]   gpio_mxc                  |   |-- gpio@30210000
 gpio          2  [   ]   gpio_mxc                  |   |-- gpio@30220000
 gpio          3  [   ]   gpio_mxc                  |   |-- gpio@30230000
 gpio          4  [   ]   gpio_mxc                  |   |-- gpio@30240000
 ...
</code></pre>
<p>If no such build of U-Boot is available, the device driver can be obtained through manual matching of the <code>compatible</code> strings between the platform's device tree and a device driver.</p>
<p>For example, from the following device tree excerpt it can be seen that the GPIO device is compatible with a device driver that advertises compatibility to either <code>fsl,imx8mq-gpio</code> or <code>fsl,imx35-gpio</code> devices.</p>
<pre><code class="language-text">gpio@30200000 {
    compatible = "fsl,imx8mq-gpio\0fsl,imx35-gpio";
    ...
};
</code></pre>
<p>Performing a textual search for these compatibility strings within the U-Boot source code provides the following match for the <code>fsl,imx35-gpio</code> compatibility string:</p>
<pre><code class="language-c">static const struct udevice_id mxc_gpio_ids[] = {
    { .compatible = "fsl,imx35-gpio" },
    { }
};

U_BOOT_DRIVER(gpio_mxc) = {
    .name = "gpio_mxc",
    .id = UCLASS_GPIO,
    ...
    .of_match = mxc_gpio_ids,
    ...
};
</code></pre>
<p>Through either method, the U-Boot source file declaring the driver can be identified.</p>
<h2 id="updating-cmakeliststxt"><a class="header" href="#updating-cmakeliststxt">Updating <code>CMakeLists.txt</code></a></h2>
<p>Once the source file declaring the driver has been established, this information can be captured in the library CMake file (<code>CMakeLists.txt</code>).</p>
<p>The CMake file contains sections devoted to each class of driver (also known as a <code>UCLASS</code> in U-Boot), e.g. Ethernet drivers, MMC drivers, etc. If the driver to be added is of a previously unsupported class then a new section will need to be added; this will typically have the following structure (using the GPIO driver class as an example supporting a single driver):</p>
<pre><code class="language-makefile">#############################
# Settings for GPIO drivers #
#############################

if(gpio_driver MATCHES "none")
    # Nothing to do
else()
    # Enable GPIO support
    add_definitions("-DCONFIG_DM_GPIO=1")
    add_definitions("-DCONFIG_GPIO_EXTRA_HEADER=1")
    add_definitions("-DCONFIG_CMD_GPIO_READ=1")
    # Generic GPIO source files
    list(APPEND uboot_deps uboot/cmd/gpio.c)
    list(APPEND uboot_deps uboot/drivers/gpio/gpio-uclass.c)

    # Driver specific settings / files
    if(gpio_driver MATCHES "gpio_mxc")
        list(APPEND uboot_deps uboot/drivers/gpio/mxc_gpio.c)
    else()
        message(FATAL_ERROR "Unrecognised GPIO driver. Aborting.")
    endif()
endif()
</code></pre>
<p>This structure allows configuration settings to be defined, such as configuration macros and source files, which are set regardless of the driver to be used, as well as configuration settings specific to each driver.</p>
<p>To identify the required configuration macros (using <code>add_definitions("-D&lt;macro_name&gt;=1")</code>) it is suggested that the macros generated by a build of U-Boot are examined (contained in the <code>.config</code> file following configuration of U-Boot). If a build of U-Boot is unavailable, the <code>defconfig</code> file for the platform can be examined (see U-Boot files <code>config/&lt;platform&gt;_defconfig</code>). Alternatively, how the configuration macros themselves are used within the U-Boot source code can be examined (see instances of <code>#if ...</code>).</p>
<p>For a new driver class, it is recommended that two source files are listed for all drivers (using <code>list(APPEND uboot_deps &lt;file&gt;)</code>):</p>
<ol>
<li>The source file declaring U-Boot commands related to the driver class. For example, U-Boot commands related to GPIO are stored in the <code>uboot/cmd/gpio.c</code> file.</li>
<li>The source file declaring the UCLASS driver for the driver class. A UCLASS driver is declared in U-Boot using the <code>UCLASS_DRIVER</code> macro. For example, the U-Boot GPIO UCLASS driver is declared in the <code>uboot/drivers/gpio/gpio-uclass.c</code> file.</li>
</ol>
<p>For a new driver it is recommended that the single source file declaring the driver (as identified in the <a href="activity/device_drivers/uboot_library_add_driver.html#identification-of-u-boot-device-driver">previous step</a>) is set.</p>
<p>It is accepted at this stage that the set of source files may not be complete; this is resolved in a later step.</p>
<p>Note that by convention, the driver naming used in <code>CMakeLists.txt</code> matches the driver name used by U-Boot, e.g. in its <code>dm tree</code> output (e.g. <code>gpio_mxc</code>).</p>
<h2 id="associating-driver-with-platform"><a class="header" href="#associating-driver-with-platform">Associating Driver With Platform</a></h2>
<p>To associate the driver with the platform, the following changes need to be made.</p>
<h3 id="cmakeliststxt"><a class="header" href="#cmakeliststxt"><code>CMakeLists.txt</code></a></h3>
<p>Within the platform specific section of the library <code>CMakeLists.txt</code> file, the variable holding the selected driver for the driver class must be set. For example, if a GPIO driver named <code>gpio_foo</code> has been added for platform <code>foo</code> then the following would be added:</p>
<pre><code class="language-makefile">    # Set up the applicable drivers and platform dependent configuration.
    if(KernelPlatImx8mq)
        ...
    elseif("${KernelPlatform}" STREQUAL "foo")
        # Platform specific settings for the Foo board.
+       set(gpio_driver "gpio_foo")
    else()
        message(FATAL_ERROR "Unsupported platform. Aborting.")
    endif()
</code></pre>
<h3 id="plat_driver_datah"><a class="header" href="#plat_driver_datah"><code>plat_driver_data.h</code></a></h3>
<p>The <code>plat_driver_data.h</code> and <code>plat_driver_data.c</code> files are used to create arrays of objects, such as drivers or commands, that U-Boot normally stores in dedicated linker sections (see <a href="activity/device_drivers/uboot_driver_library.html#linker-lists">documentation on linker lists</a> for details). The objects are declared in U-Boot source files via macros of the form <code>U_BOOT_&lt;object_type&gt; = { ... };</code>. All objects that the library needs to access must be declared and enumerated in  <code>plat_driver_data.h</code> and added to the <code>driver_data</code> structure within <code>plat_driver_data.c</code>.</p>
<p>Within the platform's <code>include/plat/&lt;platform&gt;/plat_driver_data.h</code> file, the new objects from the added source files (e.g. driver, UCLASS driver, commands, etc.) need to be declared, and the counts of each class of object needs to be updated. It should be noted that sometimes multiple drivers or UCLASS drivers are required to support a single device.</p>
<p>For example, if a GPIO driver were to be added then it is expected that the GPIO driver, the GPIO UCLASS driver, and the GPIO command objects would be added as follows:</p>
<pre><code class="language-c">extern struct uclass_driver _u_boot_uclass_driver__gpio;
extern struct driver        _u_boot_driver__gpio_foo;
extern struct cmd_tbl       _u_boot_cmd__gpio;
</code></pre>
<p>Each declaration is of the form <code>extern struct &lt;type&gt; _u_boot_&lt;class&gt;__&lt;name&gt;</code> to match the declaration generated by the expansion of the <code>U_BOOT_&lt;object_Type&gt;</code> macro, where:</p>
<ul>
<li><code>&lt;name&gt;</code> is the parameter provided to the macro that declared the object, e.g. a driver is declared with <code>U_BOOT_DRIVER(&lt;name&gt;)</code>;</li>
<li><code>&lt;type&gt;</code> and <code>&lt;class&gt;</code> directly correspond to the type of object. Worked examples of the correct format for each object type are provided in the Avnet MaaXBoard's <code>plat_driver_data.h</code> file. Alternatively, the format for each type of object can be determined from the expansion of the macro for that object type; e.g. for a driver, see the expansion of <code>#define U_BOOT_DRIVER</code>.</li>
</ul>
<h3 id="plat_driver_datac"><a class="header" href="#plat_driver_datac"><code>plat_driver_data.c</code></a></h3>
<p>Within the platform's <code>include/plat/&lt;platform&gt;/plat_driver_data.c</code> file, the objects declared in the <code>plat_driver_data.h</code> file need to be added to the <code>driver_data</code> global structure. A worked example covering multiple object types is provided in the Avnet MaaXBoard's <code>plat_driver_data.c</code> file.</p>
<h2 id="resolving-compilation-issues"><a class="header" href="#resolving-compilation-issues">Resolving Compilation Issues</a></h2>
<p>At this stage, compilation of the library should be attempted, e.g. through compilation of the <code>uboot-driver-example</code> test application.</p>
<p>It is expected that the set of source files referenced in the library <code>CMakeLists.txt</code> may not be complete, leading to compilation or linker errors;  whilst the source files declaring the driver, UCLASS driver and commands have been added, these may rely upon routines from source files not currently referenced.</p>
<p>For each error some judgement needs to be made:</p>
<ul>
<li>
<p>If the required routine is fundamental to correct operation of the driver (this is the normal case) then the source file should be added to the <code>CMakeLists.txt</code> section for the driver class. It must be determined by the developer whether the source file is likely to be required by all drivers of the driver class or is specific to the driver.</p>
</li>
<li>
<p>If the required routine is not required, e.g. it can be seen that it should never be called or a 'null' implementation would be sufficient, then the routine can be added to the wrapper file <code>src/wrapper/unimplemented.c</code>.</p>
</li>
<li>
<p>If an alternative implementation of the routine / source file needs to be provided, e.g. because the original implementation is incompatible with use within the context of an seL4 user-mode application, then a stub version of the source file can be added to the <code>uboot_stub</code> folder.</p>
</li>
</ul>
<h2 id="updating-sel4-application"><a class="header" href="#updating-sel4-application">Updating seL4 Application</a></h2>
<p>At this stage, the library with the newly added driver should compile cleanly.</p>
<p>What remains is to update the application utilising the library to:</p>
<ol>
<li>
<p>Ensure that seL4 permits access to the necessary devices from the platform's device tree; this is performed through the configuration of the application's CAmkES project file or Microkit's system file. For a worked example, see the  <code>uboot-driver-example.camkes</code> or <code>uboot-driver-example.system</code> file from the <code>uboot-driver-example</code> <a href="activity/device_drivers/uboot_driver_usage.html#test-application-uboot-driver-example">test application</a>.</p>
</li>
<li>
<p>Provide the identity of those devices from the platform's device tree to the library; this is performed by providing the names of the devices when initialising the library through the <code>initialise_uboot_drivers</code> interface on the library's public API. Note that only those devices from the device tree listed in the call to <code>initialise_uboot_drivers</code> will be used by the library; all other devices in the device tree will be considered to be disabled.</p>
</li>
</ol>
<h2 id="appendices-1"><a class="header" href="#appendices-1">Appendices</a></h2>
<ul>
<li><a href="activity/device_drivers/./appendices/add_driver_worked_example.html">Worked Example - Adding a Device Driver</a></li>
<li><a href="activity/device_drivers/./appendices/driver_troubleshooting.html">Library Extension - Troubleshooting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-4"><a class="header" href="#todo-4">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-5"><a class="header" href="#todo-5">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-6"><a class="header" href="#todo-6">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-7"><a class="header" href="#todo-7">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hdmi-driver"><a class="header" href="#hdmi-driver">HDMI Driver</a></h1>
<p>For this task the aim was to create an hdmi display driver using our current devkit setup. For inspiration we chose to look at U-Boot’s implementation of an imx8m display driver. We chose to look at U-Boot’s solution compared to the linux contribution because it is BSD licensed, less fully featured and simpler to understand.</p>
<h2 id="displaying-a-static-image"><a class="header" href="#displaying-a-static-image">Displaying a static image</a></h2>
<p>The first step involved understanding the basics of display drivers so that we could define our goals for the project. The first goal was to understand U-Boot’s display driver and to set up our memory regions for the frame buffer and the physical devices required by the driver. After building and running the U-Boot example, we looked through the source code and found relevant sections in IMX8M technical specification to get a better understanding of how to write the display driver.</p>
<p>Through reading the technical specification we learnt that the two main components of the Maaxboard needed for the driver are the DCSS (Display Controller Subsystem) and the HDMI TX Controller. With this information we were able to understand the purpose of the memory register read and write operations and which register bits needed to be set for specific functionality. We decided to use one protection domain for the simplicity of having one area to handle all operations.</p>
<p>After gaining a deeper understanding of Maaxboard and U-Boots implementation, we set values for the essential memory registers including where to set the address of the frame buffer to. For the framebuffer, we defined a region of memory that was large enough for our currently selected screen resolution and bit depth. <strong>(Talk about existing DMA library)</strong></p>
<p>In order to read and write from specific memory registers, they must be explicitly defined in the system file for the PD that they are being accessed from. This is an essential concept to grasp when working with microkit. The majority of the code was taken from U-Boot, so the main focus of this part of the task was to set up the parts of the code that directly interfaced with the hardware. For other projects this could include registering and handling interrupts.</p>
<p>Our initial display configuration had a screen resolution of 1280x720 and a colour depth of 32 bit RGB. This meant that each pixel was composed of 32 bits with 8 bits reserved for each colour and an additional alpha channel for colour transparency. With this information, we were able to create a simple image displaying 4 colours red, green, blue and white as 4 equally spaced bars across the screen. We then experimented with different screen resolutions which involved re-defining the size of the framebuffer so that it could accommodate larger screen resolutions.</p>
<h2 id="displaying-a-moving-image"><a class="header" href="#displaying-a-moving-image">Displaying a moving image</a></h2>
<p>The next goal was to display a moving image, which first involved learning about the theory of double buffering and understanding the capabilities of the Maaxboard’s DCSS. Double buffering makes use of two buffers. The first stores the current frame, whilst the second buffer is used to store the next frame. Whilst the current frame is being displayed the second buffer is being written to. During the window of time where the image on screen is not actively being redrawn, the pointers to each buffer are swapped.</p>
<p>U-Boot’s implementation did not provide any capability to drive video, so we needed to investigate and understand the technical specification in greater detail. We found a component of the DCSS called the Context Loader which can be configured to change various parts of the display state at specific timing intervals. This would act as the trigger to switch the pointers to each frame buffer.</p>
<p>For our implementation we decided to use two PD’s. One PD contains the display driver, consisting of the DCSS and the HDMI TX Controller. The other PD contains the api and examples which demonstrate different use cases of the driver. The system is designed such that the two PD’s communicate with each other through notifications and make use of a single shared DMA memory region. This memory region is split into different parts which are accessed by a pointer with a specific offset for different parts of the memory e.g frame buffer 1, frame buffer 2. This approach was implemented for simplicity so that the memory is easily accessible, however it would be better to define individual DMA regions for specific tasks, so that certain parts of the memory are only exposed to the PD that should have access to it.</p>
<p>The initial time to redraw the buffer was slow because we were writing 8 bits of the 32 bit pixel at a time. To combat this we optimised the code logic reducing loops and where possible wrote 16, 32 or 64 bits at a time to minimise the amount of separate cpu instructions. This example is limited by the technology that we have available to us. For fully fledged display drivers, there will be extra bits of hardware that will be able to process the frame, drastically increasing processing time.</p>
<p>For moving images a visible redraw is seen when switching between frames which is most noticeable when the entire screen has changed. Multiple attempts have been made to combat this issue, which have been listed in the repo for this activity.</p>
<p>The API contains the following examples:</p>
<ul>
<li>static_image - Displays 4 colour bars on the screen.</li>
<li>resolution_change - Displays a square of the same size in pixels one after another at three different resolutions.</li>
<li>rotating_bars - Displays 4 colour bars rotating across the screen.</li>
<li>moving_square - A small square that moves around the screen, changing direction each time it hits the side of the screen.</li>
</ul>
<p>TO DO:</p>
<ul>
<li>Talk about the firmware being used and the config options that need to be disabled.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-linux-guest"><a class="header" href="#single-linux-guest">Single Linux guest</a></h1>
<p>For this task, the goal was to load up a virtual machine (VM) on a host with serial TTY passthrough. Our starting point for this activity was to rework an example from the Trustworthy Systems libvmm repository so that it runs on the Maaxboard. This repo contains a virtual machine monitor for the seL4 microkernel with various examples built for the Odroid board and the open source emulator Qemu. Libvmm provides a virtual machine monitor (VMM) which in our example is used to start and manage the guest VM.</p>
<p>To create the linux kernel image we used buildroot. Buildroot is an open source project that automates the process of building a complete and bootable Linux environment for an embedded system. We chose buildroot because the process to create a basic linux kernel image is straightforward. <strong>(More on build root)</strong></p>
<p>The VM doesn’t necessarily know it's being virtualised, so it will try to perform read and write operations on certain devices and memory regions that it shouldn’t have access to. When setting up the project there were a number of virtual memory faults, which were caused by the guest VM trying to access devices that it was not exposed to in the system file. Generally, there are three approaches to fix this.</p>
<p>One approach is to disable the device node in the device tree so that it does not try to access the device. This approach may not be feasible because the memory region may be required by a specific process in your system or dependent on another device in order to function. Another approach is to disable the device driver in the guest configuration (This can be configured with buildroot). The last approach is to utilise device “pass-through” which is where the address of the device is mapped into the guest VM allowing access directly to the device. Ideally, in a virtualised environment the guest VM shouldn’t have access to physical devices. However, for simplicity and with the absence of a serial driver it was necessary to pass through the serial device and the devices that depend on it.</p>
<p>Two memory regions that are required to be passed through for the use of libvmm and our example are the RAM and the Generic Interrupt Controller Virtual CPU (GIC-VCPU). In order for the linux guest to be able to run, it needs to have an area of contiguous space directly allocated for its own RAM. In its current implementation libvmm expects the physical memory address and the virtual memory area for the RAM to be at the same address. At a minimum there needed to be enough memory to load the kernel image and other associated binaries. The size and position of this memory need to reflect the memory node in the device tree. The GIC-VCPU is used to signal virtual interrupts. Libvmm provides a driver to handle this device which is necessary for running any guest operating system with libvmm.. <strong>(more on memory? - dual tty activity will detail memory sizing issues)</strong></p>
<ul>
<li>Another issue we faced when setting up the VM was SMC…</li>
<li>Talk about how to run the project and how it works generally. Why is this useful, what do we have here?</li>
<li>Did anything trip us up on the way?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vmm-with-dual-linux-guests-and-tty-multiplex"><a class="header" href="#vmm-with-dual-linux-guests-and-tty-multiplex">VMM with dual linux guests and TTY Multiplex</a></h1>
<p>For this activity the goal was to load two linux Virtual Machines (VM) on one host. This was achieved by building upon our previous single guest example and taking inspiration from an existing libvmm contribution that makes use of VirtIO console. For this example five Protection Domains (PD) are used. Two PD’s are used for each virtual machine, one for the UART serial driver and the remaining two for the TX and RX communication to handle the serial data. <strong>(Explain RX and TX briefly)</strong></p>
<p>VirtIO is an interface used by virtual machines to use its hosts’ devices through the means of virtual devices. The main role of these devices is to get data to and from the hosts physical hardware. VirtIO consists of three main parts: front-end drivers, back-end devices, and VirtQueues.</p>
<p>Typically, the front end drivers exist in the hosts kernel. These can be turned on in the config file when creating a linux kernel with buildroot. They are responsible for accepting I/O requests from user processes, transfering I/O requests to its corresponding back-end VirtIO device and retrieving completed requests from the back-end device. The back-end devices typically exist in the VMM. Libvmm provides implementations for console, network, block and sound devices. They are responsible for accepting I/O requests from the corresponding front-end driver,
handling the requests by offloading the I/O operations to the host’s physical hardware,
and making the processed and requested data available to the VirtIO driver.</p>
<p>VirtQueues are shared memory regions that are used by a VirtIO front-end driver and back-end device pair. A VRing is a data structure contained within the VirtQueue that facilitates data transfer between the VirtIO device and driver. Libvmm follows version 1.2 of the VirtIO specification and uses the seL4 Device Driver Framework (SDDF) to implement the VirtQueues for specific devices.</p>
<p>In our example, we make use of the VirtIO Console device to handle serial I/O data. To use VirtIO Console a node was created in the device tree and a multiple settings turned on in the linux kernel config file. In the “chosen” node of the device tree, the stdout path and the boot args also needed to be set up specifically for the console device. In our initial implementation we passed through 8 additional devices. We then managed to remove the need for 7 of them by disabling them in the device tree. The remaining “gpc” device was needed by virtio-console, but at this stage it is unknown why.</p>
<ul>
<li>Memory considerations for two linuxes. (Where this is set up, tweaking was needed)</li>
<li>Talk about the timer, priorities of the two VM’s</li>
<li>What was the missing thing that bill found so that we could get set up?</li>
<li>add in more failures and attempts at things</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-8"><a class="header" href="#todo-8">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="licensing"><a class="header" href="#licensing">Licensing</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
